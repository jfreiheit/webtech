{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Web-Technologien \u00b6 Herzlich willkommen zur WebTech-Veranstaltung! Grober Inhalt \u00b6 In dieser Veranstaltung lernen Sie, was das World Wide Web ist und wie man eigene Webseiten und -anwendungen realisiert. Sie lernen die Protokolle und Sprachen http , HTML , CSS und JavaScript kennen und machen sich mit Angular , node.js und REST vertraut. Organisatorisches \u00b6 Zur erfolgreichen Durchf\u00fchrung der Veranstaltung m\u00fcssen die \u00dcbungen l\u00f6sen und zu den jeweiligen Fristen per Git auf einen Server (GitHub oder GitLab) laden. Am Ende des Semesters ist eine Aufgabe abzugeben. Diese Aufgabe wird bewertet. Die Bewertung entspricht dann der Modulnote. Hier sind die \u00dcbungen beschrieben, die Sie in jeder Woche ausf\u00fchren sollen. Damit Sie dies erfolgreich erledigen k\u00f6nnen, ist jeweils angegeben, welche Themen Sie daf\u00fcr durcharbeiten m\u00fcssen. Das Durcharbeiten der jeweiligen Themen entspricht jeweils einer Vorlesung. Diese wird also selbst\u00e4ndig durchgef\u00fchrt. F\u00fcr die Kommunikation untereinander verwenden wir Slack . Dort k\u00f6nnen Sie alle inhaltlichen und organisatorischen Fragen stellen. Ich f\u00e4nde es gut, wenn ich dort m\u00f6glichst wenig Fragen - zumindest die inhaltlichen - beantworten m\u00fcsste, sondern eine Art internes Diskussionsforum entsteht. Es ist sehr gew\u00fcnscht, dort Fragen zu stellen und noch mehr gew\u00fcnscht, diese von Ihnen dort beantwortet zu sehen. Damit w\u00e4re allen geholfen und ich kann besser erkennen, wo noch Nachhol- bzw. Erl\u00e4uterungsbedarf bei den meisten besteht. Wochenplan \u00b6 Woche 1 Hierbei handelt es sich um reines Selbstudium. Erledigen Sie \u00dcbungsaufgabe 1 ! \u00dcbungen \u00b6 \u00dcbungsaufgabe 1 Arbeiten Sie im Abschnitt Angular die Abschnitte Erstes Projekt erstellen und Angular-Projektstruktur durch. Sie m\u00fcssen dazu Angular installieren, eine Integrierte Entwicklungsumgebung und die passenden Developer Tools . Aufgabe \u00b6 Am Ende des Kurses geben Sie eine Webanwendung ab. \u00dcberlegen Sie sich fr\u00fch, was Sie implementieren wollen. Ihrer Kreativit\u00e4t sind keine Grenzen gesetzt. Es k\u00f6nnen 2 Studentinnen gemeinsam ein Projekt durchf\u00fchren und abgeben. Sie erhalten dann die gleiche Note. Mindestanforderungen Folgende Anforderungen werden an Ihr Projekt gestellt: das Frontend soll mit Angular entwickelt werden, das Backend mit Node.js, als Datenbank soll MySQL verwendet werden, es soll CRUD implementiert sein, d.h. Sie ben\u00f6tigen eine Komponente zur Erstellung und Speicherung eines Datenbankeintrages ( C reate), eine Komponente zur \u00c4nderung eines Datenbankeintrages ( U pdate), eine Komponente zur Anzeige aller Datenbankeintr\u00e4ge ( R ead), eine Komponente zum L\u00f6schen eines Datenbankeintrages ( D elete). Datenbankeintr\u00e4ge k\u00f6nnen B\u00fccher, CDs, ToDos, Einkaufslisten, Vorlesungen, K\u00fchlschrankinhalte usw. sein - wie gesagt, Ihrer Kreativit\u00e4t sind keine Grenzen gesetzt. Verwenden Sie ein CSS-Framework, wie z.B. Materialize, Bootstrap o.\u00e4.! Ihre Anwendung soll modern aussehen.","title":"Home"},{"location":"#web-technologien","text":"Herzlich willkommen zur WebTech-Veranstaltung!","title":"Web-Technologien"},{"location":"#grober-inhalt","text":"In dieser Veranstaltung lernen Sie, was das World Wide Web ist und wie man eigene Webseiten und -anwendungen realisiert. Sie lernen die Protokolle und Sprachen http , HTML , CSS und JavaScript kennen und machen sich mit Angular , node.js und REST vertraut.","title":"Grober Inhalt"},{"location":"#organisatorisches","text":"Zur erfolgreichen Durchf\u00fchrung der Veranstaltung m\u00fcssen die \u00dcbungen l\u00f6sen und zu den jeweiligen Fristen per Git auf einen Server (GitHub oder GitLab) laden. Am Ende des Semesters ist eine Aufgabe abzugeben. Diese Aufgabe wird bewertet. Die Bewertung entspricht dann der Modulnote. Hier sind die \u00dcbungen beschrieben, die Sie in jeder Woche ausf\u00fchren sollen. Damit Sie dies erfolgreich erledigen k\u00f6nnen, ist jeweils angegeben, welche Themen Sie daf\u00fcr durcharbeiten m\u00fcssen. Das Durcharbeiten der jeweiligen Themen entspricht jeweils einer Vorlesung. Diese wird also selbst\u00e4ndig durchgef\u00fchrt. F\u00fcr die Kommunikation untereinander verwenden wir Slack . Dort k\u00f6nnen Sie alle inhaltlichen und organisatorischen Fragen stellen. Ich f\u00e4nde es gut, wenn ich dort m\u00f6glichst wenig Fragen - zumindest die inhaltlichen - beantworten m\u00fcsste, sondern eine Art internes Diskussionsforum entsteht. Es ist sehr gew\u00fcnscht, dort Fragen zu stellen und noch mehr gew\u00fcnscht, diese von Ihnen dort beantwortet zu sehen. Damit w\u00e4re allen geholfen und ich kann besser erkennen, wo noch Nachhol- bzw. Erl\u00e4uterungsbedarf bei den meisten besteht.","title":"Organisatorisches"},{"location":"#wochenplan","text":"Woche 1 Hierbei handelt es sich um reines Selbstudium. Erledigen Sie \u00dcbungsaufgabe 1 !","title":"Wochenplan"},{"location":"#ubungen","text":"\u00dcbungsaufgabe 1 Arbeiten Sie im Abschnitt Angular die Abschnitte Erstes Projekt erstellen und Angular-Projektstruktur durch. Sie m\u00fcssen dazu Angular installieren, eine Integrierte Entwicklungsumgebung und die passenden Developer Tools .","title":"\u00dcbungen"},{"location":"#aufgabe","text":"Am Ende des Kurses geben Sie eine Webanwendung ab. \u00dcberlegen Sie sich fr\u00fch, was Sie implementieren wollen. Ihrer Kreativit\u00e4t sind keine Grenzen gesetzt. Es k\u00f6nnen 2 Studentinnen gemeinsam ein Projekt durchf\u00fchren und abgeben. Sie erhalten dann die gleiche Note. Mindestanforderungen Folgende Anforderungen werden an Ihr Projekt gestellt: das Frontend soll mit Angular entwickelt werden, das Backend mit Node.js, als Datenbank soll MySQL verwendet werden, es soll CRUD implementiert sein, d.h. Sie ben\u00f6tigen eine Komponente zur Erstellung und Speicherung eines Datenbankeintrages ( C reate), eine Komponente zur \u00c4nderung eines Datenbankeintrages ( U pdate), eine Komponente zur Anzeige aller Datenbankeintr\u00e4ge ( R ead), eine Komponente zum L\u00f6schen eines Datenbankeintrages ( D elete). Datenbankeintr\u00e4ge k\u00f6nnen B\u00fccher, CDs, ToDos, Einkaufslisten, Vorlesungen, K\u00fchlschrankinhalte usw. sein - wie gesagt, Ihrer Kreativit\u00e4t sind keine Grenzen gesetzt. Verwenden Sie ein CSS-Framework, wie z.B. Materialize, Bootstrap o.\u00e4.! Ihre Anwendung soll modern aussehen.","title":"Aufgabe"},{"location":"angular/","text":"Angular \u00b6 Angular geh\u00f6rt neben React.js und Vue.js zu den meisteverwendeten Frameworks f\u00fcr die Entwicklung sogenannter Single-Page-Applikationen . In einer Single-Page-Applikation wird eine Seite vom Webserver geladen und diese Seite durch unterschiedliche Inhalte bef\u00fcllt, je nach Nutzerinteraktion. Diese Inhalte werden in Angular durch sogenannte Komponenten bereitsgestellt. Komponenten sind die Grundbausteine einer Angular-Anwendung. Das erste Release von Angular erschien 2010 (damals noch unter dem Namen AngularJS, ab Version 2 nur noch Angular). React und Vue kamen 2013 bzw. 2014 erstmalig heraus. Angular wird haupts\u00e4chlich von Google, React haupts\u00e4chlich von Facebook und Vue als Community-Version entwickelt. Alle drei Frameworks stehen unter MIT-Lizent . Neben HTML und CSS verwendet Angular TypeScript . TypeScript ist eine Obermenge von JavaScript. Das bedeutet, dass jeder JavaScript-Code auch TypeScript ist, aber nicht umgekehrt. TypeScript-Code wird compiliert und erzeugt JavaScript-Code, der vom Browser ausgef\u00fchrt werden kann. Im Gegensatz zu JavaScript ist TypeScript typsicher und klar objektorientiert. Erstes Projekt erstellen \u00b6 Eine Angularanwendung besteht haupts\u00e4chlich aus Komponenten und Services. Um die Anwendung selbst sowie Komponenten und Services zu erstellen, wird am besten das Command Line Interface for Angular (Angular CLI) verwendet. \u00d6ffnen Sie ein Terminal (Windows-Nutzerinnen sollten die Git-Bash verwenden, die Sie bereits mit Git installiert haben). Wechseln Sie im Terminal in das Verzeichnis, das Ihre Projekte enthalten soll. F\u00fcr das Wechseln in andere Verzeichnisse nutzen Sie den cd Befehl (change directory). Um die Anwendung \"first\" zu erzeugen, geben Sie folgenden Befehl in das Terminal ein: ng new first ng steht f\u00fcr Angular. Mit dem Attribut new geben Sie an, dass Sie ein neues Projekt erzeugen wollen. first ist der Name des Projektes. Wenn Sie gefragt werden, ob Sie Angular routing verwenden m\u00f6chten, geben Sie ein y ein. Wenn Sie nach dem stylesheet format gefragt werden, k\u00f6nnen Sie CSS einfach mit Enter best\u00e4tigen. Wenn alles geklappt hat, erhalten Sie im Terminal eine Ausgabe in der Form: Es entsteht ein Ordner first in Ihrem Projekte-Verzeichnis. Wechseln Sie in dieses Verzeichnis: cd first F\u00fchren Sie darin den Befehl: npm install aus. Damit werden alle Abh\u00e4ngigkeiten, die in der Datei package.json definiert sind, geladen und das node_modules -Verzeichnis erstellt. Siehe z.B. hier . Danach geben Sie ng serve ein. Es werden die entsprechenden TypeScript-Dateien compiliert und es erscheint am Ende eine Ausgabe, wie z.B. ** Angular Live Development Server is listening on localhost:4200, open your browser on http://localhost:4200/ ** :Compiled successfully. \u00d6ffnen Sie Ihren Browser und geben Sie als URL http://localhost:4200 ein. Folgende Seite sollte erscheinen: Success Fertig! Sie haben Ihr erstes Angular-Projekt erstellt. Angular-Projektstruktur \u00b6 \u00d6ffnen Sie die IDE Ihrer Wahl (Screenshots hier mit [PhpStorm] ( https://www.jetbrains.com/de-de/phpstorm/ ). W\u00e4hlen Sie unter Open Project den Projektordner first . Klappen Sie das Projekt first auf, klappen Sie den Ordner src und dann den Ordner app auf. Der Projektexplorer zeigt folgendes Bild: Die meiste Arbeit wird im src -Ordner erledigt. Darin befindet sich (wird sich befinden) der Code unserer Anwendung. Darin der wichtigste Ordner ist der app -Ordner. Hier werden wir unsere Module, Komponenten und Services hinzuf\u00fcgen. In dem assets -Ordner werden Bilder, Icons und Daten abgelegt. Der node_modules -Ordner enth\u00e4lt alle ben\u00f6tigten 3 rd -party-libraries. Welche das sind, wird in der Datei package.json als dependencies definiert. Mithilfe des Befehls npm install werden alle ben\u00f6tigten Module dem Ordner node_modules hinzugef\u00fcgt. Der Ordner environments enth\u00e4lt die notwendigen Konfigurationsinformationen f\u00fcr den development - und den production -Modus. Wir entwickeln zun\u00e4chst im development -Modus. favicon.ico ist das Favicon - ein kleines Icon, das im Reiter erscheint. W\u00e4hlen Sie am besten ein eigenes. index.html ist die Hauptseite. Mithilfe von Angular entwickeln wir eine Single Page Application , d.h. es wird eine einzige HTML-Seite geladen ( index.html ) und jeder weitere Inhalt wird asynchron hinzugef\u00fcgt. styles.css enth\u00e4lt die globalen Stylesheets, d.h. die CSS-Eigenschaften, die f\u00fcr das gesamte Projekt gelten sollen. Die app.component.* -Dateien beschreiben die app-Komponente. Eine Komponente besteht aus einer HTML -, einer CSS - und einer TypeScript -Datei (auch noch eine *.spec.ts , aber die interessiert zun\u00e4chst nicht). \u00d6ffnen Sie in Ihrer IDE die Datei app.component.html . L\u00f6schen Sie den kompletten Inhalt und lassen nur noch <router-outlet></router-outlet> . F\u00fcgen Sie oberhalb von <router-outlet></router-outlet> die Zeile <h1>This is app</h1> ein. Gehen Sie wieder zum Browser und schauen sich den ge\u00f6ffneten Tab mit der URL localhost:4200 an. Es erscheint der folgende Inhalt: \u00d6ffnen Sie die app.component.css -Datei und geben Sie dort h1 { color : red ; } Nach den \u00c4nderungen in app.component.css erscheint der Text der \u00dcberschrift in rot: Zusammenfassung Wir haben die die app.component.html ge\u00e4ndert, um den Inhalt der dargestellten Seite anzupassen und die app.component.css , um \u00c4nderungen an der Darstellung (dem Stil) des Inhalts durchzuf\u00fchren. Komponenten \u00b6 Eine Angular-Anwendung besteht haupts\u00e4chlich aus Komponenten . Jede Anwendung hat eine Hauptkomponente - die sogenannte Root Component. Diese Hauptkomponente ist meistens die AppComponent . Eine Komponente hat eine in sich geschlossene Bedeutung, z.B. ein Formular f\u00fcr Dateneingabe, eine Liste aller Daten oder auch nur ein bestimmtes Element. Eine Komponente besteht aus einer View ( Template ) und einer TypeScript-Klasse. Die AppComponent besteht z.B. aus der app.component.html (der View) und der app.component.ts (der TypeScript-Klasse). Die TypeScript-Klasse k\u00fcmmert sich um die Verwaltung der Daten, die in der View dargestellt und/oder durch Eingaben erzeugt werden. Die TypeScript-Klasse beschreibt die Logik der Komponente. Die View ist der dargestellte Bereich der Komponente, also das, was man im Browser von der Komponente sieht. Neben der *.html - und der *.ts -Datei einer Komponente gibt es auch noch die *.css -Datei (also z.B. app.component.css ). Diese enth\u00e4lt CSS-Eigenschaften, die speziell f\u00fcr die Komponente gelten sollen. Um eine Komponente der gesamten Anwendung als Komponente bekannt zu machen, wird der Decorator @Component verwendet. Decoratoren erkennt man am f\u00fchrenden @ -Zeichen. Sie werden verwendet, um Metadaten der Anwendung zu verwalten. Der typische Aufbau einer Komponente (hier AppComponent - app.component.ts ): @ Component ({ selector : 'app-root' , templateUrl : './app.component.html' , styleUrls : [ './app.component.css' ] }) export class AppComponent { title = 'book-app' ; } Der Selektor gibt an, dass \u00fcberall dort, wo app-root als Elementselektor <app-root> </app-root> verwendet wird, das in app.component.html definerte Template eingesetzt wird. Angenommen, in app.component.html ist der HTML-Code: < h1 > This is app </ h1 > definiert. Dann wird dieser Code als Inhalt in das HTML-Element <app-root> </app-root> eingesetzt: < app-root > < h1 > This is app </ h1 > </ app-root > Wir schauen uns ein ausf\u00fchrlicheres Beispiel im Folgenden an, in dem wir eine neue Komponente erzeugen. Eine neue Komponente erzeugen \u00b6 Mithilfe von Angular-CLI erzeugen wir in unserer App first eine neue Komponente. Wir wechseln dazu im Terminal in den Ordner von first und geben dann ng generate component mycomponent ein. Sp\u00e4ter k\u00fcrzen wir solche Eingaben ab. Anstelle von generate brauchen wir auch nur g zu schreiben. Und anstelle von component gen\u00fcgt c . Das hei\u00dft, wir h\u00e4tten stattdessen auch ng g c mycomponent schreiben k\u00f6nnen. In unserer first App gibt es nun die Komponente mycomponent : Jede Angular-Komponente besteht aus vier Teilen: der TypeScript-Klasse (die *.component.ts -Datei) dem Template (die *.component.html -Datei) den Styles (die *.component.css -Datei) einer Testspezifikation (die *.component.spec.ts -Datei) Jede Komponente wird in der app.module.ts der gesamten Anwendung bekannt gemacht. Das erfolgt mithilfe der Eigenschaft declarations im Decorator @NgModule() : import { BrowserModule } from '@angular/platform-browser' ; import { NgModule } from '@angular/core' ; import { AppRoutingModule } from './app-routing.module' ; import { AppComponent } from './app.component' ; import { MycomponentComponent } from './mycomponent/mycomponent.component' ; @ NgModule ({ declarations : [ AppComponent , MycomponentComponent ], imports : [ BrowserModule , AppRoutingModule ], providers : [], bootstrap : [ AppComponent ] }) export class AppModule { } Das obige Listing zeigt, dass die neue Komponente Mycomponent registriert wurde. Um dieses Eintragen in die app.module.ts m\u00fcssen wir uns aber nicht k\u00fcmmern, das erledigt die Angular-CLI mit der Anweisung zur Erstellung einer neuen Komponente ng generate component newComponent . Doppelklicken Sie im Projektexplorer Ihrer IDE auf die Datei mycomponent.component.ts , um sie zu \u00f6ffnen. Sie enth\u00e4lt den folgenden Quelltext: import { Component , OnInit } from '@angular/core' ; @ Component ({ selector : 'app-mycomponent' , templateUrl : './mycomponent.component.html' , styleUrls : [ './mycomponent.component.css' ] }) export class MycomponentComponent implements OnInit { constructor () { } ngOnInit () : void { } } Wir \u00e4ndern diese Datei zun\u00e4chst nicht und \u00f6ffnen auch noch die mycomponent.component.html . Diese enth\u00e4lt nur ein HTML-Element, einen Absatz: < p > mycomponent works! </ p > Wir \u00e4ndern auch diese Datei zun\u00e4chst nicht und \u00f6ffnen die app.component.html - die HTML-Datei unserer Root-Komponente. Diese sieht derzeit so aus: < h1 > This is app </ h1 > < router-outlet ></ router-outlet > Wir f\u00fcgen in die Datei den Selektor app-mycomponent unserer neuen Mycomponent -Komponente als HTML-Element ein: < h1 > This is app </ h1 > < app-mycomponent ></ app-mycomponent > <!-- eingefuegt --> < router-outlet ></ router-outlet > Dieses Element dient als \"Platzhalter\" f\u00fcr das Template unserer neuen Komponente. Das bedeutet, dass in dieses Element der HTML-Code aus mycomponent.component.html eingef\u00fcgt wird. Wechseln Sie in den Browser auf den Tab mit Ihrer Anwendung ( http://localhost:4200/ ). Sie sehen folgendes Bild: Unterhalb der \u00dcberschrift ( <h1>This is app</h1> ) wurde also der Absatz <p>mycomponent works!</p> eingef\u00fcgt. Wenn Sie sich den Quelltext Ihrer Seite anschauen, z.B. \u00fcber die Entwicklertools Ihres Browsers ( z.B. f\u00fcr Chrome ), dann wird folgender Code sichtbar: Wir k\u00f6nnen hier die Attribute der HTML-Elemente vernachl\u00e4ssigen (also z.B. _nghost-menu-c19 oder ng-version=\"9.0.7\" ). Aber es wird folgende HTML-Struktur sichtbar: < app-root > < h1 > This is app </ h1 > < app-mycomponent > < p > mycomponent works! </ p > </ app-mycomponent > < router-outlet ></ router-outlet > </ app-root > Das Element <app-root> fungiert als Platzhalter f\u00fcr die gesamte App. In dieses Element wird der gesamte Inhalt der Anwendung eingebunden (siehe app.component.html ). Dies ist hier zun\u00e4chst eine \u00dcberschrift <h1> , die von dem Element f\u00fcr die Mycomponent -Komponente gefolgt wird. Das bedeutet, dass in das Element <app-mycomponent> der Inhalt der Komponente Mycomponent eingebunden wird. Das ist hier nur ein Absatz <p> (siehe dazu mycomponent.component.html ). Das Element router-outlet> soll uns an dieser Stelle noch nicht interessieren. Das wird erst interessant, wenn wir \u00fcber das Routing in einer Angular-Anwendung sprechen. Direktiven \u00b6 In Angular gibt es 3 Arten sogenannter Direktiven (engl. Directives ): Komponentendirektiven (Components\u2014directives) Attributdirektiven (Attribute Directives) Strukturdirektiven (Structural-Direktives) Komponentendirektiven sind die meistverwendete Art und bereits in Angular \u2192 Kompnenten betrachtet. Attribut- und Strukturdirektiven k\u00f6nnen als HTML-Attribute verstanden werden, die dem HTML-Element ein zus\u00e4tzliches Verhalten hinzuf\u00fcgt. Attributdirektiven wirken sich das innere Verhalten eines HTML-Elementes aus (z.B. k\u00f6nnen damit CSS-Eigenschaften ge\u00e4ndert, hinzugef\u00fcgt oder gel\u00f6scht werden). Mit Strukturdirektiven kann die Struktur des DOMs ge\u00e4ndert werden (z.B. k\u00f6nnen ganze HTML-Elemente dem DOM-Baum hinzugef\u00fcgt werden). *Strukturdirektiven \u00b6 Strukturdirektiven beginnen immer mit einem Stern * . Die bekanntesten Vertreter sind *ngFor *ngIf *ngSwitch Diese sind auch in angular.io erl\u00e4utert. Wir erl\u00e4utern die darin aufgef\u00fchrten Beispiele und beginnen mit *ngIf : 1 2 3 4 5 6 7 8 < p * ngIf = \"true\" > Expression is true and ngIf is true. This paragraph is in the DOM. </ p > < p * ngIf = \"false\" > Expression is false and ngIf is false. This paragraph is not in the DOM. </ p > Die Direktive *ngIf wird also wie ein Attribut des <p> -Elementes behandelt. Das Attribut *ngIf hat entweder den Wert \"true\" oder den Wert \"false\" . Ja nach Wert des Attributes wird das jeweilige <p> -Element in den DOM-Baum eingebunden. Also entweder das <p> -Element aus den Codezeilen 1 - 4 (bei Wert \"true\" ) oder das <p> -Element aus den Codezeilen 5 - 8 (bei Wert \"false\" ). In einer echten Anwendung ergibt sich der Wert des Attributes/der Direktive meistens aus dem Wert einer boole'schen Variablen oder einem anderen boole'schen Ausdruck. Das nicht dargestellte Element ist auch nicht Teil des DOMs! Es ist also nicht einfach nur auf hide gesetzt, sondern es ist gar nicht im DOM vorhanden. Intern wird aus der *ngIf -Direktive \u00fcbrigens ein sogenanntes Property-Binding : < ng-template [ ngIf ]=\" true \" > < p > Expression is true and ngIf is true. This paragraph is in the DOM. </ p > </ ng-template > < ng-template [ ngIf ]=\" false \" > < p > Expression is false and ngIf is false. This paragraph is not in the DOM. </ p > </ ng-template > Die *ngFor -Direktive ist etwas komplexer als *ngIf . F\u00fcr *ngFor ben\u00f6tigen wir mindestens eine Liste (oder ein Array) und eine Laufvariable, die die Werte aus der Liste annehmen kann. Im folgenden Beispiel ist i unsere laufvariable und [1, 2, 3, 4, 5, 6] unser Array. < div * ngFor = \"let i of [1, 2, 3, 4, 5, 6]\" > {{ i }} </ div > F\u00fcr jeden Wert aus der Liste wird ein eigenes <div> - Element erzeugt. Der DOM-Baum sieht f\u00fcr obiges Beispiel also wie folgt aus (Angular-Attribute weggelassen): < div > 1 </ div > < div > 2 </ div > < div > 3 </ div > < div > 4 </ div > < div > 5 </ div > < div > 6 </ div > Au\u00dferdem stellt *ngFor noch einige Hilfsvariablen zur Verf\u00fcgung, die ebenfalls genutzt werden k\u00f6nnen: index (Index des aktuellen Elementes 0, 1, 2, ... ) first (ist true , wenn erstes Element, sonst false ) last (ist true , wenn letztes Element, sonst false ) even (ist true , wenn Index gerade , sonst false ) odd (ist true , wenn Index ungerade , sonst false ) Folgend ein komplexeres Beispiel unter Verwendung einiger Hilfsvariablen: 1 2 3 4 5 6 7 8 9 < div * ngFor = \"let value of [1, 2, 3, 4, 5, 6]; index as i; first as f; last as l; odd as o;\" > < div * ngIf = \"f\" > Start </ div > < div [ style . color ]=\" o ? ' red ' : ' blue '\" > {{ i }} : {{ value }} </ div > < div * ngIf = \"l\" > Ende </ div > </ div > In Zeile 1 ist unsere Laufvariable durch das Array nun value . Au\u00dferdem wird der jeweilige Wert von index in der Variablen i (Zeilennummer 2 ) gespeichert, der Wert von first in der Variablen f (Zeilennummer 3 ), der Wert von last in der Variablen l (Zeilennummer 4 ) und der Wert von odd in der Variablen o (Zeilennummer 5 ) - die Hilfsvariable even betrachten wir hier nicht, da deren Wert genau der Negation von odd entspricht. In Zeile 6 wenden wir die *ngIf -Direktive an: ein <div> mit dem Inhalt Start wird vor dem ersten Element aus dem Array ausgegeben. F\u00fcr jedes weitere Element nicht mehr. In Zeile 7 erfolgt ein Property Binding : die color -Eigenschaft bekommt einen Wert zugewiesen. Der Wert ist jedoch abh\u00e4ngig davon, ob o wahr ist (dann Wert red ) oder falsch (dann Wert blue ). Zeile 7 zeigt au\u00dferdem wie mithilfe von Interpolation der Wert von i und der Wert von value , getrennt mit : ausgegeben werden. Die Ausgabe ist also: Aufgabe Informieren Sie sich auch \u00fcber die *ngSwitch -Direktive. Implementieren Sie ein Beispiel, in dem Sie die 3 Direktiven *ngIf , *ngFor und *ngSwitch anwenden. {{ Interpolation }} \u00b6 Interpolation ist die einfachste Form des data binding . Syntaktisch erkennt man Interpolation an den doppelten geschweiften Klammern {{ Interpolation }} . Beispiel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { Component } from '@angular/core' ; @ Component ({ selector : 'app-lesson' , template : ` <h1>{{ headline }}</h1> <p>Hier steht {{name}}</p> ` , styleUrls : [ './lesson.component.css' ] }) export class LessonComponent { headline = 'Mein Titel' ; name = 'mein Name' ; } Im obigen Beispiel hat die Komponente LessonComponent zwei Eigenschaften: headline und name . In obiger Komponente wird (zur Anschauung) sogenanntes inline templating verwendet, d.h. es gibt keine eigene lesson.component.html -Datei, in der der HTML-Code steht, sondern der HTML-Code wird direkt in die template -Eigenschaft der Typescript-Datei lesson.component.ts eingef\u00fcgt (siehe Zeilen 5-8 im obigen Beispiel). Der HTML-Code wird in backticks eingefasst ( `` ), nicht zu verwechseln mit den einfachen Anf\u00fchrungsstrichen ( '' ). Damit inline templating m\u00f6glich ist, wird die Komponente mit dem Flag -t erzeugt ( inlineTemplate=true ), d.h. unsere Lesson-Komponente wurde mithilfe der CLI wie folgt erzeugt: ng g c lesson -t Eine Interpolation kann auch Ausdr\u00fccke enthalten, die aufgel\u00f6st werden, z.B. < p > 1 + 2 = {{1 + 2}}. </ p > Man kann mithilfe einer Direktive durch ein Array laufen und jedes einzelne Element mithilfe von Interpolation ausgeben: @ Component ({ selector : 'app-lesson' , template : ` <ol> <li *ngFor=\"let day of weekdays\">{{ day }}</li> </ol> ` , styleUrls : [ './lesson.component.css' ] }) export class LessonComponent { weekdays = [ 'Monday' , 'Tuesday' , 'Wednesday' , 'Thursday' , 'Friday' , 'Saturday' , 'Sunday' ]; } Oder es ist m\u00f6glich, Attributen von HTML-Elementen mithilfe von Interpolation Werte zuzuordnen: @ Component ({ selector : 'app-lesson' , template : ` <img src=\"{{ imgUrl }}\" /> ` , styleUrls : [ './lesson.component.css' ] }) export class LessonComponent { imgUrl = 'https://www.dpunkt.de/common/images/cover_masterid/800/12400.jpg' ; } [Property Bindings] \u00b6 Insbesondere, wenn Attributen von HTML-Elementen Werte zugeordnet werden sollen (so wie im letzten Beispiel des Abschnitts {{Interpolation}} ), spricht man von property binding . Property binding spielt eine gro\u00dfe Rolle beim Datenfluss von Eltern-Komponenten auf Kind-Komponenten. Die generelle Idee dabei ist, dass mithilfe von property binding Werte (Daten) an Attribute von HTML-Elementen bindet. Diese HTML-Elemente k\u00f6nnen auch Komponenten sein. Wir betrachten zun\u00e4chst die unterschiedlichen Arten (Notationen) von property binding: < element [ property ]=\" ausdruck \" ></ element > D.h. ein ausdruck wird \u00fcbergeben, der zu einem Wert aufgel\u00f6st wird und dieser Wert wird dem Attribut property \u00fcbergeben. Betrachten wir nochmals das letzte Beispiel aus dem Abschnitt {{Interpolation}} ). Bei diesem Beispiel haben wir Interpolation verwendet, um dem Attribut src des HTML-Elementes img einen Wert zuzuweisen. Das exakt gleiche Verhalten l\u00e4sst sich auch mittels property bindings erzeugen: < img [ src ]=\" imgUrl \" /> <!-- imgUrl = 'https://www.dpunkt.de/common/images/cover_masterid/800/12400.jpg'; --> Neben diesen \"allgemeinen\" property bindings gibt es auch noch \"spezielle\" property bindings, n\u00e4mlich class bindings und style bindings . Bei class bindings wird das Pr\u00e4fix class vor die property (die entsprechende CSS-Klasse) gesetzt: < element [ class . class1 ]=\" class1enabled \" [ class . class2 ]=\" class2enabled \" ... ></ element > D.h. die CSS-Klasse class1 ist genau dann wirksam, wenn der Ausdruck class1enabled true ist und class2 ist genau dann wirksam, wenn der Ausdruck class2enabled true ist usw. Bei den style bindings werden jedoch gar keine Ausdr\u00fccke, sondern Werte \u00fcbergeben: < element [ style . color ] (Event Bindings) \u00b6 In den property bindings haben wir gesehen, wie Werte Attributen (Eigenschaften) von Elementen zugeordnet werden k\u00f6nnen. Aus JavaScript ist auch bekannt, dass Ereignisse Attribute von Elementen sein k\u00f6nnen, z.B. onClick , onKeyup , onChange usw. Dabei handelt es sich um sogenannte native DOM-Ereignisse . Neben der M\u00f6glichkeit, solche nativen DOM-Ereigniss zu behandeln, bietet Angular auch die M\u00f6glichkeit, eigene Ereignisse zu definieren und diese zu behandeln. Wir betrachten beide M\u00f6glichkeiten und beginnen mit den nativen Ereignissen. Native DOM-Ereignisse \u00b6 In HTML sieht das unter Aufruf einer JavaScript-Funktion f\u00fcr die Ereignisbahandlung dann typischerweise (hier das Click-Ereignis f\u00fcr einen Button) wie folgt aus: HTML < button onClick = \"doSomething()\" > Click here! </ button > JavaScript function doSomething () { // something to do } In Angular ist das Prinzip das gleiche, nur dass das Ereignis in runden Klammern genannt und an dieses Ereignis die Ereignisbehandlung gebunden wird ( event binding ). Das bedeutet, das Angular-Template f\u00fcr das obige Beispiel sieht wie folgt aus: Angular-Template < button ( click )=\" doSomething ()\" > Click here! </ button > Angular-Typescript export class EventsComponent { doSomething () { // something to do } } Dieses Prinzip gilt f\u00fcr alle nativen DOM-Ereignisse. Hier ein kurzer \u00dcberblick \u00fcber die wichtigsten (f\u00fcr eine umfangreichere Liste siehe hier oder hier ): Ereignis Beschreibung click Mausklick auf das Element change Der Inhalt/Wert eines Elementes hat sich ge\u00e4ndert mouseover die Maus wird \u00fcber das Element bewegt mouseout die Maus wird vom Element wegbewegt keydown eine Taste der Tastatur wird gedr\u00fcckt keyup Loslassen einer Taste load der Browser hat die Seite vollst\u00e4ndig geladen focus Fokussieren des Elements (z.B. Anklicken) blur Verlieren des Fokus (z.B. Klick au\u00dferhalb) submit Abschicken eines Formulars copy , paste Kopieren, Einf\u00fcgen von Text Einen kleinen Unterschied gibt es noch bei der \u00dcbergabe des Ereignisses an die das Ereignis behandelnde Funktion zu beachten. W\u00e4hrend in plain JavaScript das Ereignis mit event der Funktion \u00fcbergeben wird, erfolgt die \u00dcbergabe des Ereignisses in Angular mit $event . Beispiel: Angular-Template < input ( change )=\" showPayload ($ event )\" type = \"text\" /> Angular-Typescript export class EventsComponent { showPayload ( e : Event ) { console . log ( e ); } } Alle Events (in TypeScript/Angular) sind vom Typ Event . Es gibt noch speziellere Eventtypen, die aber alle auf dem Interface Event basieren, z.B. MouseEvent , InputEvent , KeyboardEvent , UIEvent , ClipboardEvent . Weitere Details siehe hier . Die einfache JavaScript-Attributschreibweise kann in Angular nicht verwendet werden, sondern immer nur die event binding -Schreibweise von Angular (mit den runden Klammern)! Eigene Ereignisse \u00b6 F\u00fcr eine Komponente kann ein eigenes - nicht natives - Ereignis definiert werden. Dies geschieht, indem f\u00fcr eine Komponente eine neue Eigenschaft (z.B. myEvent ) definiert wird und diese vom Typ EventEmitter deklariert wird. Mithilfe von Generics kann der Typ des Events angegeben werden, der ausgel\u00f6st werden soll - wenn Sie den Typ nicht genau kennen, verwenden Sie any . Soll das Ereignis an die Elternkomponente weitergeleitet werden, was meistens der Fall ist, wird der Decorator @Output() verwendet. Das Ausl\u00f6sen des Events geschieht dann durch die emit() -Methode von EventEmitter . Hier ein typisches Beispiel (zun\u00e4chst die Kindkomponente EventsComponent - also events.component.html und events.component.ts ): .html < button ( click )=\" emitMyEvent ()\" > Click here! </ button > .ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { Component , EventEmitter , Output } from '@angular/core' ; @ Component ({ selector : 'app-events' , templateUrl : './events.component.html' , styleUrls : [ './events.component.css' ] }) export class EventsComponent { @ Output () myEvent = new EventEmitter < any > (); emitMyEvent () { this . myEvent . emit (); } } Die .html -Datei definiert einen Button mit dem nativen Ereignis click . Dieses wird durch die Methode emitMyEvent() behandelt. In der .ts -Datei ist diese Methode definiert (Zeilen 11-13). Darin wird das eigene Event myEvent ausgel\u00f6st. Dieses Event ist ein Objekt vom Typ EventEmitter , typisiert als any (beliebiger Typ). Das Ausl\u00f6sen dieses Events wird an die aufrufende Komponente (die Elternkomponente) ausgegeben (Decorator @Output() ). Deklaration der Eigenschaft und Dekorieren mit @Output() in Zeile 9. Das Ausl\u00f6sen des eigenen Events erfolgt durch den Aufruf der Methode emit() aus EventEmitter (Zeile 12). In der Elternkomponente kann dieses Ereignis nun empfangen werden (Beispiel einer Elternkomponente AppComponent - also app.component.html und app.component.ts ): .html < app-events ( myEvent )=\" handleEventFromEventsComponent ()\" ></ app-events > .ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { Component } from '@angular/core' ; @ Component ({ selector : 'app-root' , templateUrl : './app.component.html' , styleUrls : [ './app.component.css' ] }) export class AppComponent { handleEventFromEventsComponent () { console . log ( 'myEvent in der Kindkomponente ausgel\u00f6st' ); } } In der AppComponent (das kann nat\u00fcrlich eine beliebige Komponente sein), wird die EventsComponent eingebunden (siehe <app-events> im Template der AppComponent ). Dadurch entsteht die Hierarchie Elternkomponente AppComponent \u2192 Kindkomponente EventsComponent im DOM. Mithilfe von event binding wird die Behandlung des Ereignisses myEvent an die Methode handleEventFromEventsComponent() gebunden. In dieser Methode erfolgt hier einfach nur eine Ausgabe auf die Konsole. Interessant ist, dass wir dadurch die M\u00f6glichkeit haben, Daten von der Kindkomponente zur Elternkomponente flie\u00dfen zu lassen. Dazu \u00fcbergeben wir diese Daten als payload des Ereignisses. Daf\u00fcr typisieren wir EventEmitter mit dem Typ, von dem wir Daten \u00fcbergeben wollen (z.B. Book - siehe B\u00fccher-App ). Die beiden obigen Beispiele sehen dann wie folgt aus (zuerst wieder EventsComponent ): .html < button ( click )=\" emitMyEvent ( book )\" > Click here! </ button > .ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { Component , EventEmitter , Output } from '@angular/core' ; @ Component ({ selector : 'app-events' , templateUrl : './events.component.html' , styleUrls : [ './events.component.css' ] }) export class EventsComponent { @ Output () myEvent = new EventEmitter < Book > (); emitMyEvent ( book : Book ) { this . myEvent . emit ( book ); } } Im Template (HTML) werden die Daten der Ereignisbehandlung \u00fcbergeben. Das EventEmitter -Objekt ist mit dem konkreten Datentyp typisiert. Bei Aufruf der Methode emit() werden die Daten an die Elternkomponente \u00fcbergeben. Die Elternkomponente (hier wieder AppComponent kann diese Daten, die von der Kindkomponente an die Elternkomponente via Ereignis geflossen sind, nun weiterverarbeiten bzw. darstellen): .html < app-events ( myEvent )=\" handleEventFromEventsComponent ($ event )\" ></ app-events > .ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { Component } from '@angular/core' ; @ Component ({ selector : 'app-root' , templateUrl : './app.component.html' , styleUrls : [ './app.component.css' ] }) export class AppComponent { handleEventFromEventsComponent ( book : Book ) { console . log ( book . title ); } } Wichtig beim event binding der Elternkomponente ist, dass der payload des Ereignisses mit $event \u00fcbergeben wird (siehe auch Native DOM-Ereignisse ). Zusammenfassung In den letzten drei Abschnitten Interpolation, Property Binding und Event Binding haben wir uns mit Datenfluss besch\u00e4ftigt. Interpolation wird verwendet, um innerhalb einer Komponente die in der TypeScript-Klasse definierten Daten im Template darzustellen. Mithilfe von Property Binding kann die aufrufende Komponente (Elternkomponente) der aufgerufenen Kopmponente (Kindkomponente) Daten \u00fcbergeben. Mithilfe von Event Binding kann die Kindkomponente der Elternkomponente mithilfe eines eigenen Ereignisses Daten \u00fcbergeben. F\u00fcr die Anwendung dieser Konzepte schauen Sie sich B\u00fccher-App\u2192Datenfluss zwischen Komponenten an. [(Two-Way-Bindings)] \u00b6 Lifecycle-Hooks \u00b6 Komponenten durchlaufen einen festen Lebenszyklus ( lifecycle ). Die verschiedenen Status rufen dabei jeweils eine Methode auf, die wir jeweils implementieren k\u00f6nnen, um in den jeweiligen Status des Lebenszyklus eingreifen zu k\u00f6nnen. Man spricht dabei von sogenannten Lifecycle-Hooks . Der wohl bekannteste Lifecycle-Hook ist ngOnInit() . Damit greift man in die Initialisierung der Komponente ein. Typischerweise werden z.B. Eingabewerte initialisiert, die im Template dargestellt werden. Noch vor ngOnInit wird jedoch ngOnChange() aufgerufen. N\u00e4mlich genau dann, wenn die Eingabewerte gesetzt bzw. ge\u00e4ndert werden. F\u00fcr weiterf\u00fchrende Informationen sei https://angular.io/guide/lifecycle-hooks empfohlen. Services \u00b6 Ein Service ist eine Klasse f\u00fcr einen konkreten Zweck. Services unterscheiden sich von Komponenten dahingehend, dass eine Komponente f\u00fcr die Nutzerinteraktion zust\u00e4ndig ist, eine Komponente Eigenschaften (Daten) pr\u00e4sentiert, eine Komponente Methoden zur Datenbindung ( data binding ) zur Verf\u00fcgung stellt, um zwischen View und Anwendungslogik zu vermitteln. Ein Service erf\u00fcllt eine konkrete Aufgabe, typischerweise mit Daten, ohne sich um die Darstellung der Daten zu k\u00fcmmern. Typische Aufgaben eines Services sind: Daten vom Server holen oder auf den Server laden, Nutzereingaben zu validieren. Ein Service steht typischerweise allen Komponenten zur Verf\u00fcgung (aber nicht jede Komponente muss einen Service nutzen). Ein Service ist eine Klasse mit dem Decorator @Injectable() . Services enthalten Anwendungslogik, die aus Komponenten ausgelagert werden kann. Ein Service my kann mittels CLI so erzeugt werden: ng generate service shared/my Es entsteht im src/app/shared -Ordner eine Datei my.service.ts . Services sollten am besten in dem shared -Ordner erstellt werden, da ein Service von allen Komponenten genutzt werden kann (eine andere M\u00f6glichkeit w\u00e4re, einen eigenen Ordner services zu erstellen). In dem Decorator @Injectable() wird mittels providedIn: root angegeben, dass der Service von allen Komponenten innerhalb des Root-Moduls genutzt werden kann. Ist der Service von anderen Services oder Komponenten abh\u00e4ngig, k\u00f6nnen diese Services oder Komponenten mittels dependency injection als Parameter des Service-Konstruktor eingebunden werden. Hier ein allgemeines Beispiel eines Services MyService : my.service.ts 1 2 3 4 5 6 7 8 9 10 import { Injectable } from '@angular/core' ; @ Injectable ({ providedIn : 'root' }) export class MyService { constructor ( private myDependency : MyDependency ) { } } Der Service kann dann mittels dependency injection von einer Komponente verwendet werden. Beispiel: example.component.ts import { Component , OnInit } from '@angular/core' ; import { MyService } from './shared/my.service' ; @ Component ({ selector : 'app-example' , templateUrl : './example.component.html' , styleUrls : [ './example.component.css' ] }) export class ExampleComponent implements OnInit { constructor ( private myService : MyService ) { } ngOnInit () : void { this . example . methodOfMyService (); } } F\u00fcr ein Beispiel einer Service-Definition und der Verwendung eines Services siehe BookStoreService . F\u00fcr weiterf\u00fchrende Informationen siehe https://angular.io/guide/architecture-services . Routing \u00b6 Routing ist ein wesentliches Konzept f\u00fcr die Entwicklung von Single-Page-Applikationen (SPA). Bei Single-Page-Applikationen wird genau eine Seite vom Webserver geladen (typischerweise die index.html und alle weiteren, sich \u00e4ndernden, Inhalte und Sichten werden in diese Seite nachgeladen). Das f\u00fchrt zun\u00e4chst auch dazu, dass es f\u00fcr die Seite genau eine URL gibt, um auf sie zuzugreifen (z.B. http://www.mydomain.de bzw. http://www.mydomain.de/index.html ). M\u00f6chte man aber Komponenten direkt in der URL ansprechen, z.B. http://www.mydomain.de/login f\u00fcr die Login-Komponente, so ben\u00f6tigen wir das Routing von Angular. Wir betrachten hier ein Beispiel, das https://angular.io/guide/router entnommen ist und nur leicht abgewandelt wurde. Wir erstellen dazu zun\u00e4chst ein neues Projekt routing-lesson . ng new routing-lesson In der obigen Anweisung h\u00e4tte man auch bereits den Parameter --routing verwenden k\u00f6nnen, also: ng new routing-lesson --routing Macht man das nicht, werden Sie gefragt, ob Sie Routing verwenden wollen: ? Would you like to add Angular routing? [y|N] Antworten Sie mit y . Zur Demonstration des Routings werden wir zun\u00e4chst 2 weitere Komponenten erstellen: first und second . cd routing-lesson ng g c first ng g c second Wird ein Angular-Projekt mit Routing erstellt, so existiert die Datei app-routing.module.ts im src/app/ -Ordner. Diese Datei sieht urspr\u00fcnglich so aus: app-routing.module.ts 1 2 3 4 5 6 7 8 9 10 import { NgModule } from '@angular/core' ; import { Routes , RouterModule } from '@angular/router' ; const routes : Routes = []; @ NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { } Bei dieser Klasse handelt es sich um ein eigenes Angular-Modul (als @NgModule dekoriert). Es wird deshalb auch in die app.module.ts integriert (dies geschieht automatisch, wenn wir Routing ausgew\u00e4hlt haben) - siehe Zeilen 4 und 17 im folgenden Listing: app.module.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import { BrowserModule } from '@angular/platform-browser' ; import { NgModule } from '@angular/core' ; import { AppRoutingModule } from './app-routing.module' ; import { AppComponent } from './app.component' ; import { FirstComponent } from './first/first.component' ; import { SecondComponent } from './second/second.component' ; @ NgModule ({ declarations : [ AppComponent , FirstComponent , SecondComponent ], imports : [ BrowserModule , AppRoutingModule ], providers : [], bootstrap : [ AppComponent ] }) export class AppModule { } Das Array routes aus der Datei app-routing.module.ts enth\u00e4lt sp\u00e4ter die Pfadangaben zu den Komponenten - sogenannte Routen . Routen sind Objekte und wie folgt notiert: { path : 'mypath' , component : MyComponent } Diese Angabe bewirkt, dass unter der URL http://www.mydomain.de/mypath die Komponente MyComponent aufgerufen wird. Angenommen, wir wollen, dass unsere Komponente FirstComponent unter dem Pfad /first aufgerufen wird und SecondComponent unter dem Pfad /second , dann sieht unsere Datei app-routing.module.ts wie folgt aus: app-routing.module.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import { NgModule } from '@angular/core' ; import { Routes , RouterModule } from '@angular/router' ; import { FirstComponent } from './first/first.component' ; import { SecondComponent } from './second/second.component' ; const routes : Routes = [ { path : 'first' , component : FirstComponent }, { path : 'second' , component : SecondComponent } ]; @ NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { } In den Zeilen 8 und 9 sind die beiden Routen definiert. Beachten Sie, dass die Pfadangaben ohne vorangestelltes Slash / erfolgen! Unter Verwendung der Selektoren <app-first> bzw. <app-second> k\u00f6nnten wir unsere Komponenten nun (statisch) in unsere Anwendung einbinden. Wollen wir das jedoch dem Routing \u00fcberlassen, die Komponenten also dynamisch - abh\u00e4ngig von dem jeweils gew\u00e4hlten Pfad - einbinden lassen, verwenden wir stattdessen den Selektor <router-outlet> . Auch dieser ist bei gew\u00e4hltem Routing bereits Teil des AppComponent -Templates: app.component.html <!-- hier wurde viel vom urspr\u00fcnglichen --> <!-- Template gel\u00f6scht --> < h1 > Hier ist AppComponent </ h1 > < router-outlet ></ router-outlet > Obiges Listing zeigt, dass das Template von AppComponent zun\u00e4chst eine <h1> -\u00dcberschrift vorsieht und dann folgt das <router-outlet> , welches als Platzhalter f\u00fcr die durch das Routing ausgew\u00e4hlten Komponenten agiert. Angenommen, wir definieren die Templates f+r FirstComponent und SecondComponent wie folgt: first.component.html < h3 > Hier ist FirstComponent </ h3 > second.component.html < h3 > Hier ist SecondComponent </ h3 > Starten wir nun unsere Anwendung, dann sehen wir zun\u00e4chst (URL: http://localhost:4200/ ) nur die View der AppComponent , n\u00e4mlich die <h1> -\u00dcberschrift. Der Platzhalter <router-outlet> bleibt leer, da keine der angegebenen Pfade aus der app-routing.module.ts angegeben wurde. Geben wir jedoch als URL http://localhost:4200/first ein, so wird das Template der FirstComponent in diesen Platzhalter geladen, n\u00e4mlich die <h3 -\u00dcberschrift Hier ist FirstComponent . Geben wir als URL stattdessen http://localhost:4200/second ein, so wird das Template der SecondComponent in den Platzhalter <router-outlet> geladen, n\u00e4mlich die <h3 -\u00dcberschrift Hier ist SecondComponent . Die folgende Abbildung zeigt die Views der drei F\u00e4lle: Wir haben nun Pfade erzeugt, mit denen man Komponenten direkt ansprechen kann. Im folgenden Abschnitt wird gezeigt, wie man diese Pfade in Hyperlinks nutzt. Routen verlinken \u00b6 Wir kennen nun die m\u00f6glichen Pfade unserer Anwendung http://localhost:4200/ , http://localhost:4200/first und http://localhost:4200/second und w\u00fcrden diese Adressen z.B. gerne in Hyperlinks verwenden, um direkt zu den Views der jeweiligen Komponente zu springen, z.B. so: app.component.html < h1 > Hier ist AppComponent </ h1 > < ul > < li > < a href = \"/\" > home </ a > </ li > < li > < a href = \"/first\" > first </ a > </ li > < li > < a href = \"/second\" > second </ a > </ li > </ ul > < router-outlet ></ router-outlet > Das funktioniert auch, hat aber einen von uns nicht gewollten Effekt: Die Seite wird durch jeden Klick auf einen Hyperlink neu geladen. Das ist ja auch das gew\u00fcnschte Verhalten eines Hyperlinks. Die Idee einer Single-Page-Applikation ist aber jedoch die, dass die Seite nur genau einmal geladen wird und dann dynamisch alle weiteren Inhalte. Das Nachladen wird vermieden, wenn wir als Attribut f\u00fcr unsere Pfade nicht href verwenden, sondern die Angular-Direktive routerLink . Dies gilt nur f\u00fcr interne Links! Aber es verhindert bei internen Links ein Neuladen der Seite. app.component.html < h1 > Hier ist AppComponent </ h1 > < ul > < li > < a routerLink = \"/\" > home </ a > </ li > < li > < a routerLink = \"/first\" > first </ a > </ li > < li > < a routerLink = \"/second\" > second </ a > </ li > </ ul > < router-outlet ></ router-outlet > Die obige Attributschreibweise kann auch durch property binding ersetzt werden. Dann \u00fcbergeben Sie als Wert aber keinen String sondern ein 1-elementiges Array: app.component.html < h1 > Hier ist AppComponent </ h1 > < ul > < li > < a [ routerLink ]=\"['/']\" > home </ a > </ li > < li > < a [ routerLink ]=\"['/ first ']\" > first </ a > </ li > < li > < a [ routerLink ]=\"['/ second ']\" > second </ a > </ li > </ ul > < router-outlet ></ router-outlet > Die zweite Variante wird meistens dann verwendet, wenn an den Pfad noch dynamisch Werte \u00fcbergeben werden, sogenannte Parameter an den Routen. Parameter an Routen \u00b6 H\u00e4ufig sind die Pfadangaben nicht nur so statisch wie bisher, also /first bzw. /second , sondern es werden auch noch Werte, z.B. Session-IDs, Nutzer-IDs, B\u00fccher-ISBN usw. \u00fcbergeben. Dazu werden die Routen durch Parameter erweitert. Diese Parameter werden dann mit einem konkreten Wert bei Aufruf ersetzt. Die allgemeine Syntax f\u00fcr einen parametrisierten Pfad ist: { path : 'mypath/:id' , component : MyComponent } Der Doppelpunkt : ist zwingend, der Name des Parameters id ist frei w\u00e4hlbar. Die Werte f\u00fcr den Routenparameter k\u00f6nnen als routerLink wieder entweder als String \u00fcbergeben werden (Zeile 1 im folgenden Listing) oder per property binding als weiteres Array-Element (Zeile 2 im folgenden Listing). 1 2 < a routerLink = \"/mypath/4711\" > statischer Wert f\u00fcr id </ a > < a [ routerLink ]=\"['/ mypath ', myData . id ]\" > dynamischer Wert f\u00fcr id (aus JSON myData) </ a > Wir haben jetzt eine parametrisierten Pfad konfiguriert und wir haben auch betrachtet, wie der Aufruf einer solch parametrisierten Route erfolgen kann. Nun betrachten wir, wie der Wert eines Parameters in einer Komponentenklasse ausgelesen und verarbeitet werden kann. Wir f\u00fchren dazu zun\u00e4chst kleinere \u00c4nderungen an unserem obigen Beispiel der routing-lesson -App durch: app-routing.module.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import { NgModule } from '@angular/core' ; import { Routes , RouterModule } from '@angular/router' ; import { FirstComponent } from './first/first.component' ; import { SecondComponent } from './second/second.component' ; const routes : Routes = [ { path : 'first' , component : FirstComponent }, { path : 'first/:id' , component : FirstComponent }, { path : 'second' , component : SecondComponent } ]; @ NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { } first.component.html 1 2 < h3 > Hier ist FirstComponent </ h3 > < p * ngIf = \"id\" > {{ id }} </ p > In app-routing.module.ts haben wir einen weiteren Pfad hinzugef\u00fcgt (Zeilennummer 8). Beachten Sie, dass ohne die Pfadkonfiguration in Zeilennummer 7 die Route http://localhost:4200/first (also ohne Parameterwert) nicht mehr existieren w\u00fcrde. Wenn ein Parameter erforderlich ist, dann muss er auch angegeben werden. Nur in Kombination der beiden Pfadkonfigurationen aus Zeilennummern 7 und 8 ist der Pfad sowohl mit als auch ohne Parameterwert m\u00f6glich. Im Template der FirstComponent haben wir einen Absatz eingef\u00fcgt, der als Inhalt den Wert der Eigenschaft id mittels Interpolation anzeigt. Der Absatz erscheint nur, wenn id auch einen Wert hat. Die Eigenschaft id muss allerdings noch in der first.component.ts angelegt werden: first.component.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { Component , OnInit } from '@angular/core' ; import { ActivatedRoute } from '@angular/router' ; @ Component ({ selector : 'app-first' , templateUrl : './first.component.html' , styleUrls : [ './first.component.css' ] }) export class FirstComponent implements OnInit { id : string ; constructor ( private route : ActivatedRoute ) { } ngOnInit () : void { this . id = this . route . snapshot . paramMap . get ( 'id' ); } } In der first.component.ts kommen verschiedene Sachen hinzu: es wird die Eigenschaft id deklariert (als string ) es wird der Service ActivatedRoute per dependency injection der Klasse FirstComponent injiziert \u2192 die Eigenschaft route ist vom Typ ActivatedRoute ActivatedRoute stellt uns Informationen \u00fcber den aktuellen Router (die aktuelle URL) zur Verf\u00fcgung \u2192 die Eigenschaft this.route.snapshot.paramMap enth\u00e4lt alle Parameter der aktuellen Route \u2192 mithilfe der Methode get() kann nach einem konkreten Parameter gefragt werden \u2192 wir fragen nach dem Parameter id , da wir so unseren Pfad konfiguriert haben (siehe oben app-routing.module.ts ) Wenn wir nun z.B. die URL http://localhost:4200/first/42 eingeben, dann erscheint im Brower der Wert des Parameters (als Inhalt des <p> -Elementes; siehe oben first.component.html ). Die aktuelle Implementierung von first.component.ts liest also w\u00e4hrend der Initialisierung der Komponente die Routenparameter aus. Finden jedoch am Parameterwert \u00c4nderungen statt, ohne dass die Komponente neu initialisiert wird, bekommt die Komponente von den \u00c4nderungen nichts mit. Die oben gezeigte Form der Implementierung ist deshalb nicht f\u00fcr alle F\u00e4lle geeignet. Vielmehr ist es besser auszunutzen, dass es sich bei this.route.paramMap (ohne snapshot ) um ein Observable handelt. Ein Observable kann so verstanden werden, dass er permanent eine bestimmte Sache beobachtet (z.B. ist der EventEmitter ein Observable und beobachtet permanent, ob das Ereignis ausgel\u00f6st wird; wenn ja, dann ruft EventEmitter die Funktion emit() auf \u2192 siehe Eigene Ereignisse ). Wenn sich etwas an dem beobachteten Objekt ge\u00e4ndert hat, dann reagiert Observable sofort und ruft eine bestimmte Funktion auf. Das Observable paramMap beobachtet permanent die aktuelle Route und sobald sich etwas an dieser Route \u00e4ndert, wird eine Funktion aufgerufen. Damit das Observable aber \u00fcberhaupt den aktuellen Router permanent beobachtet, muss er an den Router angemeldet werden \u2192 das Observable \"abboniert\" den Router. Dies geschieht mithilfe der Funktion subscribe() . Dieser Funktion kann als Parameter eine Funktion \u00fcbergeben werden. Diese Funktion wird aufgerufen, sobald sich am aktuellen Router etwas \u00e4ndert. Wir \u00e4ndern die Implementierung von ngOnInit() in der Klasse first.component.ts deshalb wie folgt: first.component.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { Component , OnInit } from '@angular/core' ; import { ActivatedRoute } from '@angular/router' ; @ Component ({ selector : 'app-first' , templateUrl : './first.component.html' , styleUrls : [ './first.component.css' ] }) export class FirstComponent implements OnInit { id : string ; constructor ( private route : ActivatedRoute ) { } ngOnInit () : void { this . route . paramMap . subscribe ( paramMap => this . id = paramMap . get ( 'id' ) ); } } Nun erh\u00e4lt die Eigenschaft id immer den aktuellsten Wert (und dieser wird aufgrund der Interpolation auch stets aktuell in der View dargestellt). Verschachtelte Routen \u00b6 Angenommen, wir haben zwei weitere Komponenten OneComponent und TwoComponent und beide Komponenten sind Kindkomponenten von der Elternkomponente FirstComponent . Das Verh\u00e4ltnis Eltern- Kindkomponente entsteht ja eigentlich dadurch, dass das Template der Elternkomponente den Selektor der Kindkomponente enth\u00e4lt. Das hei\u00dft in first.component.html gibt es sowohl ein <app-one></app-one> als auch ein <app-two></app-two> \u2192 dann sind One und Two Kindkomponenten von First . Wir wollen nun aber folgendes: die Route /first verweist auf die FirstComponent die Route /first/one verweist auf die FirstComponent und deren Kindkomponente OneComponent die Route /first/two verweist auf die FirstComponent und deren Kindkomponente TwoComponent Wir wollen also, dass auch die beiden Kindkomponenten mittels Routing in die Elternkomponente eingef\u00fcgt werden. Das erreichen wir mit 2 Anpassungen: in app-routing.module.ts kann im routes -Array auch noch die Eigenschaft children hinzugef\u00fcgt werden, welche Pfadkonfigurationen zu den Kindkomponenten enth\u00e4lt in der *.component.html der Elternkomponente wird ein weiteres <router-outlet></router-outlet> hinzugef\u00fcgt app-routing.module.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { Routes , RouterModule } from '@angular/router' ; import { FirstComponent } from './first/first.component' ; import { SecondComponent } from './second/second.component' ; import { OneComponent } from './first/one/one.component' ; import { TwoComponent } from './first/two/two.component' ; const routes : Routes = [ { path : 'first' , component : FirstComponent , children : [ { path : 'one' , component : OneComponent }, { path : 'two' , component : TwoComponent }, ]}, { path : 'first/:id' , component : FirstComponent }, { path : 'second' , component : SecondComponent } ]; @ NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { } first.component.html 1 2 3 4 5 6 7 < h3 > Hier ist FirstComponent </ h3 > < ul > < li >< a [ routerLink ]=\"['/ first / one ']\" > first/one </ a ></ li > < li >< a [ routerLink ]=\"['/ first / two ']\" > first/two </ a ></ li > </ ul > < p * ngIf = \"id\" > {{ id }} </ p > < router-outlet ></ router-outlet > app.component.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 < h1 > Hier ist AppComponent </ h1 > < ul > < li > < a [ routerLink ]=\"['/']\" > home </ a > </ li > < li > < a [ routerLink ]=\"['/ first ']\" > first </ a > </ li > < li > < ul > < li >< a [ routerLink ]=\"['/ first / one ']\" > first/one </ a ></ li > < li >< a [ routerLink ]=\"['/ first / two ']\" > first/two </ a ></ li > </ ul > </ li > < li > < a [ routerLink ]=\"['/ second ']\" > second </ a > </ li > </ ul > < router-outlet ></ router-outlet > Das bedeutet, dass wir nun zwei <router-outlet></router-outlet> -Elemente haben. Eines in der app.component.html f\u00fcr die Routen first , first/:id und second und eines in der first.component.html f\u00fcr die Routen first/one und first/two . Styles f\u00fcr aktive Routen \u00b6 Sie k\u00f6nnen angeben, welche CSS-Klassen wirken sollen, falls eine Route aktiv ist. Eine Route ist aktiv, wenn Sie ausgew\u00e4hlt/angewendet werden kann. Dazu wurde in Angular das Attribut routerLinkActive eingef\u00fchrt. Angenommen, die CSS-Klasse myactiveclass soll Anwendung f\u00fcr eine aktuelle (aktive) Route /first Anwendung finden, dann definieren Sie: < a routerLink = \"/first\" routerLinkActive = \"myactiveclass\" > first </ a > Sie k\u00f6nnen auch mehrere CSS-Klassen definieren. Daf\u00fcr gibt es zwei verschiedene M\u00f6glichkeiten: < a routerLink = \"/first\" routerLinkActive = \"myactiveclass1 myactiveclass1\" > first </ a > < a routerLink = \"/first\" [ routerLinkActive ]=\"[' myactiveclass1 ', ' myactiveclass1 ']\" > first </ a > Das Styling aktiver Routen ist insbesondere f\u00fcr Navigationsleisten (Men\u00fcs) hilfreich. Routen im Programm wechseln \u00b6 Der Service Router stellt zwei Methoden zur Verf\u00fcgung, mit denen eine Route im Programm gewechselt werden kann, z.B. nach einer Nutzereingabe oder einer Nutzerinteraktion: navigate() navigateByUrl() Angenommen, wir erweitern unsere Komponente SecondComponent um einen Button. Durch den Klick auf den Button soll von der SecondComponent auf die OneComponent \u00fcber die Route /first/one gewechselt werden: second.component.html 1 2 < h3 > Hier ist SecondComponent </ h3 > < button ( click )=\" changeRoute ()\" > /first/one </ button > second.component.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { Component , OnInit } from '@angular/core' ; import { Router } from '@angular/router' ; @ Component ({ selector : 'app-second' , templateUrl : './second.component.html' , styleUrls : [ './second.component.css' ] }) export class SecondComponent implements OnInit { constructor ( private router : Router ) { } ngOnInit () : void { } changeRoute () { this . router . navigate ([ '/first' , 'one' ]); // oder // this.router.navigateByUrl('/first/one'); } } In der second.component.ts sehen wir in Zeile 11, dass der Service Router per dependency injection eingebunden wird. Der Eigenschaft router stehen die Methoden navigate() bzw. navigateByUrl() zur Verf\u00fcgung. Wir sehen in den Zeilen 16-20 die Behandlung des Click -Ereignisses des Buttons. In Zeile 17 wird darin programmatisch die Route /first/one aufgerufen. HTTPClient \u00b6 Wir wissen bereits, dass Angular eine TypeScript-Framework ist, mit dem sich Single-Page-Anwendungen implementieren lassen. Es wird einmalig eine Seite (h\u00e4ufig index.html ) vom Server geladen und alle weiteren Inhalte werden sukzessive bzw. durch Nutzerinteraktionen gesteuert in diese eine Seite nachgeladen. Die Steuering wird dabei durch den Browser vorgenommen, der das aus TypeScript \u00fcbersetzte JavaScript interpretiert und entsprechend die Templates der Komponenten in die Anwendung einbindet. Das bedeutet, dass im Prinzip die gesamte Logik im Client , d.h. im Browser ausgef\u00fchrt wird. Dem gegen\u00fcber steht jedoch die in der Anwendung verarbeitete Menge von Daten, die typischerweise in einer Datenbank auf einem Server bereitgestellt werden. W\u00e4hrend der Client sich darum k\u00fcmmert, dass Daten angezeigt oder eingegeben werden, muss sich der Server darum k\u00fcmmern, dass Daten in die Datenquelle (die Datenbank) neu eingef\u00fcgt, ausgelesen, aktualisiert und gel\u00f6scht werden k\u00f6nnen. Diese vier Operationen werden mit CRUD abgek\u00fcrzt f\u00fcr: C reate - neue Daten einf\u00fcgen R ead - Daten auslesen U pdate - Daten aktualisieren D elete - Daten l\u00f6schen Der Client und der Server m\u00fcssen dazu nun irgendwie verbunden werden. Diese Verbindung erfolgt mithilfe des Hypertext Transfer Protocols (HTTP) .","title":"Angular"},{"location":"angular/#angular","text":"Angular geh\u00f6rt neben React.js und Vue.js zu den meisteverwendeten Frameworks f\u00fcr die Entwicklung sogenannter Single-Page-Applikationen . In einer Single-Page-Applikation wird eine Seite vom Webserver geladen und diese Seite durch unterschiedliche Inhalte bef\u00fcllt, je nach Nutzerinteraktion. Diese Inhalte werden in Angular durch sogenannte Komponenten bereitsgestellt. Komponenten sind die Grundbausteine einer Angular-Anwendung. Das erste Release von Angular erschien 2010 (damals noch unter dem Namen AngularJS, ab Version 2 nur noch Angular). React und Vue kamen 2013 bzw. 2014 erstmalig heraus. Angular wird haupts\u00e4chlich von Google, React haupts\u00e4chlich von Facebook und Vue als Community-Version entwickelt. Alle drei Frameworks stehen unter MIT-Lizent . Neben HTML und CSS verwendet Angular TypeScript . TypeScript ist eine Obermenge von JavaScript. Das bedeutet, dass jeder JavaScript-Code auch TypeScript ist, aber nicht umgekehrt. TypeScript-Code wird compiliert und erzeugt JavaScript-Code, der vom Browser ausgef\u00fchrt werden kann. Im Gegensatz zu JavaScript ist TypeScript typsicher und klar objektorientiert.","title":"Angular"},{"location":"angular/#erstes-projekt-erstellen","text":"Eine Angularanwendung besteht haupts\u00e4chlich aus Komponenten und Services. Um die Anwendung selbst sowie Komponenten und Services zu erstellen, wird am besten das Command Line Interface for Angular (Angular CLI) verwendet. \u00d6ffnen Sie ein Terminal (Windows-Nutzerinnen sollten die Git-Bash verwenden, die Sie bereits mit Git installiert haben). Wechseln Sie im Terminal in das Verzeichnis, das Ihre Projekte enthalten soll. F\u00fcr das Wechseln in andere Verzeichnisse nutzen Sie den cd Befehl (change directory). Um die Anwendung \"first\" zu erzeugen, geben Sie folgenden Befehl in das Terminal ein: ng new first ng steht f\u00fcr Angular. Mit dem Attribut new geben Sie an, dass Sie ein neues Projekt erzeugen wollen. first ist der Name des Projektes. Wenn Sie gefragt werden, ob Sie Angular routing verwenden m\u00f6chten, geben Sie ein y ein. Wenn Sie nach dem stylesheet format gefragt werden, k\u00f6nnen Sie CSS einfach mit Enter best\u00e4tigen. Wenn alles geklappt hat, erhalten Sie im Terminal eine Ausgabe in der Form: Es entsteht ein Ordner first in Ihrem Projekte-Verzeichnis. Wechseln Sie in dieses Verzeichnis: cd first F\u00fchren Sie darin den Befehl: npm install aus. Damit werden alle Abh\u00e4ngigkeiten, die in der Datei package.json definiert sind, geladen und das node_modules -Verzeichnis erstellt. Siehe z.B. hier . Danach geben Sie ng serve ein. Es werden die entsprechenden TypeScript-Dateien compiliert und es erscheint am Ende eine Ausgabe, wie z.B. ** Angular Live Development Server is listening on localhost:4200, open your browser on http://localhost:4200/ ** :Compiled successfully. \u00d6ffnen Sie Ihren Browser und geben Sie als URL http://localhost:4200 ein. Folgende Seite sollte erscheinen: Success Fertig! Sie haben Ihr erstes Angular-Projekt erstellt.","title":"Erstes Projekt erstellen"},{"location":"angular/#angular-projektstruktur","text":"\u00d6ffnen Sie die IDE Ihrer Wahl (Screenshots hier mit [PhpStorm] ( https://www.jetbrains.com/de-de/phpstorm/ ). W\u00e4hlen Sie unter Open Project den Projektordner first . Klappen Sie das Projekt first auf, klappen Sie den Ordner src und dann den Ordner app auf. Der Projektexplorer zeigt folgendes Bild: Die meiste Arbeit wird im src -Ordner erledigt. Darin befindet sich (wird sich befinden) der Code unserer Anwendung. Darin der wichtigste Ordner ist der app -Ordner. Hier werden wir unsere Module, Komponenten und Services hinzuf\u00fcgen. In dem assets -Ordner werden Bilder, Icons und Daten abgelegt. Der node_modules -Ordner enth\u00e4lt alle ben\u00f6tigten 3 rd -party-libraries. Welche das sind, wird in der Datei package.json als dependencies definiert. Mithilfe des Befehls npm install werden alle ben\u00f6tigten Module dem Ordner node_modules hinzugef\u00fcgt. Der Ordner environments enth\u00e4lt die notwendigen Konfigurationsinformationen f\u00fcr den development - und den production -Modus. Wir entwickeln zun\u00e4chst im development -Modus. favicon.ico ist das Favicon - ein kleines Icon, das im Reiter erscheint. W\u00e4hlen Sie am besten ein eigenes. index.html ist die Hauptseite. Mithilfe von Angular entwickeln wir eine Single Page Application , d.h. es wird eine einzige HTML-Seite geladen ( index.html ) und jeder weitere Inhalt wird asynchron hinzugef\u00fcgt. styles.css enth\u00e4lt die globalen Stylesheets, d.h. die CSS-Eigenschaften, die f\u00fcr das gesamte Projekt gelten sollen. Die app.component.* -Dateien beschreiben die app-Komponente. Eine Komponente besteht aus einer HTML -, einer CSS - und einer TypeScript -Datei (auch noch eine *.spec.ts , aber die interessiert zun\u00e4chst nicht). \u00d6ffnen Sie in Ihrer IDE die Datei app.component.html . L\u00f6schen Sie den kompletten Inhalt und lassen nur noch <router-outlet></router-outlet> . F\u00fcgen Sie oberhalb von <router-outlet></router-outlet> die Zeile <h1>This is app</h1> ein. Gehen Sie wieder zum Browser und schauen sich den ge\u00f6ffneten Tab mit der URL localhost:4200 an. Es erscheint der folgende Inhalt: \u00d6ffnen Sie die app.component.css -Datei und geben Sie dort h1 { color : red ; } Nach den \u00c4nderungen in app.component.css erscheint der Text der \u00dcberschrift in rot: Zusammenfassung Wir haben die die app.component.html ge\u00e4ndert, um den Inhalt der dargestellten Seite anzupassen und die app.component.css , um \u00c4nderungen an der Darstellung (dem Stil) des Inhalts durchzuf\u00fchren.","title":"Angular-Projektstruktur"},{"location":"angular/#komponenten","text":"Eine Angular-Anwendung besteht haupts\u00e4chlich aus Komponenten . Jede Anwendung hat eine Hauptkomponente - die sogenannte Root Component. Diese Hauptkomponente ist meistens die AppComponent . Eine Komponente hat eine in sich geschlossene Bedeutung, z.B. ein Formular f\u00fcr Dateneingabe, eine Liste aller Daten oder auch nur ein bestimmtes Element. Eine Komponente besteht aus einer View ( Template ) und einer TypeScript-Klasse. Die AppComponent besteht z.B. aus der app.component.html (der View) und der app.component.ts (der TypeScript-Klasse). Die TypeScript-Klasse k\u00fcmmert sich um die Verwaltung der Daten, die in der View dargestellt und/oder durch Eingaben erzeugt werden. Die TypeScript-Klasse beschreibt die Logik der Komponente. Die View ist der dargestellte Bereich der Komponente, also das, was man im Browser von der Komponente sieht. Neben der *.html - und der *.ts -Datei einer Komponente gibt es auch noch die *.css -Datei (also z.B. app.component.css ). Diese enth\u00e4lt CSS-Eigenschaften, die speziell f\u00fcr die Komponente gelten sollen. Um eine Komponente der gesamten Anwendung als Komponente bekannt zu machen, wird der Decorator @Component verwendet. Decoratoren erkennt man am f\u00fchrenden @ -Zeichen. Sie werden verwendet, um Metadaten der Anwendung zu verwalten. Der typische Aufbau einer Komponente (hier AppComponent - app.component.ts ): @ Component ({ selector : 'app-root' , templateUrl : './app.component.html' , styleUrls : [ './app.component.css' ] }) export class AppComponent { title = 'book-app' ; } Der Selektor gibt an, dass \u00fcberall dort, wo app-root als Elementselektor <app-root> </app-root> verwendet wird, das in app.component.html definerte Template eingesetzt wird. Angenommen, in app.component.html ist der HTML-Code: < h1 > This is app </ h1 > definiert. Dann wird dieser Code als Inhalt in das HTML-Element <app-root> </app-root> eingesetzt: < app-root > < h1 > This is app </ h1 > </ app-root > Wir schauen uns ein ausf\u00fchrlicheres Beispiel im Folgenden an, in dem wir eine neue Komponente erzeugen.","title":"Komponenten"},{"location":"angular/#eine-neue-komponente-erzeugen","text":"Mithilfe von Angular-CLI erzeugen wir in unserer App first eine neue Komponente. Wir wechseln dazu im Terminal in den Ordner von first und geben dann ng generate component mycomponent ein. Sp\u00e4ter k\u00fcrzen wir solche Eingaben ab. Anstelle von generate brauchen wir auch nur g zu schreiben. Und anstelle von component gen\u00fcgt c . Das hei\u00dft, wir h\u00e4tten stattdessen auch ng g c mycomponent schreiben k\u00f6nnen. In unserer first App gibt es nun die Komponente mycomponent : Jede Angular-Komponente besteht aus vier Teilen: der TypeScript-Klasse (die *.component.ts -Datei) dem Template (die *.component.html -Datei) den Styles (die *.component.css -Datei) einer Testspezifikation (die *.component.spec.ts -Datei) Jede Komponente wird in der app.module.ts der gesamten Anwendung bekannt gemacht. Das erfolgt mithilfe der Eigenschaft declarations im Decorator @NgModule() : import { BrowserModule } from '@angular/platform-browser' ; import { NgModule } from '@angular/core' ; import { AppRoutingModule } from './app-routing.module' ; import { AppComponent } from './app.component' ; import { MycomponentComponent } from './mycomponent/mycomponent.component' ; @ NgModule ({ declarations : [ AppComponent , MycomponentComponent ], imports : [ BrowserModule , AppRoutingModule ], providers : [], bootstrap : [ AppComponent ] }) export class AppModule { } Das obige Listing zeigt, dass die neue Komponente Mycomponent registriert wurde. Um dieses Eintragen in die app.module.ts m\u00fcssen wir uns aber nicht k\u00fcmmern, das erledigt die Angular-CLI mit der Anweisung zur Erstellung einer neuen Komponente ng generate component newComponent . Doppelklicken Sie im Projektexplorer Ihrer IDE auf die Datei mycomponent.component.ts , um sie zu \u00f6ffnen. Sie enth\u00e4lt den folgenden Quelltext: import { Component , OnInit } from '@angular/core' ; @ Component ({ selector : 'app-mycomponent' , templateUrl : './mycomponent.component.html' , styleUrls : [ './mycomponent.component.css' ] }) export class MycomponentComponent implements OnInit { constructor () { } ngOnInit () : void { } } Wir \u00e4ndern diese Datei zun\u00e4chst nicht und \u00f6ffnen auch noch die mycomponent.component.html . Diese enth\u00e4lt nur ein HTML-Element, einen Absatz: < p > mycomponent works! </ p > Wir \u00e4ndern auch diese Datei zun\u00e4chst nicht und \u00f6ffnen die app.component.html - die HTML-Datei unserer Root-Komponente. Diese sieht derzeit so aus: < h1 > This is app </ h1 > < router-outlet ></ router-outlet > Wir f\u00fcgen in die Datei den Selektor app-mycomponent unserer neuen Mycomponent -Komponente als HTML-Element ein: < h1 > This is app </ h1 > < app-mycomponent ></ app-mycomponent > <!-- eingefuegt --> < router-outlet ></ router-outlet > Dieses Element dient als \"Platzhalter\" f\u00fcr das Template unserer neuen Komponente. Das bedeutet, dass in dieses Element der HTML-Code aus mycomponent.component.html eingef\u00fcgt wird. Wechseln Sie in den Browser auf den Tab mit Ihrer Anwendung ( http://localhost:4200/ ). Sie sehen folgendes Bild: Unterhalb der \u00dcberschrift ( <h1>This is app</h1> ) wurde also der Absatz <p>mycomponent works!</p> eingef\u00fcgt. Wenn Sie sich den Quelltext Ihrer Seite anschauen, z.B. \u00fcber die Entwicklertools Ihres Browsers ( z.B. f\u00fcr Chrome ), dann wird folgender Code sichtbar: Wir k\u00f6nnen hier die Attribute der HTML-Elemente vernachl\u00e4ssigen (also z.B. _nghost-menu-c19 oder ng-version=\"9.0.7\" ). Aber es wird folgende HTML-Struktur sichtbar: < app-root > < h1 > This is app </ h1 > < app-mycomponent > < p > mycomponent works! </ p > </ app-mycomponent > < router-outlet ></ router-outlet > </ app-root > Das Element <app-root> fungiert als Platzhalter f\u00fcr die gesamte App. In dieses Element wird der gesamte Inhalt der Anwendung eingebunden (siehe app.component.html ). Dies ist hier zun\u00e4chst eine \u00dcberschrift <h1> , die von dem Element f\u00fcr die Mycomponent -Komponente gefolgt wird. Das bedeutet, dass in das Element <app-mycomponent> der Inhalt der Komponente Mycomponent eingebunden wird. Das ist hier nur ein Absatz <p> (siehe dazu mycomponent.component.html ). Das Element router-outlet> soll uns an dieser Stelle noch nicht interessieren. Das wird erst interessant, wenn wir \u00fcber das Routing in einer Angular-Anwendung sprechen.","title":"Eine neue Komponente erzeugen"},{"location":"angular/#direktiven","text":"In Angular gibt es 3 Arten sogenannter Direktiven (engl. Directives ): Komponentendirektiven (Components\u2014directives) Attributdirektiven (Attribute Directives) Strukturdirektiven (Structural-Direktives) Komponentendirektiven sind die meistverwendete Art und bereits in Angular \u2192 Kompnenten betrachtet. Attribut- und Strukturdirektiven k\u00f6nnen als HTML-Attribute verstanden werden, die dem HTML-Element ein zus\u00e4tzliches Verhalten hinzuf\u00fcgt. Attributdirektiven wirken sich das innere Verhalten eines HTML-Elementes aus (z.B. k\u00f6nnen damit CSS-Eigenschaften ge\u00e4ndert, hinzugef\u00fcgt oder gel\u00f6scht werden). Mit Strukturdirektiven kann die Struktur des DOMs ge\u00e4ndert werden (z.B. k\u00f6nnen ganze HTML-Elemente dem DOM-Baum hinzugef\u00fcgt werden).","title":"Direktiven"},{"location":"angular/#strukturdirektiven","text":"Strukturdirektiven beginnen immer mit einem Stern * . Die bekanntesten Vertreter sind *ngFor *ngIf *ngSwitch Diese sind auch in angular.io erl\u00e4utert. Wir erl\u00e4utern die darin aufgef\u00fchrten Beispiele und beginnen mit *ngIf : 1 2 3 4 5 6 7 8 < p * ngIf = \"true\" > Expression is true and ngIf is true. This paragraph is in the DOM. </ p > < p * ngIf = \"false\" > Expression is false and ngIf is false. This paragraph is not in the DOM. </ p > Die Direktive *ngIf wird also wie ein Attribut des <p> -Elementes behandelt. Das Attribut *ngIf hat entweder den Wert \"true\" oder den Wert \"false\" . Ja nach Wert des Attributes wird das jeweilige <p> -Element in den DOM-Baum eingebunden. Also entweder das <p> -Element aus den Codezeilen 1 - 4 (bei Wert \"true\" ) oder das <p> -Element aus den Codezeilen 5 - 8 (bei Wert \"false\" ). In einer echten Anwendung ergibt sich der Wert des Attributes/der Direktive meistens aus dem Wert einer boole'schen Variablen oder einem anderen boole'schen Ausdruck. Das nicht dargestellte Element ist auch nicht Teil des DOMs! Es ist also nicht einfach nur auf hide gesetzt, sondern es ist gar nicht im DOM vorhanden. Intern wird aus der *ngIf -Direktive \u00fcbrigens ein sogenanntes Property-Binding : < ng-template [ ngIf ]=\" true \" > < p > Expression is true and ngIf is true. This paragraph is in the DOM. </ p > </ ng-template > < ng-template [ ngIf ]=\" false \" > < p > Expression is false and ngIf is false. This paragraph is not in the DOM. </ p > </ ng-template > Die *ngFor -Direktive ist etwas komplexer als *ngIf . F\u00fcr *ngFor ben\u00f6tigen wir mindestens eine Liste (oder ein Array) und eine Laufvariable, die die Werte aus der Liste annehmen kann. Im folgenden Beispiel ist i unsere laufvariable und [1, 2, 3, 4, 5, 6] unser Array. < div * ngFor = \"let i of [1, 2, 3, 4, 5, 6]\" > {{ i }} </ div > F\u00fcr jeden Wert aus der Liste wird ein eigenes <div> - Element erzeugt. Der DOM-Baum sieht f\u00fcr obiges Beispiel also wie folgt aus (Angular-Attribute weggelassen): < div > 1 </ div > < div > 2 </ div > < div > 3 </ div > < div > 4 </ div > < div > 5 </ div > < div > 6 </ div > Au\u00dferdem stellt *ngFor noch einige Hilfsvariablen zur Verf\u00fcgung, die ebenfalls genutzt werden k\u00f6nnen: index (Index des aktuellen Elementes 0, 1, 2, ... ) first (ist true , wenn erstes Element, sonst false ) last (ist true , wenn letztes Element, sonst false ) even (ist true , wenn Index gerade , sonst false ) odd (ist true , wenn Index ungerade , sonst false ) Folgend ein komplexeres Beispiel unter Verwendung einiger Hilfsvariablen: 1 2 3 4 5 6 7 8 9 < div * ngFor = \"let value of [1, 2, 3, 4, 5, 6]; index as i; first as f; last as l; odd as o;\" > < div * ngIf = \"f\" > Start </ div > < div [ style . color ]=\" o ? ' red ' : ' blue '\" > {{ i }} : {{ value }} </ div > < div * ngIf = \"l\" > Ende </ div > </ div > In Zeile 1 ist unsere Laufvariable durch das Array nun value . Au\u00dferdem wird der jeweilige Wert von index in der Variablen i (Zeilennummer 2 ) gespeichert, der Wert von first in der Variablen f (Zeilennummer 3 ), der Wert von last in der Variablen l (Zeilennummer 4 ) und der Wert von odd in der Variablen o (Zeilennummer 5 ) - die Hilfsvariable even betrachten wir hier nicht, da deren Wert genau der Negation von odd entspricht. In Zeile 6 wenden wir die *ngIf -Direktive an: ein <div> mit dem Inhalt Start wird vor dem ersten Element aus dem Array ausgegeben. F\u00fcr jedes weitere Element nicht mehr. In Zeile 7 erfolgt ein Property Binding : die color -Eigenschaft bekommt einen Wert zugewiesen. Der Wert ist jedoch abh\u00e4ngig davon, ob o wahr ist (dann Wert red ) oder falsch (dann Wert blue ). Zeile 7 zeigt au\u00dferdem wie mithilfe von Interpolation der Wert von i und der Wert von value , getrennt mit : ausgegeben werden. Die Ausgabe ist also: Aufgabe Informieren Sie sich auch \u00fcber die *ngSwitch -Direktive. Implementieren Sie ein Beispiel, in dem Sie die 3 Direktiven *ngIf , *ngFor und *ngSwitch anwenden.","title":"*Strukturdirektiven"},{"location":"angular/#interpolation","text":"Interpolation ist die einfachste Form des data binding . Syntaktisch erkennt man Interpolation an den doppelten geschweiften Klammern {{ Interpolation }} . Beispiel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { Component } from '@angular/core' ; @ Component ({ selector : 'app-lesson' , template : ` <h1>{{ headline }}</h1> <p>Hier steht {{name}}</p> ` , styleUrls : [ './lesson.component.css' ] }) export class LessonComponent { headline = 'Mein Titel' ; name = 'mein Name' ; } Im obigen Beispiel hat die Komponente LessonComponent zwei Eigenschaften: headline und name . In obiger Komponente wird (zur Anschauung) sogenanntes inline templating verwendet, d.h. es gibt keine eigene lesson.component.html -Datei, in der der HTML-Code steht, sondern der HTML-Code wird direkt in die template -Eigenschaft der Typescript-Datei lesson.component.ts eingef\u00fcgt (siehe Zeilen 5-8 im obigen Beispiel). Der HTML-Code wird in backticks eingefasst ( `` ), nicht zu verwechseln mit den einfachen Anf\u00fchrungsstrichen ( '' ). Damit inline templating m\u00f6glich ist, wird die Komponente mit dem Flag -t erzeugt ( inlineTemplate=true ), d.h. unsere Lesson-Komponente wurde mithilfe der CLI wie folgt erzeugt: ng g c lesson -t Eine Interpolation kann auch Ausdr\u00fccke enthalten, die aufgel\u00f6st werden, z.B. < p > 1 + 2 = {{1 + 2}}. </ p > Man kann mithilfe einer Direktive durch ein Array laufen und jedes einzelne Element mithilfe von Interpolation ausgeben: @ Component ({ selector : 'app-lesson' , template : ` <ol> <li *ngFor=\"let day of weekdays\">{{ day }}</li> </ol> ` , styleUrls : [ './lesson.component.css' ] }) export class LessonComponent { weekdays = [ 'Monday' , 'Tuesday' , 'Wednesday' , 'Thursday' , 'Friday' , 'Saturday' , 'Sunday' ]; } Oder es ist m\u00f6glich, Attributen von HTML-Elementen mithilfe von Interpolation Werte zuzuordnen: @ Component ({ selector : 'app-lesson' , template : ` <img src=\"{{ imgUrl }}\" /> ` , styleUrls : [ './lesson.component.css' ] }) export class LessonComponent { imgUrl = 'https://www.dpunkt.de/common/images/cover_masterid/800/12400.jpg' ; }","title":"{{ Interpolation }}"},{"location":"angular/#property-bindings","text":"Insbesondere, wenn Attributen von HTML-Elementen Werte zugeordnet werden sollen (so wie im letzten Beispiel des Abschnitts {{Interpolation}} ), spricht man von property binding . Property binding spielt eine gro\u00dfe Rolle beim Datenfluss von Eltern-Komponenten auf Kind-Komponenten. Die generelle Idee dabei ist, dass mithilfe von property binding Werte (Daten) an Attribute von HTML-Elementen bindet. Diese HTML-Elemente k\u00f6nnen auch Komponenten sein. Wir betrachten zun\u00e4chst die unterschiedlichen Arten (Notationen) von property binding: < element [ property ]=\" ausdruck \" ></ element > D.h. ein ausdruck wird \u00fcbergeben, der zu einem Wert aufgel\u00f6st wird und dieser Wert wird dem Attribut property \u00fcbergeben. Betrachten wir nochmals das letzte Beispiel aus dem Abschnitt {{Interpolation}} ). Bei diesem Beispiel haben wir Interpolation verwendet, um dem Attribut src des HTML-Elementes img einen Wert zuzuweisen. Das exakt gleiche Verhalten l\u00e4sst sich auch mittels property bindings erzeugen: < img [ src ]=\" imgUrl \" /> <!-- imgUrl = 'https://www.dpunkt.de/common/images/cover_masterid/800/12400.jpg'; --> Neben diesen \"allgemeinen\" property bindings gibt es auch noch \"spezielle\" property bindings, n\u00e4mlich class bindings und style bindings . Bei class bindings wird das Pr\u00e4fix class vor die property (die entsprechende CSS-Klasse) gesetzt: < element [ class . class1 ]=\" class1enabled \" [ class . class2 ]=\" class2enabled \" ... ></ element > D.h. die CSS-Klasse class1 ist genau dann wirksam, wenn der Ausdruck class1enabled true ist und class2 ist genau dann wirksam, wenn der Ausdruck class2enabled true ist usw. Bei den style bindings werden jedoch gar keine Ausdr\u00fccke, sondern Werte \u00fcbergeben: < element [ style . color ]","title":"[Property Bindings]"},{"location":"angular/#event-bindings","text":"In den property bindings haben wir gesehen, wie Werte Attributen (Eigenschaften) von Elementen zugeordnet werden k\u00f6nnen. Aus JavaScript ist auch bekannt, dass Ereignisse Attribute von Elementen sein k\u00f6nnen, z.B. onClick , onKeyup , onChange usw. Dabei handelt es sich um sogenannte native DOM-Ereignisse . Neben der M\u00f6glichkeit, solche nativen DOM-Ereigniss zu behandeln, bietet Angular auch die M\u00f6glichkeit, eigene Ereignisse zu definieren und diese zu behandeln. Wir betrachten beide M\u00f6glichkeiten und beginnen mit den nativen Ereignissen.","title":"(Event Bindings)"},{"location":"angular/#native-dom-ereignisse","text":"In HTML sieht das unter Aufruf einer JavaScript-Funktion f\u00fcr die Ereignisbahandlung dann typischerweise (hier das Click-Ereignis f\u00fcr einen Button) wie folgt aus: HTML < button onClick = \"doSomething()\" > Click here! </ button > JavaScript function doSomething () { // something to do } In Angular ist das Prinzip das gleiche, nur dass das Ereignis in runden Klammern genannt und an dieses Ereignis die Ereignisbehandlung gebunden wird ( event binding ). Das bedeutet, das Angular-Template f\u00fcr das obige Beispiel sieht wie folgt aus: Angular-Template < button ( click )=\" doSomething ()\" > Click here! </ button > Angular-Typescript export class EventsComponent { doSomething () { // something to do } } Dieses Prinzip gilt f\u00fcr alle nativen DOM-Ereignisse. Hier ein kurzer \u00dcberblick \u00fcber die wichtigsten (f\u00fcr eine umfangreichere Liste siehe hier oder hier ): Ereignis Beschreibung click Mausklick auf das Element change Der Inhalt/Wert eines Elementes hat sich ge\u00e4ndert mouseover die Maus wird \u00fcber das Element bewegt mouseout die Maus wird vom Element wegbewegt keydown eine Taste der Tastatur wird gedr\u00fcckt keyup Loslassen einer Taste load der Browser hat die Seite vollst\u00e4ndig geladen focus Fokussieren des Elements (z.B. Anklicken) blur Verlieren des Fokus (z.B. Klick au\u00dferhalb) submit Abschicken eines Formulars copy , paste Kopieren, Einf\u00fcgen von Text Einen kleinen Unterschied gibt es noch bei der \u00dcbergabe des Ereignisses an die das Ereignis behandelnde Funktion zu beachten. W\u00e4hrend in plain JavaScript das Ereignis mit event der Funktion \u00fcbergeben wird, erfolgt die \u00dcbergabe des Ereignisses in Angular mit $event . Beispiel: Angular-Template < input ( change )=\" showPayload ($ event )\" type = \"text\" /> Angular-Typescript export class EventsComponent { showPayload ( e : Event ) { console . log ( e ); } } Alle Events (in TypeScript/Angular) sind vom Typ Event . Es gibt noch speziellere Eventtypen, die aber alle auf dem Interface Event basieren, z.B. MouseEvent , InputEvent , KeyboardEvent , UIEvent , ClipboardEvent . Weitere Details siehe hier . Die einfache JavaScript-Attributschreibweise kann in Angular nicht verwendet werden, sondern immer nur die event binding -Schreibweise von Angular (mit den runden Klammern)!","title":"Native DOM-Ereignisse"},{"location":"angular/#eigene-ereignisse","text":"F\u00fcr eine Komponente kann ein eigenes - nicht natives - Ereignis definiert werden. Dies geschieht, indem f\u00fcr eine Komponente eine neue Eigenschaft (z.B. myEvent ) definiert wird und diese vom Typ EventEmitter deklariert wird. Mithilfe von Generics kann der Typ des Events angegeben werden, der ausgel\u00f6st werden soll - wenn Sie den Typ nicht genau kennen, verwenden Sie any . Soll das Ereignis an die Elternkomponente weitergeleitet werden, was meistens der Fall ist, wird der Decorator @Output() verwendet. Das Ausl\u00f6sen des Events geschieht dann durch die emit() -Methode von EventEmitter . Hier ein typisches Beispiel (zun\u00e4chst die Kindkomponente EventsComponent - also events.component.html und events.component.ts ): .html < button ( click )=\" emitMyEvent ()\" > Click here! </ button > .ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { Component , EventEmitter , Output } from '@angular/core' ; @ Component ({ selector : 'app-events' , templateUrl : './events.component.html' , styleUrls : [ './events.component.css' ] }) export class EventsComponent { @ Output () myEvent = new EventEmitter < any > (); emitMyEvent () { this . myEvent . emit (); } } Die .html -Datei definiert einen Button mit dem nativen Ereignis click . Dieses wird durch die Methode emitMyEvent() behandelt. In der .ts -Datei ist diese Methode definiert (Zeilen 11-13). Darin wird das eigene Event myEvent ausgel\u00f6st. Dieses Event ist ein Objekt vom Typ EventEmitter , typisiert als any (beliebiger Typ). Das Ausl\u00f6sen dieses Events wird an die aufrufende Komponente (die Elternkomponente) ausgegeben (Decorator @Output() ). Deklaration der Eigenschaft und Dekorieren mit @Output() in Zeile 9. Das Ausl\u00f6sen des eigenen Events erfolgt durch den Aufruf der Methode emit() aus EventEmitter (Zeile 12). In der Elternkomponente kann dieses Ereignis nun empfangen werden (Beispiel einer Elternkomponente AppComponent - also app.component.html und app.component.ts ): .html < app-events ( myEvent )=\" handleEventFromEventsComponent ()\" ></ app-events > .ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { Component } from '@angular/core' ; @ Component ({ selector : 'app-root' , templateUrl : './app.component.html' , styleUrls : [ './app.component.css' ] }) export class AppComponent { handleEventFromEventsComponent () { console . log ( 'myEvent in der Kindkomponente ausgel\u00f6st' ); } } In der AppComponent (das kann nat\u00fcrlich eine beliebige Komponente sein), wird die EventsComponent eingebunden (siehe <app-events> im Template der AppComponent ). Dadurch entsteht die Hierarchie Elternkomponente AppComponent \u2192 Kindkomponente EventsComponent im DOM. Mithilfe von event binding wird die Behandlung des Ereignisses myEvent an die Methode handleEventFromEventsComponent() gebunden. In dieser Methode erfolgt hier einfach nur eine Ausgabe auf die Konsole. Interessant ist, dass wir dadurch die M\u00f6glichkeit haben, Daten von der Kindkomponente zur Elternkomponente flie\u00dfen zu lassen. Dazu \u00fcbergeben wir diese Daten als payload des Ereignisses. Daf\u00fcr typisieren wir EventEmitter mit dem Typ, von dem wir Daten \u00fcbergeben wollen (z.B. Book - siehe B\u00fccher-App ). Die beiden obigen Beispiele sehen dann wie folgt aus (zuerst wieder EventsComponent ): .html < button ( click )=\" emitMyEvent ( book )\" > Click here! </ button > .ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { Component , EventEmitter , Output } from '@angular/core' ; @ Component ({ selector : 'app-events' , templateUrl : './events.component.html' , styleUrls : [ './events.component.css' ] }) export class EventsComponent { @ Output () myEvent = new EventEmitter < Book > (); emitMyEvent ( book : Book ) { this . myEvent . emit ( book ); } } Im Template (HTML) werden die Daten der Ereignisbehandlung \u00fcbergeben. Das EventEmitter -Objekt ist mit dem konkreten Datentyp typisiert. Bei Aufruf der Methode emit() werden die Daten an die Elternkomponente \u00fcbergeben. Die Elternkomponente (hier wieder AppComponent kann diese Daten, die von der Kindkomponente an die Elternkomponente via Ereignis geflossen sind, nun weiterverarbeiten bzw. darstellen): .html < app-events ( myEvent )=\" handleEventFromEventsComponent ($ event )\" ></ app-events > .ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { Component } from '@angular/core' ; @ Component ({ selector : 'app-root' , templateUrl : './app.component.html' , styleUrls : [ './app.component.css' ] }) export class AppComponent { handleEventFromEventsComponent ( book : Book ) { console . log ( book . title ); } } Wichtig beim event binding der Elternkomponente ist, dass der payload des Ereignisses mit $event \u00fcbergeben wird (siehe auch Native DOM-Ereignisse ). Zusammenfassung In den letzten drei Abschnitten Interpolation, Property Binding und Event Binding haben wir uns mit Datenfluss besch\u00e4ftigt. Interpolation wird verwendet, um innerhalb einer Komponente die in der TypeScript-Klasse definierten Daten im Template darzustellen. Mithilfe von Property Binding kann die aufrufende Komponente (Elternkomponente) der aufgerufenen Kopmponente (Kindkomponente) Daten \u00fcbergeben. Mithilfe von Event Binding kann die Kindkomponente der Elternkomponente mithilfe eines eigenen Ereignisses Daten \u00fcbergeben. F\u00fcr die Anwendung dieser Konzepte schauen Sie sich B\u00fccher-App\u2192Datenfluss zwischen Komponenten an.","title":"Eigene Ereignisse"},{"location":"angular/#two-way-bindings","text":"","title":"[(Two-Way-Bindings)]"},{"location":"angular/#lifecycle-hooks","text":"Komponenten durchlaufen einen festen Lebenszyklus ( lifecycle ). Die verschiedenen Status rufen dabei jeweils eine Methode auf, die wir jeweils implementieren k\u00f6nnen, um in den jeweiligen Status des Lebenszyklus eingreifen zu k\u00f6nnen. Man spricht dabei von sogenannten Lifecycle-Hooks . Der wohl bekannteste Lifecycle-Hook ist ngOnInit() . Damit greift man in die Initialisierung der Komponente ein. Typischerweise werden z.B. Eingabewerte initialisiert, die im Template dargestellt werden. Noch vor ngOnInit wird jedoch ngOnChange() aufgerufen. N\u00e4mlich genau dann, wenn die Eingabewerte gesetzt bzw. ge\u00e4ndert werden. F\u00fcr weiterf\u00fchrende Informationen sei https://angular.io/guide/lifecycle-hooks empfohlen.","title":"Lifecycle-Hooks"},{"location":"angular/#services","text":"Ein Service ist eine Klasse f\u00fcr einen konkreten Zweck. Services unterscheiden sich von Komponenten dahingehend, dass eine Komponente f\u00fcr die Nutzerinteraktion zust\u00e4ndig ist, eine Komponente Eigenschaften (Daten) pr\u00e4sentiert, eine Komponente Methoden zur Datenbindung ( data binding ) zur Verf\u00fcgung stellt, um zwischen View und Anwendungslogik zu vermitteln. Ein Service erf\u00fcllt eine konkrete Aufgabe, typischerweise mit Daten, ohne sich um die Darstellung der Daten zu k\u00fcmmern. Typische Aufgaben eines Services sind: Daten vom Server holen oder auf den Server laden, Nutzereingaben zu validieren. Ein Service steht typischerweise allen Komponenten zur Verf\u00fcgung (aber nicht jede Komponente muss einen Service nutzen). Ein Service ist eine Klasse mit dem Decorator @Injectable() . Services enthalten Anwendungslogik, die aus Komponenten ausgelagert werden kann. Ein Service my kann mittels CLI so erzeugt werden: ng generate service shared/my Es entsteht im src/app/shared -Ordner eine Datei my.service.ts . Services sollten am besten in dem shared -Ordner erstellt werden, da ein Service von allen Komponenten genutzt werden kann (eine andere M\u00f6glichkeit w\u00e4re, einen eigenen Ordner services zu erstellen). In dem Decorator @Injectable() wird mittels providedIn: root angegeben, dass der Service von allen Komponenten innerhalb des Root-Moduls genutzt werden kann. Ist der Service von anderen Services oder Komponenten abh\u00e4ngig, k\u00f6nnen diese Services oder Komponenten mittels dependency injection als Parameter des Service-Konstruktor eingebunden werden. Hier ein allgemeines Beispiel eines Services MyService : my.service.ts 1 2 3 4 5 6 7 8 9 10 import { Injectable } from '@angular/core' ; @ Injectable ({ providedIn : 'root' }) export class MyService { constructor ( private myDependency : MyDependency ) { } } Der Service kann dann mittels dependency injection von einer Komponente verwendet werden. Beispiel: example.component.ts import { Component , OnInit } from '@angular/core' ; import { MyService } from './shared/my.service' ; @ Component ({ selector : 'app-example' , templateUrl : './example.component.html' , styleUrls : [ './example.component.css' ] }) export class ExampleComponent implements OnInit { constructor ( private myService : MyService ) { } ngOnInit () : void { this . example . methodOfMyService (); } } F\u00fcr ein Beispiel einer Service-Definition und der Verwendung eines Services siehe BookStoreService . F\u00fcr weiterf\u00fchrende Informationen siehe https://angular.io/guide/architecture-services .","title":"Services"},{"location":"angular/#routing","text":"Routing ist ein wesentliches Konzept f\u00fcr die Entwicklung von Single-Page-Applikationen (SPA). Bei Single-Page-Applikationen wird genau eine Seite vom Webserver geladen (typischerweise die index.html und alle weiteren, sich \u00e4ndernden, Inhalte und Sichten werden in diese Seite nachgeladen). Das f\u00fchrt zun\u00e4chst auch dazu, dass es f\u00fcr die Seite genau eine URL gibt, um auf sie zuzugreifen (z.B. http://www.mydomain.de bzw. http://www.mydomain.de/index.html ). M\u00f6chte man aber Komponenten direkt in der URL ansprechen, z.B. http://www.mydomain.de/login f\u00fcr die Login-Komponente, so ben\u00f6tigen wir das Routing von Angular. Wir betrachten hier ein Beispiel, das https://angular.io/guide/router entnommen ist und nur leicht abgewandelt wurde. Wir erstellen dazu zun\u00e4chst ein neues Projekt routing-lesson . ng new routing-lesson In der obigen Anweisung h\u00e4tte man auch bereits den Parameter --routing verwenden k\u00f6nnen, also: ng new routing-lesson --routing Macht man das nicht, werden Sie gefragt, ob Sie Routing verwenden wollen: ? Would you like to add Angular routing? [y|N] Antworten Sie mit y . Zur Demonstration des Routings werden wir zun\u00e4chst 2 weitere Komponenten erstellen: first und second . cd routing-lesson ng g c first ng g c second Wird ein Angular-Projekt mit Routing erstellt, so existiert die Datei app-routing.module.ts im src/app/ -Ordner. Diese Datei sieht urspr\u00fcnglich so aus: app-routing.module.ts 1 2 3 4 5 6 7 8 9 10 import { NgModule } from '@angular/core' ; import { Routes , RouterModule } from '@angular/router' ; const routes : Routes = []; @ NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { } Bei dieser Klasse handelt es sich um ein eigenes Angular-Modul (als @NgModule dekoriert). Es wird deshalb auch in die app.module.ts integriert (dies geschieht automatisch, wenn wir Routing ausgew\u00e4hlt haben) - siehe Zeilen 4 und 17 im folgenden Listing: app.module.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import { BrowserModule } from '@angular/platform-browser' ; import { NgModule } from '@angular/core' ; import { AppRoutingModule } from './app-routing.module' ; import { AppComponent } from './app.component' ; import { FirstComponent } from './first/first.component' ; import { SecondComponent } from './second/second.component' ; @ NgModule ({ declarations : [ AppComponent , FirstComponent , SecondComponent ], imports : [ BrowserModule , AppRoutingModule ], providers : [], bootstrap : [ AppComponent ] }) export class AppModule { } Das Array routes aus der Datei app-routing.module.ts enth\u00e4lt sp\u00e4ter die Pfadangaben zu den Komponenten - sogenannte Routen . Routen sind Objekte und wie folgt notiert: { path : 'mypath' , component : MyComponent } Diese Angabe bewirkt, dass unter der URL http://www.mydomain.de/mypath die Komponente MyComponent aufgerufen wird. Angenommen, wir wollen, dass unsere Komponente FirstComponent unter dem Pfad /first aufgerufen wird und SecondComponent unter dem Pfad /second , dann sieht unsere Datei app-routing.module.ts wie folgt aus: app-routing.module.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import { NgModule } from '@angular/core' ; import { Routes , RouterModule } from '@angular/router' ; import { FirstComponent } from './first/first.component' ; import { SecondComponent } from './second/second.component' ; const routes : Routes = [ { path : 'first' , component : FirstComponent }, { path : 'second' , component : SecondComponent } ]; @ NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { } In den Zeilen 8 und 9 sind die beiden Routen definiert. Beachten Sie, dass die Pfadangaben ohne vorangestelltes Slash / erfolgen! Unter Verwendung der Selektoren <app-first> bzw. <app-second> k\u00f6nnten wir unsere Komponenten nun (statisch) in unsere Anwendung einbinden. Wollen wir das jedoch dem Routing \u00fcberlassen, die Komponenten also dynamisch - abh\u00e4ngig von dem jeweils gew\u00e4hlten Pfad - einbinden lassen, verwenden wir stattdessen den Selektor <router-outlet> . Auch dieser ist bei gew\u00e4hltem Routing bereits Teil des AppComponent -Templates: app.component.html <!-- hier wurde viel vom urspr\u00fcnglichen --> <!-- Template gel\u00f6scht --> < h1 > Hier ist AppComponent </ h1 > < router-outlet ></ router-outlet > Obiges Listing zeigt, dass das Template von AppComponent zun\u00e4chst eine <h1> -\u00dcberschrift vorsieht und dann folgt das <router-outlet> , welches als Platzhalter f\u00fcr die durch das Routing ausgew\u00e4hlten Komponenten agiert. Angenommen, wir definieren die Templates f+r FirstComponent und SecondComponent wie folgt: first.component.html < h3 > Hier ist FirstComponent </ h3 > second.component.html < h3 > Hier ist SecondComponent </ h3 > Starten wir nun unsere Anwendung, dann sehen wir zun\u00e4chst (URL: http://localhost:4200/ ) nur die View der AppComponent , n\u00e4mlich die <h1> -\u00dcberschrift. Der Platzhalter <router-outlet> bleibt leer, da keine der angegebenen Pfade aus der app-routing.module.ts angegeben wurde. Geben wir jedoch als URL http://localhost:4200/first ein, so wird das Template der FirstComponent in diesen Platzhalter geladen, n\u00e4mlich die <h3 -\u00dcberschrift Hier ist FirstComponent . Geben wir als URL stattdessen http://localhost:4200/second ein, so wird das Template der SecondComponent in den Platzhalter <router-outlet> geladen, n\u00e4mlich die <h3 -\u00dcberschrift Hier ist SecondComponent . Die folgende Abbildung zeigt die Views der drei F\u00e4lle: Wir haben nun Pfade erzeugt, mit denen man Komponenten direkt ansprechen kann. Im folgenden Abschnitt wird gezeigt, wie man diese Pfade in Hyperlinks nutzt.","title":"Routing"},{"location":"angular/#routen-verlinken","text":"Wir kennen nun die m\u00f6glichen Pfade unserer Anwendung http://localhost:4200/ , http://localhost:4200/first und http://localhost:4200/second und w\u00fcrden diese Adressen z.B. gerne in Hyperlinks verwenden, um direkt zu den Views der jeweiligen Komponente zu springen, z.B. so: app.component.html < h1 > Hier ist AppComponent </ h1 > < ul > < li > < a href = \"/\" > home </ a > </ li > < li > < a href = \"/first\" > first </ a > </ li > < li > < a href = \"/second\" > second </ a > </ li > </ ul > < router-outlet ></ router-outlet > Das funktioniert auch, hat aber einen von uns nicht gewollten Effekt: Die Seite wird durch jeden Klick auf einen Hyperlink neu geladen. Das ist ja auch das gew\u00fcnschte Verhalten eines Hyperlinks. Die Idee einer Single-Page-Applikation ist aber jedoch die, dass die Seite nur genau einmal geladen wird und dann dynamisch alle weiteren Inhalte. Das Nachladen wird vermieden, wenn wir als Attribut f\u00fcr unsere Pfade nicht href verwenden, sondern die Angular-Direktive routerLink . Dies gilt nur f\u00fcr interne Links! Aber es verhindert bei internen Links ein Neuladen der Seite. app.component.html < h1 > Hier ist AppComponent </ h1 > < ul > < li > < a routerLink = \"/\" > home </ a > </ li > < li > < a routerLink = \"/first\" > first </ a > </ li > < li > < a routerLink = \"/second\" > second </ a > </ li > </ ul > < router-outlet ></ router-outlet > Die obige Attributschreibweise kann auch durch property binding ersetzt werden. Dann \u00fcbergeben Sie als Wert aber keinen String sondern ein 1-elementiges Array: app.component.html < h1 > Hier ist AppComponent </ h1 > < ul > < li > < a [ routerLink ]=\"['/']\" > home </ a > </ li > < li > < a [ routerLink ]=\"['/ first ']\" > first </ a > </ li > < li > < a [ routerLink ]=\"['/ second ']\" > second </ a > </ li > </ ul > < router-outlet ></ router-outlet > Die zweite Variante wird meistens dann verwendet, wenn an den Pfad noch dynamisch Werte \u00fcbergeben werden, sogenannte Parameter an den Routen.","title":"Routen verlinken"},{"location":"angular/#parameter-an-routen","text":"H\u00e4ufig sind die Pfadangaben nicht nur so statisch wie bisher, also /first bzw. /second , sondern es werden auch noch Werte, z.B. Session-IDs, Nutzer-IDs, B\u00fccher-ISBN usw. \u00fcbergeben. Dazu werden die Routen durch Parameter erweitert. Diese Parameter werden dann mit einem konkreten Wert bei Aufruf ersetzt. Die allgemeine Syntax f\u00fcr einen parametrisierten Pfad ist: { path : 'mypath/:id' , component : MyComponent } Der Doppelpunkt : ist zwingend, der Name des Parameters id ist frei w\u00e4hlbar. Die Werte f\u00fcr den Routenparameter k\u00f6nnen als routerLink wieder entweder als String \u00fcbergeben werden (Zeile 1 im folgenden Listing) oder per property binding als weiteres Array-Element (Zeile 2 im folgenden Listing). 1 2 < a routerLink = \"/mypath/4711\" > statischer Wert f\u00fcr id </ a > < a [ routerLink ]=\"['/ mypath ', myData . id ]\" > dynamischer Wert f\u00fcr id (aus JSON myData) </ a > Wir haben jetzt eine parametrisierten Pfad konfiguriert und wir haben auch betrachtet, wie der Aufruf einer solch parametrisierten Route erfolgen kann. Nun betrachten wir, wie der Wert eines Parameters in einer Komponentenklasse ausgelesen und verarbeitet werden kann. Wir f\u00fchren dazu zun\u00e4chst kleinere \u00c4nderungen an unserem obigen Beispiel der routing-lesson -App durch: app-routing.module.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import { NgModule } from '@angular/core' ; import { Routes , RouterModule } from '@angular/router' ; import { FirstComponent } from './first/first.component' ; import { SecondComponent } from './second/second.component' ; const routes : Routes = [ { path : 'first' , component : FirstComponent }, { path : 'first/:id' , component : FirstComponent }, { path : 'second' , component : SecondComponent } ]; @ NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { } first.component.html 1 2 < h3 > Hier ist FirstComponent </ h3 > < p * ngIf = \"id\" > {{ id }} </ p > In app-routing.module.ts haben wir einen weiteren Pfad hinzugef\u00fcgt (Zeilennummer 8). Beachten Sie, dass ohne die Pfadkonfiguration in Zeilennummer 7 die Route http://localhost:4200/first (also ohne Parameterwert) nicht mehr existieren w\u00fcrde. Wenn ein Parameter erforderlich ist, dann muss er auch angegeben werden. Nur in Kombination der beiden Pfadkonfigurationen aus Zeilennummern 7 und 8 ist der Pfad sowohl mit als auch ohne Parameterwert m\u00f6glich. Im Template der FirstComponent haben wir einen Absatz eingef\u00fcgt, der als Inhalt den Wert der Eigenschaft id mittels Interpolation anzeigt. Der Absatz erscheint nur, wenn id auch einen Wert hat. Die Eigenschaft id muss allerdings noch in der first.component.ts angelegt werden: first.component.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { Component , OnInit } from '@angular/core' ; import { ActivatedRoute } from '@angular/router' ; @ Component ({ selector : 'app-first' , templateUrl : './first.component.html' , styleUrls : [ './first.component.css' ] }) export class FirstComponent implements OnInit { id : string ; constructor ( private route : ActivatedRoute ) { } ngOnInit () : void { this . id = this . route . snapshot . paramMap . get ( 'id' ); } } In der first.component.ts kommen verschiedene Sachen hinzu: es wird die Eigenschaft id deklariert (als string ) es wird der Service ActivatedRoute per dependency injection der Klasse FirstComponent injiziert \u2192 die Eigenschaft route ist vom Typ ActivatedRoute ActivatedRoute stellt uns Informationen \u00fcber den aktuellen Router (die aktuelle URL) zur Verf\u00fcgung \u2192 die Eigenschaft this.route.snapshot.paramMap enth\u00e4lt alle Parameter der aktuellen Route \u2192 mithilfe der Methode get() kann nach einem konkreten Parameter gefragt werden \u2192 wir fragen nach dem Parameter id , da wir so unseren Pfad konfiguriert haben (siehe oben app-routing.module.ts ) Wenn wir nun z.B. die URL http://localhost:4200/first/42 eingeben, dann erscheint im Brower der Wert des Parameters (als Inhalt des <p> -Elementes; siehe oben first.component.html ). Die aktuelle Implementierung von first.component.ts liest also w\u00e4hrend der Initialisierung der Komponente die Routenparameter aus. Finden jedoch am Parameterwert \u00c4nderungen statt, ohne dass die Komponente neu initialisiert wird, bekommt die Komponente von den \u00c4nderungen nichts mit. Die oben gezeigte Form der Implementierung ist deshalb nicht f\u00fcr alle F\u00e4lle geeignet. Vielmehr ist es besser auszunutzen, dass es sich bei this.route.paramMap (ohne snapshot ) um ein Observable handelt. Ein Observable kann so verstanden werden, dass er permanent eine bestimmte Sache beobachtet (z.B. ist der EventEmitter ein Observable und beobachtet permanent, ob das Ereignis ausgel\u00f6st wird; wenn ja, dann ruft EventEmitter die Funktion emit() auf \u2192 siehe Eigene Ereignisse ). Wenn sich etwas an dem beobachteten Objekt ge\u00e4ndert hat, dann reagiert Observable sofort und ruft eine bestimmte Funktion auf. Das Observable paramMap beobachtet permanent die aktuelle Route und sobald sich etwas an dieser Route \u00e4ndert, wird eine Funktion aufgerufen. Damit das Observable aber \u00fcberhaupt den aktuellen Router permanent beobachtet, muss er an den Router angemeldet werden \u2192 das Observable \"abboniert\" den Router. Dies geschieht mithilfe der Funktion subscribe() . Dieser Funktion kann als Parameter eine Funktion \u00fcbergeben werden. Diese Funktion wird aufgerufen, sobald sich am aktuellen Router etwas \u00e4ndert. Wir \u00e4ndern die Implementierung von ngOnInit() in der Klasse first.component.ts deshalb wie folgt: first.component.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { Component , OnInit } from '@angular/core' ; import { ActivatedRoute } from '@angular/router' ; @ Component ({ selector : 'app-first' , templateUrl : './first.component.html' , styleUrls : [ './first.component.css' ] }) export class FirstComponent implements OnInit { id : string ; constructor ( private route : ActivatedRoute ) { } ngOnInit () : void { this . route . paramMap . subscribe ( paramMap => this . id = paramMap . get ( 'id' ) ); } } Nun erh\u00e4lt die Eigenschaft id immer den aktuellsten Wert (und dieser wird aufgrund der Interpolation auch stets aktuell in der View dargestellt).","title":"Parameter an Routen"},{"location":"angular/#verschachtelte-routen","text":"Angenommen, wir haben zwei weitere Komponenten OneComponent und TwoComponent und beide Komponenten sind Kindkomponenten von der Elternkomponente FirstComponent . Das Verh\u00e4ltnis Eltern- Kindkomponente entsteht ja eigentlich dadurch, dass das Template der Elternkomponente den Selektor der Kindkomponente enth\u00e4lt. Das hei\u00dft in first.component.html gibt es sowohl ein <app-one></app-one> als auch ein <app-two></app-two> \u2192 dann sind One und Two Kindkomponenten von First . Wir wollen nun aber folgendes: die Route /first verweist auf die FirstComponent die Route /first/one verweist auf die FirstComponent und deren Kindkomponente OneComponent die Route /first/two verweist auf die FirstComponent und deren Kindkomponente TwoComponent Wir wollen also, dass auch die beiden Kindkomponenten mittels Routing in die Elternkomponente eingef\u00fcgt werden. Das erreichen wir mit 2 Anpassungen: in app-routing.module.ts kann im routes -Array auch noch die Eigenschaft children hinzugef\u00fcgt werden, welche Pfadkonfigurationen zu den Kindkomponenten enth\u00e4lt in der *.component.html der Elternkomponente wird ein weiteres <router-outlet></router-outlet> hinzugef\u00fcgt app-routing.module.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { Routes , RouterModule } from '@angular/router' ; import { FirstComponent } from './first/first.component' ; import { SecondComponent } from './second/second.component' ; import { OneComponent } from './first/one/one.component' ; import { TwoComponent } from './first/two/two.component' ; const routes : Routes = [ { path : 'first' , component : FirstComponent , children : [ { path : 'one' , component : OneComponent }, { path : 'two' , component : TwoComponent }, ]}, { path : 'first/:id' , component : FirstComponent }, { path : 'second' , component : SecondComponent } ]; @ NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { } first.component.html 1 2 3 4 5 6 7 < h3 > Hier ist FirstComponent </ h3 > < ul > < li >< a [ routerLink ]=\"['/ first / one ']\" > first/one </ a ></ li > < li >< a [ routerLink ]=\"['/ first / two ']\" > first/two </ a ></ li > </ ul > < p * ngIf = \"id\" > {{ id }} </ p > < router-outlet ></ router-outlet > app.component.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 < h1 > Hier ist AppComponent </ h1 > < ul > < li > < a [ routerLink ]=\"['/']\" > home </ a > </ li > < li > < a [ routerLink ]=\"['/ first ']\" > first </ a > </ li > < li > < ul > < li >< a [ routerLink ]=\"['/ first / one ']\" > first/one </ a ></ li > < li >< a [ routerLink ]=\"['/ first / two ']\" > first/two </ a ></ li > </ ul > </ li > < li > < a [ routerLink ]=\"['/ second ']\" > second </ a > </ li > </ ul > < router-outlet ></ router-outlet > Das bedeutet, dass wir nun zwei <router-outlet></router-outlet> -Elemente haben. Eines in der app.component.html f\u00fcr die Routen first , first/:id und second und eines in der first.component.html f\u00fcr die Routen first/one und first/two .","title":"Verschachtelte Routen"},{"location":"angular/#styles-fur-aktive-routen","text":"Sie k\u00f6nnen angeben, welche CSS-Klassen wirken sollen, falls eine Route aktiv ist. Eine Route ist aktiv, wenn Sie ausgew\u00e4hlt/angewendet werden kann. Dazu wurde in Angular das Attribut routerLinkActive eingef\u00fchrt. Angenommen, die CSS-Klasse myactiveclass soll Anwendung f\u00fcr eine aktuelle (aktive) Route /first Anwendung finden, dann definieren Sie: < a routerLink = \"/first\" routerLinkActive = \"myactiveclass\" > first </ a > Sie k\u00f6nnen auch mehrere CSS-Klassen definieren. Daf\u00fcr gibt es zwei verschiedene M\u00f6glichkeiten: < a routerLink = \"/first\" routerLinkActive = \"myactiveclass1 myactiveclass1\" > first </ a > < a routerLink = \"/first\" [ routerLinkActive ]=\"[' myactiveclass1 ', ' myactiveclass1 ']\" > first </ a > Das Styling aktiver Routen ist insbesondere f\u00fcr Navigationsleisten (Men\u00fcs) hilfreich.","title":"Styles f\u00fcr aktive Routen"},{"location":"angular/#routen-im-programm-wechseln","text":"Der Service Router stellt zwei Methoden zur Verf\u00fcgung, mit denen eine Route im Programm gewechselt werden kann, z.B. nach einer Nutzereingabe oder einer Nutzerinteraktion: navigate() navigateByUrl() Angenommen, wir erweitern unsere Komponente SecondComponent um einen Button. Durch den Klick auf den Button soll von der SecondComponent auf die OneComponent \u00fcber die Route /first/one gewechselt werden: second.component.html 1 2 < h3 > Hier ist SecondComponent </ h3 > < button ( click )=\" changeRoute ()\" > /first/one </ button > second.component.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { Component , OnInit } from '@angular/core' ; import { Router } from '@angular/router' ; @ Component ({ selector : 'app-second' , templateUrl : './second.component.html' , styleUrls : [ './second.component.css' ] }) export class SecondComponent implements OnInit { constructor ( private router : Router ) { } ngOnInit () : void { } changeRoute () { this . router . navigate ([ '/first' , 'one' ]); // oder // this.router.navigateByUrl('/first/one'); } } In der second.component.ts sehen wir in Zeile 11, dass der Service Router per dependency injection eingebunden wird. Der Eigenschaft router stehen die Methoden navigate() bzw. navigateByUrl() zur Verf\u00fcgung. Wir sehen in den Zeilen 16-20 die Behandlung des Click -Ereignisses des Buttons. In Zeile 17 wird darin programmatisch die Route /first/one aufgerufen.","title":"Routen im Programm wechseln"},{"location":"angular/#httpclient","text":"Wir wissen bereits, dass Angular eine TypeScript-Framework ist, mit dem sich Single-Page-Anwendungen implementieren lassen. Es wird einmalig eine Seite (h\u00e4ufig index.html ) vom Server geladen und alle weiteren Inhalte werden sukzessive bzw. durch Nutzerinteraktionen gesteuert in diese eine Seite nachgeladen. Die Steuering wird dabei durch den Browser vorgenommen, der das aus TypeScript \u00fcbersetzte JavaScript interpretiert und entsprechend die Templates der Komponenten in die Anwendung einbindet. Das bedeutet, dass im Prinzip die gesamte Logik im Client , d.h. im Browser ausgef\u00fchrt wird. Dem gegen\u00fcber steht jedoch die in der Anwendung verarbeitete Menge von Daten, die typischerweise in einer Datenbank auf einem Server bereitgestellt werden. W\u00e4hrend der Client sich darum k\u00fcmmert, dass Daten angezeigt oder eingegeben werden, muss sich der Server darum k\u00fcmmern, dass Daten in die Datenquelle (die Datenbank) neu eingef\u00fcgt, ausgelesen, aktualisiert und gel\u00f6scht werden k\u00f6nnen. Diese vier Operationen werden mit CRUD abgek\u00fcrzt f\u00fcr: C reate - neue Daten einf\u00fcgen R ead - Daten auslesen U pdate - Daten aktualisieren D elete - Daten l\u00f6schen Der Client und der Server m\u00fcssen dazu nun irgendwie verbunden werden. Diese Verbindung erfolgt mithilfe des Hypertext Transfer Protocols (HTTP) .","title":"HTTPClient"},{"location":"books-backend/","text":"B\u00fccher-Backend \u00b6 Datenbank erstellen \u00b6 http://localhost/phpmyadmin Datei books-db.sql files/books-db.sql -- phpMyAdmin SQL Dump -- version 5.0.2 -- https://www.phpmyadmin.net/ -- -- Host: localhost -- Generation Time: Jul 15, 2020 at 02:36 PM -- Server version: 8.0.17 -- PHP Version: 7.3.11 SET SQL_MODE = \"NO_AUTO_VALUE_ON_ZERO\" ; START TRANSACTION ; SET time_zone = \"+00:00\" ; /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */ ; /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */ ; /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */ ; /*!40101 SET NAMES utf8mb4 */ ; -- -- Database: `books-db` -- -- -------------------------------------------------------- -- -- Table structure for table `author` -- CREATE TABLE `author` ( `author_id` int ( 11 ) NOT NULL , `lastname` varchar ( 255 ) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL , `firstname` varchar ( 255 ) NOT NULL ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ; -- -- Dumping data for table `author` -- INSERT INTO `author` (`author_id`, `lastname`, `firstname`) VALUES ( 1 , 'Malcher' , 'Ferdinand' ), ( 2 , 'Hoppe' , 'Johannes' ), ( 3 , 'Kopenhagen' , 'Danny' ), ( 4 , 'Zeigermann' , 'Oliver' ), ( 5 , 'Hartmann' , 'Nils' ), ( 6 , 'Bloch' , 'Joshua' ); -- -------------------------------------------------------- -- -- Table structure for table `author_book` -- CREATE TABLE `author_book` ( `id` int ( 11 ) NOT NULL , `author_id` int ( 11 ) NOT NULL , `book_id` int ( 11 ) NOT NULL ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ; -- -- Dumping data for table `author_book` -- INSERT INTO `author_book` (`id`, `author_id`, `book_id`) VALUES ( 1 , 1 , 1 ), ( 2 , 2 , 1 ), ( 3 , 3 , 1 ), ( 4 , 4 , 2 ), ( 5 , 5 , 2 ), ( 6 , 6 , 3 ); -- -------------------------------------------------------- -- -- Table structure for table `books` -- CREATE TABLE `books` ( `book_id` int ( 11 ) NOT NULL , `isbn` varchar ( 30 ) NOT NULL , `title` varchar ( 50 ) NOT NULL , `published` date NOT NULL , `subtitle` varchar ( 255 ) NOT NULL , `rating` smallint ( 6 ) NOT NULL , `thumbnails` int ( 11 ) NOT NULL , `description` varchar ( 255 ) NOT NULL ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ; -- -- Dumping data for table `books` -- INSERT INTO `books` (`book_id`, `isbn`, `title`, `published`, `subtitle`, `rating`, `thumbnails`, `description`) VALUES ( 1 , '9783864906466' , 'Angular' , '2019-04-30' , 'Grundlagen, fortgeschrittene Techniken und Best Practices - mit NativeScript und NgRx' , 5 , 1 , 'Die Autoren f\u00fchren Sie mit einem anspruchsvollen Beispielprojekt durch die Welt von Angular...' ), ( 2 , '9783864903274' , 'React' , '2016-06-17' , 'Die praktische Einf\u00fchrung in React, React Router und Redux' , 3 , 2 , 'React ist ein JavaScript-Framework zur Entwicklung von Benutzeroberfl\u00e4chen ...' ), ( 3 , '978-3-86490-578-0' , 'Effective Java' , '2018-09-01' , 'Best Practices f\u00fcr die Java-Plattform' , 3 , 3 , 'Seit der Vorauflage von Effective Java hat sich Java dramatisch ver\u00e4ndert...' ); -- -------------------------------------------------------- -- -- Table structure for table `thumbnail` -- CREATE TABLE `thumbnail` ( `id` int ( 11 ) NOT NULL , `url` varchar ( 255 ) NOT NULL , `title` varchar ( 255 ) NOT NULL ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ; -- -- Dumping data for table `thumbnail` -- INSERT INTO `thumbnail` (`id`, `url`, `title`) VALUES ( 1 , 'https://ng-buch.de/cover2.jpg' , 'Buchcover' ), ( 2 , 'https://ng-buch.de/cover1.jpg' , 'Buchcover' ), ( 3 , 'https://www.dpunkt.de/common/images/cover_masterid/300/13216.jpg' , 'Buchcover' ); -- -- Indexes for dumped tables -- -- -- Indexes for table `author` -- ALTER TABLE `author` ADD PRIMARY KEY ( `author_id` ), ADD KEY `author_id` ( `author_id` ); -- -- Indexes for table `author_book` -- ALTER TABLE `author_book` ADD PRIMARY KEY ( `id` ), ADD UNIQUE KEY `id` ( `book_id` , `author_id` ), ADD KEY `author_id` ( `author_id` ); -- -- Indexes for table `books` -- ALTER TABLE `books` ADD PRIMARY KEY ( `book_id` ), ADD KEY `book_id` ( `book_id` ), ADD KEY `thumbnails` ( `thumbnails` ); -- -- Indexes for table `thumbnail` -- ALTER TABLE `thumbnail` ADD PRIMARY KEY ( `id` ); -- -- AUTO_INCREMENT for dumped tables -- -- -- AUTO_INCREMENT for table `author` -- ALTER TABLE `author` MODIFY `author_id` int ( 11 ) NOT NULL AUTO_INCREMENT , AUTO_INCREMENT = 7 ; -- -- AUTO_INCREMENT for table `author_book` -- ALTER TABLE `author_book` MODIFY `id` int ( 11 ) NOT NULL AUTO_INCREMENT , AUTO_INCREMENT = 7 ; -- -- AUTO_INCREMENT for table `books` -- ALTER TABLE `books` MODIFY `book_id` int ( 11 ) NOT NULL AUTO_INCREMENT , AUTO_INCREMENT = 12 ; -- -- AUTO_INCREMENT for table `thumbnail` -- ALTER TABLE `thumbnail` MODIFY `id` int ( 11 ) NOT NULL AUTO_INCREMENT , AUTO_INCREMENT = 4 ; -- -- Constraints for dumped tables -- -- -- Constraints for table `author_book` -- ALTER TABLE `author_book` ADD CONSTRAINT `author_book_ibfk_1` FOREIGN KEY ( `author_id` ) REFERENCES `author` ( `author_id` ), ADD CONSTRAINT `author_book_ibfk_2` FOREIGN KEY ( `book_id` ) REFERENCES `books` ( `book_id` ); -- -- Constraints for table `books` -- ALTER TABLE `books` ADD CONSTRAINT `books_ibfk_1` FOREIGN KEY ( `thumbnails` ) REFERENCES `thumbnail` ( `id` ); COMMIT ; /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */ ; /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */ ; /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */ ; Node.js-Projekt erstellen \u00b6 Ordner books-backend erstellen. In diesen Ordner wechseln. Im Ordner npm init ausf\u00fchren (es entsteht eine package.json ). mkdir books-backend cd books-backend npm init Alle Fragen mit einem Enter beantworten (oder etwas eingeben, wenn Sie m\u00f6chten). Jetzt noch die Packages express und mysql installieren. npm install express npm install mysql Im Ordner books-backend eine index.js erzeugen: books-backend/index.js const express = require ( 'express' ); const app = express (); app . listen ( 8081 , () => { console . log ( 'Server is listening to http://localhost:8081' ); }); Im Ordner books-backend einen Ordner books erzeugen. Darin eine index.js (f\u00fcr den Router), eine model.js (f\u00fcr die Datenbankanbindung) und eine controller.js (f\u00fcr die Aktionsverwaltung) erstellen. Einen Endpunkt ( localhost/books/authors ) erstellen, um alle Authoren aus der Datenbank auszulesen (mit GET ). /books/model.js const mysql = require ( 'mysql' ); const connection = mysql . createConnection ({ host : 'localhost' , user : 'root' , password : 'password' , database : 'books-db' , }); connection . connect (); function getAllAuthors () { return new Promise (( resolve , reject ) => { const query = 'SELECT * FROM author' ; connection . query ( query , ( error , results ) => { if ( error ) reject ( error ); else resolve ( results ); }) }); } module . exports = { getAllAuthors , }; /books/controller.js const model = require ( './model' ); function readAuthors ( request , response ) { model . getAllAuthors (). then ( authors => response . json ( authors ), error => response . json ( error ), ); } module . exports = { readAuthors , } /books/index.js const express = require ( 'express' ); const router = express . Router (); const { readAuthors } = require ( './controller' ); router . get ( '/authors' , readAuthors ); module . exports = router ; Zum Testen in Postman: http://localhost:8081/books/authors eingeben und GET -Methode w\u00e4hlen. Es erscheint das JSON mit allen Autoren: Response-Body [ { \"author_id\" : 1 , \"lastname\" : \"Malcher\" , \"firstname\" : \"Ferdinand\" }, { \"author_id\" : 2 , \"lastname\" : \"Hoppe\" , \"firstname\" : \"Johannes\" }, { \"author_id\" : 3 , \"lastname\" : \"Kopenhagen\" , \"firstname\" : \"Danny\" }, { \"author_id\" : 4 , \"lastname\" : \"Zeigermann\" , \"firstname\" : \"Oliver\" }, { \"author_id\" : 5 , \"lastname\" : \"Hartmann\" , \"firstname\" : \"Nils\" }, { \"author_id\" : 6 , \"lastname\" : \"Bloch\" , \"firstname\" : \"Joshua\" } ] GET - einen Autor auslesen \u00b6 Neu hinzugekommener Code highlighted: /books/model.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 const mysql = require ( 'mysql' ); const connection = mysql . createConnection ({ host : 'localhost' , user : 'root' , password : 'password' , database : 'books-db' , }); connection . connect (); function getAllAuthors () { return new Promise (( resolve , reject ) => { const query = 'SELECT * FROM author' ; connection . query ( query , ( error , results ) => { if ( error ) reject ( error ); else resolve ( results ); }) }); } function getOneAuthor ( id ) { return new Promise (( resolve , reject ) => { const query = 'SELECT * FROM author WHERE author_id=?' ; connection . query ( query , [ id ], ( error , results ) => { if ( error ) reject ( error ); else resolve ( results [ 0 ]); }); }); } module . exports = { getAllAuthors , getAuthor ( id ) { return getOneAuthor ( id ) }, }; /books/controller.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const model = require ( './model' ); function readAuthors ( request , response ) { model . getAllAuthors (). then ( authors => response . json ( authors ), error => response . json ( error ), ); } function readAuthor ( request , response ) { model . getAuthor ( request . params . id ). then ( author => response . json ( author ), error => response . status ( 500 ). json ( error ), ); } module . exports = { readAuthors , readAuthor , } /books/index.js 1 2 3 4 5 6 7 8 const express = require ( 'express' ); const router = express . Router (); const { readAuthors , readAuthor } = require ( './controller' ); router . get ( '/authors' , readAuthors ); router . get ( '/author/:id' , readAuthor ); module . exports = router ; Zum Testen in Postman z.B. http://localhost:8081/books/author/4 (Autor mit der author_id 4) und GET aufrufen. POST - einen neuen Autoren anlegen und PUT - einen Autoren \u00e4ndern \u00b6 Ein neuer Autor bzw. die \u00c4nderungen werden als JSON dem Request-Body \u00fcbergeben. Dazu wird das Paket body-parser ben\u00f6tigt. npm install body-parser","title":"B\u00fccher-Backend"},{"location":"books-backend/#bucher-backend","text":"","title":"B\u00fccher-Backend"},{"location":"books-backend/#datenbank-erstellen","text":"http://localhost/phpmyadmin Datei books-db.sql files/books-db.sql -- phpMyAdmin SQL Dump -- version 5.0.2 -- https://www.phpmyadmin.net/ -- -- Host: localhost -- Generation Time: Jul 15, 2020 at 02:36 PM -- Server version: 8.0.17 -- PHP Version: 7.3.11 SET SQL_MODE = \"NO_AUTO_VALUE_ON_ZERO\" ; START TRANSACTION ; SET time_zone = \"+00:00\" ; /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */ ; /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */ ; /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */ ; /*!40101 SET NAMES utf8mb4 */ ; -- -- Database: `books-db` -- -- -------------------------------------------------------- -- -- Table structure for table `author` -- CREATE TABLE `author` ( `author_id` int ( 11 ) NOT NULL , `lastname` varchar ( 255 ) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL , `firstname` varchar ( 255 ) NOT NULL ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ; -- -- Dumping data for table `author` -- INSERT INTO `author` (`author_id`, `lastname`, `firstname`) VALUES ( 1 , 'Malcher' , 'Ferdinand' ), ( 2 , 'Hoppe' , 'Johannes' ), ( 3 , 'Kopenhagen' , 'Danny' ), ( 4 , 'Zeigermann' , 'Oliver' ), ( 5 , 'Hartmann' , 'Nils' ), ( 6 , 'Bloch' , 'Joshua' ); -- -------------------------------------------------------- -- -- Table structure for table `author_book` -- CREATE TABLE `author_book` ( `id` int ( 11 ) NOT NULL , `author_id` int ( 11 ) NOT NULL , `book_id` int ( 11 ) NOT NULL ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ; -- -- Dumping data for table `author_book` -- INSERT INTO `author_book` (`id`, `author_id`, `book_id`) VALUES ( 1 , 1 , 1 ), ( 2 , 2 , 1 ), ( 3 , 3 , 1 ), ( 4 , 4 , 2 ), ( 5 , 5 , 2 ), ( 6 , 6 , 3 ); -- -------------------------------------------------------- -- -- Table structure for table `books` -- CREATE TABLE `books` ( `book_id` int ( 11 ) NOT NULL , `isbn` varchar ( 30 ) NOT NULL , `title` varchar ( 50 ) NOT NULL , `published` date NOT NULL , `subtitle` varchar ( 255 ) NOT NULL , `rating` smallint ( 6 ) NOT NULL , `thumbnails` int ( 11 ) NOT NULL , `description` varchar ( 255 ) NOT NULL ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ; -- -- Dumping data for table `books` -- INSERT INTO `books` (`book_id`, `isbn`, `title`, `published`, `subtitle`, `rating`, `thumbnails`, `description`) VALUES ( 1 , '9783864906466' , 'Angular' , '2019-04-30' , 'Grundlagen, fortgeschrittene Techniken und Best Practices - mit NativeScript und NgRx' , 5 , 1 , 'Die Autoren f\u00fchren Sie mit einem anspruchsvollen Beispielprojekt durch die Welt von Angular...' ), ( 2 , '9783864903274' , 'React' , '2016-06-17' , 'Die praktische Einf\u00fchrung in React, React Router und Redux' , 3 , 2 , 'React ist ein JavaScript-Framework zur Entwicklung von Benutzeroberfl\u00e4chen ...' ), ( 3 , '978-3-86490-578-0' , 'Effective Java' , '2018-09-01' , 'Best Practices f\u00fcr die Java-Plattform' , 3 , 3 , 'Seit der Vorauflage von Effective Java hat sich Java dramatisch ver\u00e4ndert...' ); -- -------------------------------------------------------- -- -- Table structure for table `thumbnail` -- CREATE TABLE `thumbnail` ( `id` int ( 11 ) NOT NULL , `url` varchar ( 255 ) NOT NULL , `title` varchar ( 255 ) NOT NULL ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ; -- -- Dumping data for table `thumbnail` -- INSERT INTO `thumbnail` (`id`, `url`, `title`) VALUES ( 1 , 'https://ng-buch.de/cover2.jpg' , 'Buchcover' ), ( 2 , 'https://ng-buch.de/cover1.jpg' , 'Buchcover' ), ( 3 , 'https://www.dpunkt.de/common/images/cover_masterid/300/13216.jpg' , 'Buchcover' ); -- -- Indexes for dumped tables -- -- -- Indexes for table `author` -- ALTER TABLE `author` ADD PRIMARY KEY ( `author_id` ), ADD KEY `author_id` ( `author_id` ); -- -- Indexes for table `author_book` -- ALTER TABLE `author_book` ADD PRIMARY KEY ( `id` ), ADD UNIQUE KEY `id` ( `book_id` , `author_id` ), ADD KEY `author_id` ( `author_id` ); -- -- Indexes for table `books` -- ALTER TABLE `books` ADD PRIMARY KEY ( `book_id` ), ADD KEY `book_id` ( `book_id` ), ADD KEY `thumbnails` ( `thumbnails` ); -- -- Indexes for table `thumbnail` -- ALTER TABLE `thumbnail` ADD PRIMARY KEY ( `id` ); -- -- AUTO_INCREMENT for dumped tables -- -- -- AUTO_INCREMENT for table `author` -- ALTER TABLE `author` MODIFY `author_id` int ( 11 ) NOT NULL AUTO_INCREMENT , AUTO_INCREMENT = 7 ; -- -- AUTO_INCREMENT for table `author_book` -- ALTER TABLE `author_book` MODIFY `id` int ( 11 ) NOT NULL AUTO_INCREMENT , AUTO_INCREMENT = 7 ; -- -- AUTO_INCREMENT for table `books` -- ALTER TABLE `books` MODIFY `book_id` int ( 11 ) NOT NULL AUTO_INCREMENT , AUTO_INCREMENT = 12 ; -- -- AUTO_INCREMENT for table `thumbnail` -- ALTER TABLE `thumbnail` MODIFY `id` int ( 11 ) NOT NULL AUTO_INCREMENT , AUTO_INCREMENT = 4 ; -- -- Constraints for dumped tables -- -- -- Constraints for table `author_book` -- ALTER TABLE `author_book` ADD CONSTRAINT `author_book_ibfk_1` FOREIGN KEY ( `author_id` ) REFERENCES `author` ( `author_id` ), ADD CONSTRAINT `author_book_ibfk_2` FOREIGN KEY ( `book_id` ) REFERENCES `books` ( `book_id` ); -- -- Constraints for table `books` -- ALTER TABLE `books` ADD CONSTRAINT `books_ibfk_1` FOREIGN KEY ( `thumbnails` ) REFERENCES `thumbnail` ( `id` ); COMMIT ; /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */ ; /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */ ; /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */ ;","title":"Datenbank erstellen"},{"location":"books-backend/#nodejs-projekt-erstellen","text":"Ordner books-backend erstellen. In diesen Ordner wechseln. Im Ordner npm init ausf\u00fchren (es entsteht eine package.json ). mkdir books-backend cd books-backend npm init Alle Fragen mit einem Enter beantworten (oder etwas eingeben, wenn Sie m\u00f6chten). Jetzt noch die Packages express und mysql installieren. npm install express npm install mysql Im Ordner books-backend eine index.js erzeugen: books-backend/index.js const express = require ( 'express' ); const app = express (); app . listen ( 8081 , () => { console . log ( 'Server is listening to http://localhost:8081' ); }); Im Ordner books-backend einen Ordner books erzeugen. Darin eine index.js (f\u00fcr den Router), eine model.js (f\u00fcr die Datenbankanbindung) und eine controller.js (f\u00fcr die Aktionsverwaltung) erstellen. Einen Endpunkt ( localhost/books/authors ) erstellen, um alle Authoren aus der Datenbank auszulesen (mit GET ). /books/model.js const mysql = require ( 'mysql' ); const connection = mysql . createConnection ({ host : 'localhost' , user : 'root' , password : 'password' , database : 'books-db' , }); connection . connect (); function getAllAuthors () { return new Promise (( resolve , reject ) => { const query = 'SELECT * FROM author' ; connection . query ( query , ( error , results ) => { if ( error ) reject ( error ); else resolve ( results ); }) }); } module . exports = { getAllAuthors , }; /books/controller.js const model = require ( './model' ); function readAuthors ( request , response ) { model . getAllAuthors (). then ( authors => response . json ( authors ), error => response . json ( error ), ); } module . exports = { readAuthors , } /books/index.js const express = require ( 'express' ); const router = express . Router (); const { readAuthors } = require ( './controller' ); router . get ( '/authors' , readAuthors ); module . exports = router ; Zum Testen in Postman: http://localhost:8081/books/authors eingeben und GET -Methode w\u00e4hlen. Es erscheint das JSON mit allen Autoren: Response-Body [ { \"author_id\" : 1 , \"lastname\" : \"Malcher\" , \"firstname\" : \"Ferdinand\" }, { \"author_id\" : 2 , \"lastname\" : \"Hoppe\" , \"firstname\" : \"Johannes\" }, { \"author_id\" : 3 , \"lastname\" : \"Kopenhagen\" , \"firstname\" : \"Danny\" }, { \"author_id\" : 4 , \"lastname\" : \"Zeigermann\" , \"firstname\" : \"Oliver\" }, { \"author_id\" : 5 , \"lastname\" : \"Hartmann\" , \"firstname\" : \"Nils\" }, { \"author_id\" : 6 , \"lastname\" : \"Bloch\" , \"firstname\" : \"Joshua\" } ]","title":"Node.js-Projekt erstellen"},{"location":"books-backend/#get-einen-autor-auslesen","text":"Neu hinzugekommener Code highlighted: /books/model.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 const mysql = require ( 'mysql' ); const connection = mysql . createConnection ({ host : 'localhost' , user : 'root' , password : 'password' , database : 'books-db' , }); connection . connect (); function getAllAuthors () { return new Promise (( resolve , reject ) => { const query = 'SELECT * FROM author' ; connection . query ( query , ( error , results ) => { if ( error ) reject ( error ); else resolve ( results ); }) }); } function getOneAuthor ( id ) { return new Promise (( resolve , reject ) => { const query = 'SELECT * FROM author WHERE author_id=?' ; connection . query ( query , [ id ], ( error , results ) => { if ( error ) reject ( error ); else resolve ( results [ 0 ]); }); }); } module . exports = { getAllAuthors , getAuthor ( id ) { return getOneAuthor ( id ) }, }; /books/controller.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const model = require ( './model' ); function readAuthors ( request , response ) { model . getAllAuthors (). then ( authors => response . json ( authors ), error => response . json ( error ), ); } function readAuthor ( request , response ) { model . getAuthor ( request . params . id ). then ( author => response . json ( author ), error => response . status ( 500 ). json ( error ), ); } module . exports = { readAuthors , readAuthor , } /books/index.js 1 2 3 4 5 6 7 8 const express = require ( 'express' ); const router = express . Router (); const { readAuthors , readAuthor } = require ( './controller' ); router . get ( '/authors' , readAuthors ); router . get ( '/author/:id' , readAuthor ); module . exports = router ; Zum Testen in Postman z.B. http://localhost:8081/books/author/4 (Autor mit der author_id 4) und GET aufrufen.","title":"GET - einen Autor auslesen"},{"location":"books-backend/#post-einen-neuen-autoren-anlegen-und-put-einen-autoren-andern","text":"Ein neuer Autor bzw. die \u00c4nderungen werden als JSON dem Request-Body \u00fcbergeben. Dazu wird das Paket body-parser ben\u00f6tigt. npm install body-parser","title":"POST - einen neuen Autoren anlegen und PUT - einen Autoren \u00e4ndern"},{"location":"books/","text":"B\u00fccher-App \u00b6 Das folgende Beispiel ist dem Buch Ferdinand Malcher, Johannes Hoppe, Danny Koppenhagen: \"Angular: Grundlagen, fortgeschrittene Themen und Best Practices\" dpunkt.verlag, 2. Auflage, ISBN: 978-3-86490-646-6, 2019 Link entnommen (und nur unwesentlich ge\u00e4ndert). In der App soll eine Liste von B\u00fcchern angezeigt werden, f\u00fcr jedes einzelne Buch soll eine Detailansicht existieren und B\u00fccher k\u00f6nnen hinzugef\u00fcgt werden. Projekt anlegen \u00b6 Wir gehen wie in beschrieben vor. Wir wollen unsere App book-app nennen. ng new book-app Wir werden gefragt, ob wir Routing verwenden m\u00f6chten (Antwort: y ) und welches StyleSheet-Format wir verwenden (Antwort: CSS ): ? Would you like to add Angular routing? Yes ? Which stylesheet format would you like to use? CSS Nachdem das Projekt erstellt wurde, wechseln wir im Terminal in das Verzeichnis book-app cd book-app und rufen darin npm install auf, um alle in package.json definierten Abh\u00e4ngigkeiten und Module einzubinden. Danach kann die Anwendung durch Eingabe von ng serve gestartet werden. \u00d6ffnen Sie den Browser und geben Sie als URL http://localhost:4200/ ein. Es erscheint die Angular-Projekt-Startseite (siehe auch Erstes Angular-Projekt erstellen ). \u00d6ffnen Sie nun noch in Ihrer IDE (z.B. IntelliJ IDEA ) das Projekt book-app , um Ihre Implementierungen durchzuf\u00fchren. Zun\u00e4chst k\u00fcmmern wir uns allerdings erst noch um das Aussehen des Projektes - um moderne, einheitliche Styles. CSS-Framework Semantic UI einbinden \u00b6 Es ist \u00fcblich, eines der bekannten Style-Frameworks (z.B. Bootstrap oder Material Design ) einzubinden. F\u00fcr die B\u00fccher-App soll daf\u00fcr Semantic UI verwendet werden. Geben Sie dazu im Terminal in dem book-app -Verzeichnis npm install semantic-ui-css ein. Durch diese Anweisung werden die ben\u00f6tigten Style-Dateien geladen und unter dem Ordner node_modules/semantic-ui-css gespeichert. Diese m\u00fcssen jetzt nur noch in das Projekt eingebunden werden. \u00d6ffnen Sie dazu in Ihrer IDE die Datei angular.json . Bei dieser Datei handelt es sich um eine JSON -Datei, die f\u00fcr die Konfiguration unserer Angular-Anwendung zust\u00e4ndig ist. In der angular.json -Datei \u00e4ndern wir unter \"projects\"\u2192\"book-app\"\u2192\"architect\"\u2192\"build\"\u2192\"options\"\u2192\"styles\" den Eintrag von \"styles\" : [ \"src/styles.css\" ] , auf \"styles\" : [ \"node_modules/semantic-ui-css/semantic.css\" ] , Die gleiche \u00c4nderung f\u00fchren wir in angular.json unter \"test\" (statt \"build\" ) durch, um die Styles auch beim Testen einzubeziehen. Also unter \"projects\"\u2192\"book-app\"\u2192\"architect\"\u2192\"test\"\u2192\"options\"\u2192\"styles\" ebenfalls nach \"styles\" : [ \"node_modules/semantic-ui-css/semantic.css\" ] , \u00e4ndern. Um zu testen, ob das Einbinden der Semantic-UI-Styles geklappt hat, \u00f6ffnen wir in der IDE die Datei app.component.html und l\u00f6schen darin alles bis auf <router-outlet></router-outlet> . Stattdessen geben wir davor ein (Listing zeigt auch <router-outlet></router-outlet> - also die dann vollst\u00e4ndige Datei app.component.html ): < div class = \"ui active inverted dimmer\" > < div class = \"ui text loader large\" > Lade B\u00fccher ... </ div > </ div > < router-outlet ></ router-outlet > Wir gestalten also das Template unserer App-Komponente als ein div im div . Beiden div s werden CSS-Klassen aus dem Semantic-UI-Framework zugeordnet (siehe z.B. Klasse loader ). Unsere Webseite sollte nun so aussehen: Success Der erste Teil unserer B\u00fccher-App ist erstellt! Wir haben eine Anwendung erstellt und diese aufgerufen. Wir haben ein CSS-Framework eingebunden und erste \u00c4nderungen am HTML-Code vorgenommen. Unter http://localhost:4200/ ist unsere Anwendung nun im Browser sichtbar und alle unseren zuk\u00fcnftigen \u00c4nderungen am Code werden automatisch (ohne erneuten Aufruf) der Seite dargestellt. Datenmodell und Daten \u00b6 Wir wollen Details (Daten) \u00fcber B\u00fccher speichern und verwenden dazu die JavaScript Object Notation (JSON) . Zun\u00e4chst wird Angular jedoch das dazugeh\u00f6rige Datenmodell bekannt gemacht. Dies geschieht mithilfe eines Interfaces . Wir erstellen ein solches Interface mithilfe der Angular CLI im Terminal (Sie sind im book-app -Verzeichnis): ng g interface shared/book Die obige Anweisung erstellt eine Datei book.ts im Ordner src/app/shared . Der shared - Ordner wird automatisch angelegt. In der obigen Anweisung steht g f\u00fcr generate ( h\u00e4tte man auch schreiben k\u00f6nnen ). In der IDE \u00f6ffnen wir die Datei book.ts . Sie enth\u00e4lt nur die Interface-Deklaration ohne Inhalt: export interface Book { } Wir implementieren das Interface wie folgt: export interface Book { isbn : string ; title : string ; authors : string []; published : Date ; subtitle ?: string ; rating ?: number ; thumbnails ?: Thumbnail []; description ?: string ; } export interface Thumbnail { url : string ; title ?: string ; } Das bedeutet, dass unser Datenmodell so aussieht, dass die Details \u00fcber ein Buch folgende Daten beinhalten: isbn , title , authors , published , subtitle , rating , thumbnails , description . Die Fragezeichen hinter den Bezeichnern geben an, dass die jeweilige Eigenschaft optional ist, d.h. dass ihr kein Wert zugeordnet werden muss. Die Eigenschaft thumbnail ist vom Typ Thumbnail -Array. Dieser Typ ist kein Standard-TypeScript-Typ, sondern von uns definiert. Thumbnail definieren wir ebenfalls als Interface, bestehend aus 2 Eigenschaften url und (optional) title . Die Definition dieses Interfaces erfolgt ebenfalls direkt in book.ts . Wir haben also 2 Interfaces diefiniert: Book und Thumbnail . Die Daten werden zun\u00e4chst direkt in eine neu zu erstellende Komponente zum Anzeigen der B\u00fccher-Liste eingebunden: B\u00fccherliste erstellen \u00b6 Zur Anzeige aller gespeicherten B\u00fccher erstellen wir eine neue Komponente book-list . Siehe dazu auch Angular \u2192 Eine neue Komponente erzeugen : ng generate component book-list Es ensteht ein neuer Ordner src/app/book-list , welcher die 4 Dateien: book-list.component.css book-list.component.html book-list.component.spec.ts book-list.component.ts enth\u00e4lt. In der IDE \u00f6ffnen wir zun\u00e4chst die book-list.component.html . Sie sieht so aus: < p > book-list works! </ p > Wir ersetzen den Inhalt vollst\u00e4ndig durch den folgenden HTML-Code: < div class = \"ui middle aligned selection divided list\" > < a * ngFor = \"let book of books\" class = \"item\" > < img class = \"ui tiny image\" * ngIf = \"book.thumbnails && book.thumbnails[0] && book.thumbnails[0].url\" [ src ]=\" book . thumbnails [ 0 ]. url \" /> < div class = \"content\" > < div class = \"header\" > {{ book.title }} </ div > < div * ngIf = \"book.subtitle\" class = \"description\" > {{ book.subtitle }} </ div > < div class = \"metadata\" > < span * ngFor = \"let author of book.authors; last as l\" > {{ author }} < span * ngIf = \"!l\" > , </ span > </ span > < br /> ISBN {{ book.isbn }} </ div > </ div > </ a > </ div > Obiger Code enth\u00e4lt einige Strukturdirektiven (siehe Angular \u2192 *Strukturdirektiven )). So l\u00e4uft bspw. die *ngFor -Direktive in der zweiten Zeile durch die Liste books und erzeugt f\u00fcr jedes Buch aus der Liste books einen Hyperlink <a> . Diese existiert jedoch noch gar nicht, so dass unsere App sich derzeit nicht ausf\u00fchren l\u00e4sst. Die erste *ngIf -Direktive in der vierten Zeile pr\u00fcft zun\u00e4chst, ob das Array book.thumbnails \u00fcberhaupt existiert und wenn ja, ob dieses Array einen ersten Eintrag hat book.thumbnails[0] und wenn das der Fall ist, ob dieser erste Eintrag auch eine url enth\u00e4lt (siehe Interfaces Book und Thumbnail ). Wenn diese url existiert, wird durch ein Property-Binding (siehe Angular \u2192 [Property Binding] ) dem src -Attribut von <a> der Wert zugeordnet, der unter book.thumbnails[0].url im JSON gespeichert ist. Die Liste der Autoren eines Buches wird ebenfalls mithilfe der Strukturdirektive *ngFor durchlaufen. Au\u00dferdem findet die Hilfsvariable last dieser Strukturdirektive Anwendung (siehe Angular \u2192 *Strukturdirektiven )). Alle Autoren werden durch Komma getrennt. Nur nach dem letzten Autor wird kein Komma hinzugef\u00fcgt. Dies gelingt mithilfe der Strukturdirektive *ngIf und der Abfrage, ob es sich nicht um das letzte Element handelt - dann Komma. Wir ben\u00f6tigen jetzt f\u00fcr unsere Komponente noch die Liste der B\u00fccher - ein Book -Array. Dieses legen wir in der Datei book-list.component.ts an. Wir \u00f6ffnen diese Datei - sie sieht wie folgt aus: import { Component , OnInit } from '@angular/core' ; @ Component ({ selector : 'app-book-list' , templateUrl : './book-list.component.html' , styleUrls : [ './book-list.component.css' ] }) export class BookListComponent implements OnInit { constructor () { } ngOnInit () : void { } } Die (TypeScript-)Klasse BookListComponent enth\u00e4lt zwei Methoden: den Konstruktor constructor() { } ngOnInit(): void { } ngOnInit() ist eine Methode aus dem Interface OnInit . Dabei handelt es sich um einen sogenannten Lifecycle-Hook (siehe Angular \u2192 Lifecycle-Hooks ). Die Methode ngOnInit() wird immer dann (automatisch) ausgef\u00fchrt, wenn die Komponente geladen wird. Wir ersetzen den bisherigen Code der Datei book-list.component.ts durch: import { Component , OnInit } from '@angular/core' ; import { Book } from '../shared/book' ; @ Component ({ selector : 'app-book-list' , templateUrl : './book-list.component.html' , styleUrls : [ './book-list.component.css' ] }) export class BookListComponent implements OnInit { books : Book []; constructor () { } ngOnInit () : void { this . books = [ { isbn : '9783864906466' , title : 'Angular' , authors : [ 'Ferdinand Malcher' , 'Johannes Hoppe' , 'Danny Kopenhagen' ], published : new Date ( 2019 , 4 , 30 ), subtitle : 'Grundlagen, fortgeschrittene Techniken und Best Practices - mit NativeScript und NgRx' , rating : 5 , thumbnails : [{ url : 'https://ng-buch.de/cover2.jpg' , title : 'Buchcover' }], description : 'Die Autoren f\u00fchren Sie mit einem anspruchsvollen Beispielprojekt durch die Welt von Angular...' , }, { isbn : '9783864903274' , title : 'React' , authors : [ 'Oliver Zeigermann' , 'Nils Hartmann' ], published : new Date ( 2016 , 6 , 17 ), subtitle : 'Die praktische Einf\u00fchrung in React, React Router und Redux' , rating : 3 , thumbnails : [{ url : 'https://ng-buch.de/cover1.jpg' , title : 'Buchcover' }], description : 'React ist ein JavaScript-Framework zur Entwicklung von Benutzeroberfl\u00e4chen ...' , }, { isbn : '978-3-86490-578-0' , title : 'Effective Java' , authors : [ 'Joshua Bloch' ], published : new Date ( 2018 , 9 , 1 ), subtitle : 'Best Practices f\u00fcr die Java-Plattform' , rating : 3 , thumbnails : [{ url : 'https://www.dpunkt.de/common/images/cover_masterid/300/13216.jpg' , title : 'Buchcover' }], description : 'Seit der Vorauflage von \\\"Effective Java\\\" hat sich Java dramatisch ver\u00e4ndert...' , } ]; } } Somit existiert die Eigenschaft books f\u00fcr die Komponente nun (siehe books: Book[] ). Auf diese Eigenschaft kann innerhalb der Klasse mit this.books zugegriffen werden. Dies passiert auch in der ngOnInit() -Methode. Dort wird das Array mit Daten bef\u00fcllt (mit zun\u00e4chst 3 B\u00fcchern). Die Syntax entspricht der JavaScript Object Notation (JSON) . Damit unsere Komponente \u00fcberhaupt sichtbar ist, binden wir sie noch in unsere Root-Komponente ein. Der Selektor unserer book-list -Komponente ist app-book-list . Wir binden diesen Selektor als HTML-Element in app.component.html ein. app.component.html (alt) < div class = \"ui active inverted dimmer\" > < div class = \"ui text loader large\" > Lade B\u00fccher ... </ div > </ div > < router-outlet ></ router-outlet > app.component.html (neu) < app-book-list ></ app-book-list > < router-outlet ></ router-outlet > Die App ist nun ausf\u00fchrbar. Im Browser erscheint folgende Darstellung: Success Der zeite Teil unserer B\u00fccher-App ist erstellt! Wir haben zwei Interfaces ( Book und Thumbnail ) und eine neue Komponente ( book-list ) erstellt. Wir haben Direktiven verwendet ( *ngFor und *ngIf ), um durch Daten zu man\u00f6vrieren und diese entsprechend darszustellen. Wir haben Daten im JSON-Format gespeichert. Datenfluss zwischen Komponenten \u00b6 In diesem Abschnitt wird der Datenfluss von Eltern- auf Kindkomponenten und von Kind- auf Elternkomponenten betrachtet. Letzteres erreicht man \u00fcber event binding (siehe Angular\u2192Event Binding ). Wir betrachten zun\u00e4chst den Datenfluss von Eltern- auf Kindkomponenten. Das grundlegende Prinzip dabei ist das property binding (siehe dazu Angular \u2192 [Property Bindings] ). Datenfluss von Eltern- auf Kindkomponenten \u00b6 Wir legen uns dazu zun\u00e4chst eine weitere Komponente in unserer B\u00fccher-App an - die Komponente book-list-item . Sie ist daf\u00fcr zust\u00e4ndig, die Informationen \u00fcber ein einzelnes Buch im Detail anzuzeigen. Wir werden zu dieser Detailansicht gelangen, indem wir ausgehend von der Liste der B\u00fccher auf ein einzelnes Buch klicken - dieses wird dann im Detail angezeigt. Wechseln Sie im Terminal in den Ordner Ihrer B\u00fccher-App book-app und geben dort zum Erzeugen der neuen Komponente ein: ng g c book-list-item Im Ordner book-app/src/app entsteht eine neue Komponente (ein neuer Ordner) book-list-item mit den Dateien book-list-item.component.ts , book-list-item.component.html , book-list-item.component.css und book-list-item.component.spec.ts . Wir kopieren zun\u00e4chst den Teil aus der book-list.component.html in die book-list-item.component.html , der die Details eines Buches anzeigt. Im folgenden Tab sind jeweils die *.component.html gemeint. book-list (alt) < div class = \"ui middle aligned selection divided list\" > < a * ngFor = \"let book of books\" class = \"item\" > < img class = \"ui tiny image\" * ngIf = \"book.thumbnails && book.thumbnails[0] && book.thumbnails[0].url\" [ src ]=\" book . thumbnails [ 0 ]. url \" /> < div class = \"content\" > < div class = \"header\" > {{ book.title }} </ div > < div * ngIf = \"book.subtitle\" class = \"description\" > {{ book.subtitle }} </ div > < div class = \"metadata\" > < span * ngFor = \"let author of book.authors; last as l\" > {{ author }} < span * ngIf = \"!l\" > , </ span > </ span > < br /> ISBN {{ book.isbn }} </ div > </ div > </ a > </ div > book-list-item < img class = \"ui tiny image\" * ngIf = \"book.thumbnails && book.thumbnails[0] && book.thumbnails[0].url\" [ src ]=\" book . thumbnails [ 0 ]. url \" /> < div class = \"content\" > < div class = \"header\" > {{ book.title }} </ div > < div * ngIf = \"book.subtitle\" class = \"description\" > {{ book.subtitle }} </ div > < div class = \"metadata\" > < span * ngFor = \"let author of book.authors; last as l\" > {{ author }} < span * ngIf = \"!l\" > , </ span > </ span > < br /> ISBN {{ book.isbn }} </ div > </ div > book-list (neu - zun\u00e4chst) < div class = \"ui middle aligned selection divided list\" > < a * ngFor = \"let book of books\" class = \"item\" > <!-- dieses Anchorelement (Hyperlink <a>) wird gleich ge\u00e4ndert aber die Direktive *ngFor bleibt --> </ a > </ div > Nachdem wir den oben gelb unterlegten Teil nach book-list-item.component.html geschoben haben, f\u00e4llt auf, dass die Variable book in der Komponente book-list-item (noch) unbekannt ist. Dies wird nun ge\u00e4ndert. Zun\u00e4chst \u00e4ndern das HTML-Element, das uns die Details eines Buches anzeigen soll von <a> nach <app-book-list-item> - das ist der Selektor unserer neuen Komponente. book-list.component.html 1 2 3 4 5 6 < div class = \"ui middle aligned selection divided list\" > < app-book-list-item class = \"item\" * ngFor = \"let b of books\" [ book ]=\" b \" > </ app-book-list-item > </ div > In Zeile 2 erkennt man die Verwendung des Selektors app-book-list-item , hier erfolgt der \"Aufruf\" unserer neuen Komponente. In Zeile 3 wird die bereits bekannte Direktive *ngFor angewendet (siehe Angular\u2192*Strukturdirektiven ), mit der wir durch unser Array von B\u00fcchern ( Book[] ) laufen. In Zeile 4 findet nun das property binding statt (siehe Angular \u2192 [Property Bindings] )). Der Eigenschaft book wird jeweils der Wert der Variable b \u00fcbergeben. Das bedeutet, dass wir in der Elternkomponente book-list die Kindkomponente book-list-item aufrufen und in der Elternkomponente einer Eigenschaft der Kindkomponente book einen Wert zuweisen. Es erfolgt also ein Datenfluss von der Elternkoponente zur Kindkomponente unter Verwendung von property binding . Es fehlt nur noch zwei Sachen: die Eigenschaft book (vom Typ Book ) muss noch als Eigenschaft (Objektvariable) der Komponente book-list-tem deklariert werden. es muss mithilfe des Decorators @Input() aggeben werden, dass die Werte (Daten) f\u00fcr diese Eigenschaft \"in die Komponente hineinflie\u00dfen\". Beides erreichen wir durch \u00c4nderungen der Datei book-list-item.component.ts wie folgt: book-list-item.component.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { Component , Input , OnInit } from '@angular/core' ; import { Book } from '../shared/book' ; @ Component ({ selector : 'app-book-list-item' , templateUrl : './book-list-item.component.html' , styleUrls : [ './book-list-item.component.css' ] }) export class BookListItemComponent implements OnInit { @ Input () book : Book ; constructor () { } ngOnInit () : void { } } Wesentlich ist die Zeile 10. Dort sehen Sie die Deklaration der Eigenschaft book: Book und die Verwendung der Directive @Input() . Sowohl das Interface Book als auch die Directive @Input m\u00fcssen noch eingebunden werden (Zeilen 1 und 2). Lassen Sie dies am besten Ihre IDE erledigen. Gehen Sie mit der Maus \u00fcber die rot dargestellten Bezeichner ( Book und @Input() ) und w\u00e4hlen Sie jeweils den automatischen Korrekturvorschlag aus. Success Der dritte Teil unserer B\u00fccher-App ist erstellt! Leider hat sich in der Ansicht nichts ge\u00e4ndert. Zwar wissen wir jetzt, wie der Datenfluss von Eltern- auf Kindkomponenten erfolgt (n\u00e4mlich mit property binding und der Deklaration der Eigenschaft (property) mithilfe des @Input() -Decorators). Aber der Wechsel der Ansicht ist noch nicht realisiert. Dieser soll durch ein Ereignis ausgel\u00f6st werden, n\u00e4mlich wenn wir auf eines der B\u00fccher aus der Liste klicken. Die Behandlung von Ereignissen ( event binding ) ist Thema des n\u00e4chsten Abschnittes. Datenfluss von Kind- auf Elternkomponenten \u00b6 Der Datenfluss von Kind- auf Elternkomponenten kann mithilfe von event binding organisiert werden (siehe dazu Angular\u2192Eigene Ereignisse ). Wir werden eine BookDetailsComponent erzeugen. Diese zeigt die Details eines Buches. In unserer BookListComponent definieren wir ein Ereignis, das diese Detail-Ansicht aufruft und dabei das entsprechende Buch \u00fcbergibt. In der BookDetailsComponent definieren wir ein Ereignis, das die Listendarstellung aller B\u00fccher wieder aufruft. Wir erzeugen zun\u00e4chst die BookDetailsComponent : ng g c book-details Wir planen folgende Kommunikation zwischen den Komponenten (Abbildung ebenfalls aus eingangs erw\u00e4hntem Buch ): Wir erweitern zun\u00e4chst die Komponente AppComponent um zwei weitere Eigenschaften: book vom Typ Book (die Daten eines Buches sollen ja an die Komponente BookDetailsComponent mithilfe von property binding weitergegeben werden) und einen viewState , der zwischen den beiden Ansichten BookList und BookDetails umschalten soll. Dazu vereinbaren wir einen neuen Typ ViewState , der 2 verschiedene Werte annehmen kann list und details . Die neue app.component.ts sieht dann so aus: app.component.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import { Component } from '@angular/core' ; import { Book } from './shared/book' ; type ViewState = 'list' | 'details' ; @ Component ({ selector : 'app-root' , templateUrl : './app.component.html' , styleUrls : [ './app.component.css' ] }) export class AppComponent { book : Book ; viewState : ViewState = 'list' ; showList () { this . viewState = 'list' ; } showDetails ( book : Book ) { this . book = book ; this . viewState = 'details' ; } } Neben den beiden Eigenschaften book und viewState ( viewState ist vom Typ ViewState - dieser wurde in Zeile 5 erstellt) wurde auch zwei Methoden hinzugef\u00fcgt: showList() und showDetails(book: Book) . showList() wird von der Kindkomponente BookDetailsComponent als Ereignis aufgerufen ( event binding ). showDetails() wird von der Kindkomponente BookListComponent als Ereignis aufgerufen und liefert als payload des Ereignisses die Informationen \u00fcber das Buch mit, auf das innerhalb der Liste geklickt wurde (siehe auch Angular\u2192Eigene Ereignisse ). Die beiden Methoden schalten jeweils zwischen den viewState s um. Im Template der AppComponent wird mittels der *ngIf -Direktive zwischen den Ansichten der beiden Komponenten BookDetailsComponent und BookListeComponent umgeschaltet, je nachdem, welcher Wert viewState aufweist: app.component.html 1 2 3 4 5 6 7 8 9 10 < app-book-list * ngIf = \"viewState === 'list'\" ( showDetailsEvent )=\" showDetails ($ event )\" ></ app-book-list > < app-book-details * ngIf = \"viewState === 'details'\" ( showListEvent )=\" showList ()\" [ book ]=\" book \" ></ app-book-details > < router-outlet ></ router-outlet > Die beiden Events showDetailsEvent und showListEvent der beiden Komponenten BookListComponent bzw. BookDetailsComponent sind noch nicht in den jeweiligen Komponenten angelegt, ebenso noch nicht die Eigenschaft book in der BookDetailsComponent . Das machen wir jetzt in beginnen mit der BookListComponent . In der BookListComponent soll ein eigenes Event ( showDetailsEvent ) definiert werden. Wir gehen dazu vor, wie in Angular\u2192Eigene Ereignisse beschrieben. Wichtig ist, dass wir einen payload des Events \u00fcbergeben, n\u00e4mlich das jeweilige Buch auf das geklickt wurde. Dieser payload wird in der Methode showDetails($event) der AppComponent verarbeitet. Wir \u00f6ffnen die book-list.component.ts und f\u00fcgen hinzu : Caution Achten Sie darauf, dass Sie nur den Teil hinzuf\u00fcgen, der noch nicht in Ihrer book-list.component.ts enthalten ist. Diese Datei ist durch das JSON schon recht lang. Es kommen nur die Zeilen 8 und 14-16 hinzu und in der ersten Zeile werden EventEmitter und Output aus @angular/core importiert! book-list.component.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { Component , EventEmitter , OnInit , Output } from '@angular/core' ; import { Book } from '../shared/book' ; @ Component ({ /* bleibt wie es ist */ }) export class BookListComponent implements OnInit { books : Book []; @ Output () showDetailsEvent = new EventEmitter < Book > (); constructor () { } ngOnInit () : void { /* bleibt wie es ist */ } showDetails ( book : Book ) { this . showDetailsEvent . emit ( book ); } } Im Template der BookListComponent kommt nur ein event binding hinzu. Wir binden das native DOM-Ereignis click an die Ereignisbehandlung showDetails() und \u00fcbergeben dabei als payload das entsprechende Buch b . Das bedeutet, dass jetzt jedes einzelne BookItem (es gibt f\u00fcr jedes Buch eine eigens BookItem - siehe *ngFor ) ein Click-Ereignis existiert. Klicken wir also auf einen Eintrag in unserer BookList , dann wird das showDetails() -Ereignis ausgel\u00f6st, das entsprechende Buch als payload \u00fcbergeben und an die AppComponent weitergereicht, die dann auf die BookDetails -Ansicht umschaltet. Die um diese eine Zeile (Zeile 5) erweiterte book-list.component.html sieht nun so: book-list.component.html 1 2 3 4 5 6 7 < div class = \"ui middle aligned selection divided list\" > < app-book-list-item class = \"item\" * ngFor = \"let b of books\" [ book ]=\" b \" ( click )=\" showDetails ( b )\" > </ app-book-list-item > </ div > Reflexion Wir sehen in dem obigen kleinen Beispiel book-list.component.html sehr sch\u00f6n vier Konzepte: 1. die Komponente BookListComponent ruft die Komponente BookListItemComponent auf. Damit ist BookListComponent eine Elternkomponente der Kindkomponente BookListItemComponent (Zeile 2). 2. der Einsatz der Direktive *ngFor . F\u00fcr jeden einzelnen Eintrag aus dem Array books wird ein neues HTML-Element <app-book-list-item> erzeugt. 3. Ein property binding , bei der der Ausdruck \"b\" and die Eigenschaft book gebunden wird und 4. ein event binding , bei der wir die Ereignisbehandlung showDetails(b) an das native DOM-Element click binden. Jetzt k\u00fcmmern wir uns noch um unsere neue Komponente BookDetailsComponent . Zwei Konzepte kennen wir bereits: definieren wir uns eine Eigenschaft book , deren Wert wir als @Input() von der Elternkomponente AppComponent erhalten (siehe dazu Datenfluss von Eltern- auf Kindkomponenten ). definieren wir uns ein eigenes Ereignis, welches an die Elternkomponente AppComponent weitergereicht wird (siehe dazu book-list.component.ts oben) Es wird noch eine dritte Kleinigkeit eingef\u00fcgt: eine Methode getRating(number) , die f\u00fcr eine gegebene Zahl ein Array der \u00fcbergebenen L\u00e4nge zur\u00fcckgibt. Wir werden im Template sehen, was es damit auf sich hat. Die book-details.component.ts sieht dann wie folgt aus: book-details.component.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { Component , EventEmitter , Input , OnInit , Output } from '@angular/core' ; import { Book } from '../shared/book' ; @ Component ({ selector : 'app-book-details' , templateUrl : './book-details.component.html' , styleUrls : [ './book-details.component.css' ] }) export class BookDetailsComponent implements OnInit { @ Input () book : Book ; @ Output () showListEvent = new EventEmitter < any > (); ngOnInit () { } getRating ( num : number ) { return new Array ( num ); } showBookList () { this . showListEvent . emit (); } } Das zugeh\u00f6rige Template ist recht umfangreich. Wir gehen auf einzelne Details ein, zeigen es aber zun\u00e4chst: book-details.component.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 < div * ngIf = \"book\" > < h1 > {{ book.title }} </ h1 > < h3 * ngIf = \"book.subtitle\" > {{ book.subtitle }} </ h3 > < div class = \"ui divider\" ></ div > < div class = \"ui grid\" > < div class = \"four wide column\" > < h4 > Autoren </ h4 > < ng-container * ngFor = \"let author of book.authors\" > {{ author }} < br > </ ng-container > </ div > < div class = \"four wide column\" > < h4 > ISBN </ h4 > {{ book.isbn }} </ div > < div class = \"four wide column\" > < h4 > Erschienen </ h4 > {{ book.published }} </ div > < div class = \"four wide column\" > < h4 > Rating </ h4 > < i class = \"yellow star icon\" * ngFor = \"let r of getRating(book.rating)\" ></ i > </ div > </ div > < h4 > Beschreibung </ h4 > < p > {{ book.description }} </ p > < div class = \"ui small images\" > < img * ngFor = \"let thumbnail of book.thumbnails\" [ src ]=\" thumbnail . url \" > </ div > < button class = \"ui red button\" ( click )=\" showBookList ()\" > Zur\u00fcck zur Buchliste </ button > </ div > Die Detailansicht sollte dann etwa so aussehen: Success Der vierte Teil unserer B\u00fccher-App ist erstellt! Wir wissen jetzt, wie wir Ereignisse behandeln und sogar eigene Ereignisse erstellen k\u00f6nnen und wie wir mit diesen eigenen Ereignissen und event bining Daten an die Elternklasse \u00fcbergeben k\u00f6nnen. Damit k\u00f6nnen wir jetzt sowohl von Eltern- nach Kindklassen als auch zur\u00fcck Daten transferieren und durch Ereignisse zwischen verschiedenen Komponenten hin- und herwechseln. F\u00fcr viele Komponenten und eine tiefe Verschachtelung ist die Komplexit\u00e4t jedoch mit diesen Konzepten zu hoch. Wir lernen zwei weitere Konzepte kennen, die uns helfen, diese Komplexit\u00e4t zu meistern: Services und Routing . Service BookStoreService \u00b6 Derzeit ist die Liste (genauer: das Array) unserer B\u00fccher statisch als JSON innerhalb der Komponente BookListComponent gespeichert (siehe in ngOnInit() this.books = [ ... ] ). Die BookListComponent verwaltet somit die B\u00fccher und stellt diese auch noch als Liste dar. Wir wollen die Darstellung unabh\u00e4ngig von der \"Datenspeicherung\" gestalten und die Datenverwaltung (Speicherung und Bereitstellung) in einen Service auslagern (siehe Angular\u2192Services ). Um einen Service mithilfe der CLI anzulegen (zu generieren), verwenden wir das Attribut service anstelle von component . Au\u00dferdem ist es guter Stil, Services in den shared -Ordner abzulegen, da ja alle Komponenten einen Service nutzen k\u00f6nnen. Wir erzeugen einen Service BookStoreService : ng g service shared/book-store Nach der Erzeugung sieht der Service zun\u00e4chst so aus: book-store.service.ts import { Injectable } from '@angular/core' ; @ Injectable ({ providedIn : 'root' }) export class BookStoreService { constructor () { } } F\u00fcr Services gibt es keine Lifecycle-Hooks. Wir finden hier deshalb auch keine ngOnInit() -Methode. W\u00e4hrend Komponenten den Decorator @Component() aufweisen, wird f\u00fcr Services der Decorator @Injectable() verwendet. Mit diesem Decorator geben wir an, dass der Service weitere Abh\u00e4ngigkeiten einbinden kann. Dies geschieht typischerweise \u00fcber einen Parameter im Konstruktor - eine soganannte dependency injection (wenn \u00fcber den Konstruktor, dann constructor injection ). Auch wenn wir eine solche Abh\u00e4ngigkeit nicht einbinden, sollte der Decorator @Injectable() stets f\u00fcr einen Service angegeben werden. Dies liegt daran, dass wir diesen Decorator um die providedIn -Eigenschaft erweitern. Mit providedIn: 'root' geben wir an, dass der Service allen Komponenten (im gesamten Root-Modul) zur Verf\u00fcgung steht, er also von allen Komponenten genutzt werden kann. In unseren Service integrieren wir nun folgende Eigenschaften: das Book -Array books aus der BookListComponent und die Methode getAll() , die dieses Array zur\u00fcckgibt, also alle B\u00fccher aus dem Array books . book-store.service.ts import { Injectable } from '@angular/core' ; import { Book } from './book' ; @ Injectable ({ providedIn : 'root' }) export class BookStoreService { books : Book []; constructor () { this . books = [ { isbn : '9783864906466' , /* das gesamte Array aus book-list.component.ts hier her bewegen */ }, } getAll () : Book [] { return this . books ; } } book-list.component.ts import { Component , EventEmitter , OnInit , Output } from '@angular/core' ; import { Book } from '../shared/book' ; @ Component ({ selector : 'app-book-list' , templateUrl : './book-list.component.html' , styleUrls : [ './book-list.component.css' ] }) export class BookListComponent implements OnInit { books : Book []; @ Output () showDetailsEvent = new EventEmitter < Book > (); constructor () { } ngOnInit () : void { } showDetails ( book : Book ) { this . showDetailsEvent . emit ( book ); } } Es wurde also die gesamte Wertebelegung f\u00fcr this.books mit dem JSON von der Datei book-list.component.ts (dort aus ngOnInit() ) nach book-store.service.ts (hier in den Konstruktor constructor() - Liefecycle-hooks gibt es f\u00fcr Services ja nicht) verschoben. Dazu wurde dem Service die Eigenschaft books hinzugef\u00fcgt (Typ Book[] - das Interface Book muss dazu importiert werden). Au\u00dferdem wurde in dem Service die Methode getAll() implementiert. Nun kann der Service in der BookListComponent verwendet werden. Dazu werden der BookService importiert, der BookService mittels dependency injection ( constructor injection ) in die Komponente eingebunden und die Methode getAll() des Services aufgerufen, um die Eigenschaft this.books mit dem Book -Array zu initialisieren. book-list.component.ts import { Component , EventEmitter , OnInit , Output } from '@angular/core' ; import { Book } from '../shared/book' ; import { BookStoreService } from '../shared/book-store.service' ; @ Component ({ selector : 'app-book-list' , templateUrl : './book-list.component.html' , styleUrls : [ './book-list.component.css' ] }) export class BookListComponent implements OnInit { books : Book []; @ Output () showDetailsEvent = new EventEmitter < Book > (); constructor ( private bs : BookStoreService ) { } ngOnInit () : void { this . books = this . bs . getAll (); } showDetails ( book : Book ) { this . showDetailsEvent . emit ( book ); } } Beachten Sie, dass die dependency injection des Services dazu f\u00fchrt, dass bs eine Eigenschaft der BookListComponent ist, ohne dass diese Eigenschaft explizit deklariert wird. In ngOnInit() wird \u00fcber this.bs auf den Service zugegriffen. Die Anwendung sieht zwar genauso aus wie vorher, aber wir haben die BookListComponent davon entlastet, das B\u00fccher-Array speichern zu m\u00fcssen. Diesen Dienst haben wir in einen Service augelagert, der au\u00dferdem noch die Methode getAll() zur Verf\u00fcgung stellt, mit dem das gesamte B\u00fccher-Array zur\u00fcckgegeben wird. Success Der f\u00fcnfte Teil unserer B\u00fccher-App ist erstellt! Die Anwendung sieht zwar genauso aus wie vorher, aber wir haben die BookListComponent davon entlastet, das B\u00fccher-Array speichern zu m\u00fcssen. Diesen Dienst haben wir in einen Service augelagert, der au\u00dferdem noch die Methode getAll() zur Verf\u00fcgung stellt, mit dem das gesamte B\u00fccher-Array zur\u00fcckgegeben wird. Nun wollen wir mithilfe von Routing besser durch unsere Anwendung navigieren. Routing \u00b6 Derzeit hat unsere App zwei Sichten: einerseits die Listenansicht aller B\u00fccher (Template der BookListComponent , wobei jede Zeile der Liste/jedes Buch durch das Template der BookListItemComponent dargestellt wird) und die Detailansicht eines Buches (Template der BookDetailsComponent ). Zwischen diesen Sichten ( views ) wechseln wir durch Nutzereignisse hin- und her. Von der Listenansicht auf die Detailansicht kommen wir durch Anklicken einer Buchzeile und zur\u00fcck kommen wir durch Klicken des Buttons \"Zur\u00fcck zur Buchliste\". Unsere URL bleibt jedoch immer gleich, n\u00e4mlich localhost:4200 . Ein direkter Zugriff auf die Detailansicht eines Buches ist nicht m\u00f6glich, sondern erfolgt immer \u00fcber die Listenansicht. Dies soll im folgenden ge\u00e4ndert werden. Zum Beispiel k\u00f6nnte die Detailansicht des Buches mit der ISBN 9783864906466 mithilfe der URL localhost:4200/books/9783864906466 erfolgen. Eine solche URL h\u00e4tte auch den Vorteil, dass man diese URL an andere versenden k\u00f6nnte, um auf ein konkretes Buch aufmerksam zu machen. Zur Erstellung solcher Pfade wird das Konzept des Routings in Angular verwendet (siehe Angular \u2192 Routing ). Wir erweitern unsere B\u00fccher-App zun\u00e4chst um eine weitere Komponente home . ng g c home Routen konfigurieren \u00b6 In der app-routing.module.ts werden wir 4 Routen konfigurieren: /home zeigt die HomeComponent / wird auf die /home -Route umgeleitet, zeigt also ebenfalls auf die HomeComponent /books zeigt auf die BookListComponent /books/:isbn zeigt auf die BooksDetailsComponent f\u00fcr das entsprechende Buch mit der isbn des Parameterwertes app-routing.module.ts import { NgModule } from '@angular/core' ; import { Routes , RouterModule } from '@angular/router' ; import { HomeComponent } from './home/home.component' ; import { BookDetailsComponent } from './book-details/book-details.component' ; import { BookListComponent } from './book-list/book-list.component' ; const routes : Routes = [ { path : '' , redirectTo : 'home' , pathMatch : 'full' }, { path : 'home' , component : HomeComponent }, { path : 'books' , component : BookListComponent }, { path : 'books/:isbn' , component : BookDetailsComponent }, ]; @ NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { } app.component.html < router-outlet ></ router-outlet > Die app.component.html enth\u00e4lt nun nur noch das <router-outlet></router-outlet> -Element. Wenn wir nun http://localhost:4200 aufrufen, werden wir zu http://localhost:4200/home umgeleitet und es erscheint die View der HomeComponent ( home works! ). Wir k\u00f6nnen aber auch http://localhost:4200/books eingeben und es erscheint die View der BookListComponent , also die gesamte Liste unserer B\u00fccher. Parametrisierte Route auslesen \u00b6 Wenn wir z.B. http://localhost:4200/books/9783864906466 aufrufen, also eine ISBN \u00fcbergeben, bleibt die angezeigte Seite der BookDetailsComponent leer. Das liegt daran, dass die in der URL \u00fcbergebene ISBN noch nicht verwaltet wird, um das entsprechende Buch herauszusuchen und anzuzeigen. Dazu erweitern wir zun\u00e4chst den BookStoreService : Caution Achten Sie darauf, dass Sie nur den Teil hinzuf\u00fcgen, der noch nicht in Ihrer book-store.service.ts enthalten ist. Diese Datei ist durch das JSON schon recht lang. Es kommen nur die Zeilen 18-20 hinzu! shared/book-store.service.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { Injectable } from '@angular/core' ; import { Book } from './book' ; @ Injectable ({ providedIn : 'root' }) export class BookStoreService { books : Book []; constructor () { this . books = [ /* alle Eintr\u00e4ge */ ]; } getAll () : Book [] { return this . books ; } getSingle ( isbn : string ) : Book { return this . books . find ( book => ( book . isbn === isbn )); } } Wir m\u00fcssen nun noch die ISBN auslesen, die in der URL \u00fcbergeben wird. Das Auslesen von Parameterwerten aus URLs ist in Angular \u2192 Parameter an Routen beschrieben. Dazu wird book-details.component.ts wie folgt erweitert : ActivatedRoute wird importiert und dem Konstruktor injiziert, um mithilfe von route.snapshot.paramMap die aktuellen Werte der in der URL \u00fcbergebenen Parameter abzufragen. Der BookStoreService wird importiert und dem Konstruktor injiziert, um auf das Array aller B\u00fccher, insbesondere aber auf die getSingle(isbn: string) -Funktion zuzugreifen, die das Buch mit der \u00fcbergebenen isbn zur\u00fcckgibt. Daf\u00fcr entfallen einige Sachen aus der book-details.component.ts : Wir wechseln die Ansichten nicht mehr durch ein Ereignis, sondern \u00fcberlassen dies dem Router. Deshalb entfernen wir die @Output() -Eigenschaft showListEvent und die Methode showBookList() . Das ausgew\u00e4hlte Buch gelangt nun nicht mehr \u00fcber property binding in das Template, sondern \u00fcber die Eigenschaft this.book (die ihren Wert von der Methode getSingle() des BookStoreService erh\u00e4lt). Wir k\u00f6nnen deshalb auch den @Input() -Decorator von book: Book entfernen. book-details.component.ts (neu) import { Component , OnInit } from '@angular/core' ; import { Book } from '../shared/book' ; @ Component ({ selector : 'app-book-details' , templateUrl : './book-details.component.html' , styleUrls : [ './book-details.component.css' ] }) export class BookDetailsComponent implements OnInit { @ Input () book : Book ; @ Output () showListEvent = new EventEmitter < any > (); ngOnInit () { } getRating ( num : number ) { return new Array ( num ); } showBookList () { this . showListEvent . emit (); } } book-details.component.ts (alt) import { Component , EventEmitter , Input , OnInit , Output } from '@angular/core' ; import { Book } from '../shared/book' ; @ Component ({ selector : 'app-book-details' , templateUrl : './book-details.component.html' , styleUrls : [ './book-details.component.css' ] }) export class BookDetailsComponent implements OnInit { @ Input () book : Book ; @ Output () showListEvent = new EventEmitter < any > (); ngOnInit () { } getRating ( num : number ) { return new Array ( num ); } showBookList () { this . showListEvent . emit (); } } In der book-details.component.html wird der Button entfernt, also der folgende Teil gel\u00f6scht: < button class = \"ui red button\" ( click )=\" showBookList ()\" > Zur\u00fcck zur Buchliste </ button > Success Jetzt wird die Detail-Ansicht eines jeden Buches angezeigt, wenn Sie eine existierende isbn \u00fcbergeben. Also z.B. http://localhost:4200/books/9783864906466 (oder http://localhost:4200/books/9783864903274 oder http://localhost:4200/books/978-3-86490-578-0 ). Bei einer nicht existierenden isbn (z.B. http://localhost:4200/books/123 ) bleibt die Seite leer. Routen verlinken \u00b6 Derzeit m\u00fcssen wir die Routen noch jeweils als URL in den Browser eingeben. Wir wollen uns nun ein Navigationsmen\u00fc erzeugen, in dem wir die jeweiligen Routen als Links hinterlegen und somit \u00fcber Klicks die jeweiligen Komponenten aufrufen. Das prinzipielle Vorgehen ist in Angular \u2192 Routen verlinken beschrieben. Unsere Navigationsleiste f\u00fcgen wir am besten in die AppComponent ein, damit sie immer sichtbar bleibt. app.component.html < div class = \"ui menu\" > < a routerLink = \"home\" class = \"item\" > Home </ a > < a routerLink = \"books\" class = \"item\" > B\u00fccher </ a > </ div > < router-outlet ></ router-outlet > Jetzt binden wir in unserer Listen-Ansicht aller B\u00fccher noch die isbn -Eigenschaft an die routerLink -Property, um ein konkretes Buch mit der entsprechenden isbn auszuw\u00e4hlen. Wir passen dazu die book-list.component.html wie folgt an: book-list.component.html 1 2 3 4 5 6 7 < div class = \"ui middle aligned selection divided list\" > < app-book-list-item class = \"item\" * ngFor = \"let b of books\" [ book ]=\" b \" [ routerLink ]=\" b . isbn \" > </ app-book-list-item > </ div > Das click -Ereignis wird nun also nicht mehr ben\u00f6tigt und behandelt. Stattdessen binden wir mit property binding die isbn als Pfad an die Eigenschaft routerLink . Der Pfad ergibt sich somit aus der aktuellen Komponente ( /books ) und der isbn des Buches, auf das wir klicken. Daraus ergibt sich der Pfad /books/isbn ( isbn wird durch den konkreten String ersetzt). Wir erweitern noch das Template der HomeComponent um einen Button, mit dem wir zur B\u00fccherliste kommen: home.component.html 1 2 3 4 5 6 < h1 > Home </ h1 > < p > Herzlich willkommen zur B\u00fccher-App! </ p > < a routerLink = \"../books\" class = \"ui red button\" > B\u00fccherliste anzeigen < i class = \"right arrow icon\" ></ i > </ a > Der Pfad ../books ist releativ zur HomeComponent , also erst \"raus\" aus /home und dann nach /books . Aktive Links stylen und aufr\u00e4umen \u00b6 Den jeweils aktiven Men\u00fcpunkt werden wir nun noch farbig gestalten, damit wir am Men\u00fc erkennen, wo wir uns in unserer Anwendung gerade befinden. Wir gehen vor wie in Angular \u2192 Styles f\u00fcr aktive Routen beschrieben und nutzen die CSS-Klasse active des Semantic-UI-CSS-Frameworks . Wir f\u00fcgen also zwei Mal routerLinkActive=\"active\" in unsere app.component.html ein: app.component.html 1 2 3 4 5 < div class = \"ui menu\" > < a routerLink = \"home\" routerLinkActive = \"active\" class = \"item\" > Home </ a > < a routerLink = \"books\" routerLinkActive = \"active\" class = \"item\" > B\u00fccher </ a > </ div > < router-outlet ></ router-outlet > In unserer Navigationsleiste ist nun das jeweilige Element grau hinterlegt, je nachdem, wo wir uns befinden. Wir r\u00e4umen in unseren Komponenten noch ein wenig auf: in BookDetailsComponent haben wir bereits showListEvent , showBookList() , @Input() -Decorator und die entsprechenden Importe ( Input , Output und EventEmitter ) gel\u00f6scht in BookListComponent l\u00f6schen wir showDetailsEvent , showDetails() und die entsprechenden Importe ( Output und EventEmitter ) in AppComponent l\u00f6schen wir book , viewState , showList() , showDetails() und den Typ ViewState sowie den Import f\u00fcr Book book-details.component.ts import { Component , OnInit } from '@angular/core' ; import { Book } from '../shared/book' ; @ Component ({ selector : 'app-book-details' , templateUrl : './book-details.component.html' , styleUrls : [ './book-details.component.css' ] }) export class BookDetailsComponent implements OnInit { @ Input () book : Book ; @ Output () showListEvent = new EventEmitter < any > (); ngOnInit () { } getRating ( num : number ) { return new Array ( num ); } showBookList () { this . showListEvent . emit (); } } book-list.component.ts import { Component , OnInit } from '@angular/core' ; import { Book } from '../shared/book' ; import { BookStoreService } from '../shared/book-store.service' ; @ Component ({ selector : 'app-book-list' , templateUrl : './book-list.component.html' , styleUrls : [ './book-list.component.css' ] }) export class BookListComponent implements OnInit { books : Book []; constructor ( private bs : BookStoreService ) { } ngOnInit () : void { this . books = this . bs . getAll (); } } app.component.ts import { Component } from '@angular/core' ; @ Component ({ selector : 'app-root' , templateUrl : './app.component.html' , styleUrls : [ './app.component.css' ] }) export class AppComponent { } Success Der sechste Teil unserer B\u00fccher-App ist erstellt! Wir haben unsere Anwendung um ein Routing erg\u00e4nzt. Wir k\u00f6nnen Routen konfigurieren, parametrisierte Routen auslesen, Routen verlinken und aktive Links stylen. Die Zust\u00e4nde unserer Anwendung werden nun \u00fcber lesbare URL-Pfade abgebildet. RouterOutlets sind Platzhalter f\u00fcr die zu ladenden Komponenten. Kindkomponenten werden in das RouterOutlet der Elternkomponente geladen. Routen lassen sich so verschachteln.","title":"B\u00fccher-App"},{"location":"books/#bucher-app","text":"Das folgende Beispiel ist dem Buch Ferdinand Malcher, Johannes Hoppe, Danny Koppenhagen: \"Angular: Grundlagen, fortgeschrittene Themen und Best Practices\" dpunkt.verlag, 2. Auflage, ISBN: 978-3-86490-646-6, 2019 Link entnommen (und nur unwesentlich ge\u00e4ndert). In der App soll eine Liste von B\u00fcchern angezeigt werden, f\u00fcr jedes einzelne Buch soll eine Detailansicht existieren und B\u00fccher k\u00f6nnen hinzugef\u00fcgt werden.","title":"B\u00fccher-App"},{"location":"books/#projekt-anlegen","text":"Wir gehen wie in beschrieben vor. Wir wollen unsere App book-app nennen. ng new book-app Wir werden gefragt, ob wir Routing verwenden m\u00f6chten (Antwort: y ) und welches StyleSheet-Format wir verwenden (Antwort: CSS ): ? Would you like to add Angular routing? Yes ? Which stylesheet format would you like to use? CSS Nachdem das Projekt erstellt wurde, wechseln wir im Terminal in das Verzeichnis book-app cd book-app und rufen darin npm install auf, um alle in package.json definierten Abh\u00e4ngigkeiten und Module einzubinden. Danach kann die Anwendung durch Eingabe von ng serve gestartet werden. \u00d6ffnen Sie den Browser und geben Sie als URL http://localhost:4200/ ein. Es erscheint die Angular-Projekt-Startseite (siehe auch Erstes Angular-Projekt erstellen ). \u00d6ffnen Sie nun noch in Ihrer IDE (z.B. IntelliJ IDEA ) das Projekt book-app , um Ihre Implementierungen durchzuf\u00fchren. Zun\u00e4chst k\u00fcmmern wir uns allerdings erst noch um das Aussehen des Projektes - um moderne, einheitliche Styles.","title":"Projekt anlegen"},{"location":"books/#css-framework-semantic-ui-einbinden","text":"Es ist \u00fcblich, eines der bekannten Style-Frameworks (z.B. Bootstrap oder Material Design ) einzubinden. F\u00fcr die B\u00fccher-App soll daf\u00fcr Semantic UI verwendet werden. Geben Sie dazu im Terminal in dem book-app -Verzeichnis npm install semantic-ui-css ein. Durch diese Anweisung werden die ben\u00f6tigten Style-Dateien geladen und unter dem Ordner node_modules/semantic-ui-css gespeichert. Diese m\u00fcssen jetzt nur noch in das Projekt eingebunden werden. \u00d6ffnen Sie dazu in Ihrer IDE die Datei angular.json . Bei dieser Datei handelt es sich um eine JSON -Datei, die f\u00fcr die Konfiguration unserer Angular-Anwendung zust\u00e4ndig ist. In der angular.json -Datei \u00e4ndern wir unter \"projects\"\u2192\"book-app\"\u2192\"architect\"\u2192\"build\"\u2192\"options\"\u2192\"styles\" den Eintrag von \"styles\" : [ \"src/styles.css\" ] , auf \"styles\" : [ \"node_modules/semantic-ui-css/semantic.css\" ] , Die gleiche \u00c4nderung f\u00fchren wir in angular.json unter \"test\" (statt \"build\" ) durch, um die Styles auch beim Testen einzubeziehen. Also unter \"projects\"\u2192\"book-app\"\u2192\"architect\"\u2192\"test\"\u2192\"options\"\u2192\"styles\" ebenfalls nach \"styles\" : [ \"node_modules/semantic-ui-css/semantic.css\" ] , \u00e4ndern. Um zu testen, ob das Einbinden der Semantic-UI-Styles geklappt hat, \u00f6ffnen wir in der IDE die Datei app.component.html und l\u00f6schen darin alles bis auf <router-outlet></router-outlet> . Stattdessen geben wir davor ein (Listing zeigt auch <router-outlet></router-outlet> - also die dann vollst\u00e4ndige Datei app.component.html ): < div class = \"ui active inverted dimmer\" > < div class = \"ui text loader large\" > Lade B\u00fccher ... </ div > </ div > < router-outlet ></ router-outlet > Wir gestalten also das Template unserer App-Komponente als ein div im div . Beiden div s werden CSS-Klassen aus dem Semantic-UI-Framework zugeordnet (siehe z.B. Klasse loader ). Unsere Webseite sollte nun so aussehen: Success Der erste Teil unserer B\u00fccher-App ist erstellt! Wir haben eine Anwendung erstellt und diese aufgerufen. Wir haben ein CSS-Framework eingebunden und erste \u00c4nderungen am HTML-Code vorgenommen. Unter http://localhost:4200/ ist unsere Anwendung nun im Browser sichtbar und alle unseren zuk\u00fcnftigen \u00c4nderungen am Code werden automatisch (ohne erneuten Aufruf) der Seite dargestellt.","title":"CSS-Framework Semantic UI einbinden"},{"location":"books/#datenmodell-und-daten","text":"Wir wollen Details (Daten) \u00fcber B\u00fccher speichern und verwenden dazu die JavaScript Object Notation (JSON) . Zun\u00e4chst wird Angular jedoch das dazugeh\u00f6rige Datenmodell bekannt gemacht. Dies geschieht mithilfe eines Interfaces . Wir erstellen ein solches Interface mithilfe der Angular CLI im Terminal (Sie sind im book-app -Verzeichnis): ng g interface shared/book Die obige Anweisung erstellt eine Datei book.ts im Ordner src/app/shared . Der shared - Ordner wird automatisch angelegt. In der obigen Anweisung steht g f\u00fcr generate ( h\u00e4tte man auch schreiben k\u00f6nnen ). In der IDE \u00f6ffnen wir die Datei book.ts . Sie enth\u00e4lt nur die Interface-Deklaration ohne Inhalt: export interface Book { } Wir implementieren das Interface wie folgt: export interface Book { isbn : string ; title : string ; authors : string []; published : Date ; subtitle ?: string ; rating ?: number ; thumbnails ?: Thumbnail []; description ?: string ; } export interface Thumbnail { url : string ; title ?: string ; } Das bedeutet, dass unser Datenmodell so aussieht, dass die Details \u00fcber ein Buch folgende Daten beinhalten: isbn , title , authors , published , subtitle , rating , thumbnails , description . Die Fragezeichen hinter den Bezeichnern geben an, dass die jeweilige Eigenschaft optional ist, d.h. dass ihr kein Wert zugeordnet werden muss. Die Eigenschaft thumbnail ist vom Typ Thumbnail -Array. Dieser Typ ist kein Standard-TypeScript-Typ, sondern von uns definiert. Thumbnail definieren wir ebenfalls als Interface, bestehend aus 2 Eigenschaften url und (optional) title . Die Definition dieses Interfaces erfolgt ebenfalls direkt in book.ts . Wir haben also 2 Interfaces diefiniert: Book und Thumbnail . Die Daten werden zun\u00e4chst direkt in eine neu zu erstellende Komponente zum Anzeigen der B\u00fccher-Liste eingebunden:","title":"Datenmodell und Daten"},{"location":"books/#bucherliste-erstellen","text":"Zur Anzeige aller gespeicherten B\u00fccher erstellen wir eine neue Komponente book-list . Siehe dazu auch Angular \u2192 Eine neue Komponente erzeugen : ng generate component book-list Es ensteht ein neuer Ordner src/app/book-list , welcher die 4 Dateien: book-list.component.css book-list.component.html book-list.component.spec.ts book-list.component.ts enth\u00e4lt. In der IDE \u00f6ffnen wir zun\u00e4chst die book-list.component.html . Sie sieht so aus: < p > book-list works! </ p > Wir ersetzen den Inhalt vollst\u00e4ndig durch den folgenden HTML-Code: < div class = \"ui middle aligned selection divided list\" > < a * ngFor = \"let book of books\" class = \"item\" > < img class = \"ui tiny image\" * ngIf = \"book.thumbnails && book.thumbnails[0] && book.thumbnails[0].url\" [ src ]=\" book . thumbnails [ 0 ]. url \" /> < div class = \"content\" > < div class = \"header\" > {{ book.title }} </ div > < div * ngIf = \"book.subtitle\" class = \"description\" > {{ book.subtitle }} </ div > < div class = \"metadata\" > < span * ngFor = \"let author of book.authors; last as l\" > {{ author }} < span * ngIf = \"!l\" > , </ span > </ span > < br /> ISBN {{ book.isbn }} </ div > </ div > </ a > </ div > Obiger Code enth\u00e4lt einige Strukturdirektiven (siehe Angular \u2192 *Strukturdirektiven )). So l\u00e4uft bspw. die *ngFor -Direktive in der zweiten Zeile durch die Liste books und erzeugt f\u00fcr jedes Buch aus der Liste books einen Hyperlink <a> . Diese existiert jedoch noch gar nicht, so dass unsere App sich derzeit nicht ausf\u00fchren l\u00e4sst. Die erste *ngIf -Direktive in der vierten Zeile pr\u00fcft zun\u00e4chst, ob das Array book.thumbnails \u00fcberhaupt existiert und wenn ja, ob dieses Array einen ersten Eintrag hat book.thumbnails[0] und wenn das der Fall ist, ob dieser erste Eintrag auch eine url enth\u00e4lt (siehe Interfaces Book und Thumbnail ). Wenn diese url existiert, wird durch ein Property-Binding (siehe Angular \u2192 [Property Binding] ) dem src -Attribut von <a> der Wert zugeordnet, der unter book.thumbnails[0].url im JSON gespeichert ist. Die Liste der Autoren eines Buches wird ebenfalls mithilfe der Strukturdirektive *ngFor durchlaufen. Au\u00dferdem findet die Hilfsvariable last dieser Strukturdirektive Anwendung (siehe Angular \u2192 *Strukturdirektiven )). Alle Autoren werden durch Komma getrennt. Nur nach dem letzten Autor wird kein Komma hinzugef\u00fcgt. Dies gelingt mithilfe der Strukturdirektive *ngIf und der Abfrage, ob es sich nicht um das letzte Element handelt - dann Komma. Wir ben\u00f6tigen jetzt f\u00fcr unsere Komponente noch die Liste der B\u00fccher - ein Book -Array. Dieses legen wir in der Datei book-list.component.ts an. Wir \u00f6ffnen diese Datei - sie sieht wie folgt aus: import { Component , OnInit } from '@angular/core' ; @ Component ({ selector : 'app-book-list' , templateUrl : './book-list.component.html' , styleUrls : [ './book-list.component.css' ] }) export class BookListComponent implements OnInit { constructor () { } ngOnInit () : void { } } Die (TypeScript-)Klasse BookListComponent enth\u00e4lt zwei Methoden: den Konstruktor constructor() { } ngOnInit(): void { } ngOnInit() ist eine Methode aus dem Interface OnInit . Dabei handelt es sich um einen sogenannten Lifecycle-Hook (siehe Angular \u2192 Lifecycle-Hooks ). Die Methode ngOnInit() wird immer dann (automatisch) ausgef\u00fchrt, wenn die Komponente geladen wird. Wir ersetzen den bisherigen Code der Datei book-list.component.ts durch: import { Component , OnInit } from '@angular/core' ; import { Book } from '../shared/book' ; @ Component ({ selector : 'app-book-list' , templateUrl : './book-list.component.html' , styleUrls : [ './book-list.component.css' ] }) export class BookListComponent implements OnInit { books : Book []; constructor () { } ngOnInit () : void { this . books = [ { isbn : '9783864906466' , title : 'Angular' , authors : [ 'Ferdinand Malcher' , 'Johannes Hoppe' , 'Danny Kopenhagen' ], published : new Date ( 2019 , 4 , 30 ), subtitle : 'Grundlagen, fortgeschrittene Techniken und Best Practices - mit NativeScript und NgRx' , rating : 5 , thumbnails : [{ url : 'https://ng-buch.de/cover2.jpg' , title : 'Buchcover' }], description : 'Die Autoren f\u00fchren Sie mit einem anspruchsvollen Beispielprojekt durch die Welt von Angular...' , }, { isbn : '9783864903274' , title : 'React' , authors : [ 'Oliver Zeigermann' , 'Nils Hartmann' ], published : new Date ( 2016 , 6 , 17 ), subtitle : 'Die praktische Einf\u00fchrung in React, React Router und Redux' , rating : 3 , thumbnails : [{ url : 'https://ng-buch.de/cover1.jpg' , title : 'Buchcover' }], description : 'React ist ein JavaScript-Framework zur Entwicklung von Benutzeroberfl\u00e4chen ...' , }, { isbn : '978-3-86490-578-0' , title : 'Effective Java' , authors : [ 'Joshua Bloch' ], published : new Date ( 2018 , 9 , 1 ), subtitle : 'Best Practices f\u00fcr die Java-Plattform' , rating : 3 , thumbnails : [{ url : 'https://www.dpunkt.de/common/images/cover_masterid/300/13216.jpg' , title : 'Buchcover' }], description : 'Seit der Vorauflage von \\\"Effective Java\\\" hat sich Java dramatisch ver\u00e4ndert...' , } ]; } } Somit existiert die Eigenschaft books f\u00fcr die Komponente nun (siehe books: Book[] ). Auf diese Eigenschaft kann innerhalb der Klasse mit this.books zugegriffen werden. Dies passiert auch in der ngOnInit() -Methode. Dort wird das Array mit Daten bef\u00fcllt (mit zun\u00e4chst 3 B\u00fcchern). Die Syntax entspricht der JavaScript Object Notation (JSON) . Damit unsere Komponente \u00fcberhaupt sichtbar ist, binden wir sie noch in unsere Root-Komponente ein. Der Selektor unserer book-list -Komponente ist app-book-list . Wir binden diesen Selektor als HTML-Element in app.component.html ein. app.component.html (alt) < div class = \"ui active inverted dimmer\" > < div class = \"ui text loader large\" > Lade B\u00fccher ... </ div > </ div > < router-outlet ></ router-outlet > app.component.html (neu) < app-book-list ></ app-book-list > < router-outlet ></ router-outlet > Die App ist nun ausf\u00fchrbar. Im Browser erscheint folgende Darstellung: Success Der zeite Teil unserer B\u00fccher-App ist erstellt! Wir haben zwei Interfaces ( Book und Thumbnail ) und eine neue Komponente ( book-list ) erstellt. Wir haben Direktiven verwendet ( *ngFor und *ngIf ), um durch Daten zu man\u00f6vrieren und diese entsprechend darszustellen. Wir haben Daten im JSON-Format gespeichert.","title":"B\u00fccherliste erstellen"},{"location":"books/#datenfluss-zwischen-komponenten","text":"In diesem Abschnitt wird der Datenfluss von Eltern- auf Kindkomponenten und von Kind- auf Elternkomponenten betrachtet. Letzteres erreicht man \u00fcber event binding (siehe Angular\u2192Event Binding ). Wir betrachten zun\u00e4chst den Datenfluss von Eltern- auf Kindkomponenten. Das grundlegende Prinzip dabei ist das property binding (siehe dazu Angular \u2192 [Property Bindings] ).","title":"Datenfluss zwischen Komponenten"},{"location":"books/#datenfluss-von-eltern-auf-kindkomponenten","text":"Wir legen uns dazu zun\u00e4chst eine weitere Komponente in unserer B\u00fccher-App an - die Komponente book-list-item . Sie ist daf\u00fcr zust\u00e4ndig, die Informationen \u00fcber ein einzelnes Buch im Detail anzuzeigen. Wir werden zu dieser Detailansicht gelangen, indem wir ausgehend von der Liste der B\u00fccher auf ein einzelnes Buch klicken - dieses wird dann im Detail angezeigt. Wechseln Sie im Terminal in den Ordner Ihrer B\u00fccher-App book-app und geben dort zum Erzeugen der neuen Komponente ein: ng g c book-list-item Im Ordner book-app/src/app entsteht eine neue Komponente (ein neuer Ordner) book-list-item mit den Dateien book-list-item.component.ts , book-list-item.component.html , book-list-item.component.css und book-list-item.component.spec.ts . Wir kopieren zun\u00e4chst den Teil aus der book-list.component.html in die book-list-item.component.html , der die Details eines Buches anzeigt. Im folgenden Tab sind jeweils die *.component.html gemeint. book-list (alt) < div class = \"ui middle aligned selection divided list\" > < a * ngFor = \"let book of books\" class = \"item\" > < img class = \"ui tiny image\" * ngIf = \"book.thumbnails && book.thumbnails[0] && book.thumbnails[0].url\" [ src ]=\" book . thumbnails [ 0 ]. url \" /> < div class = \"content\" > < div class = \"header\" > {{ book.title }} </ div > < div * ngIf = \"book.subtitle\" class = \"description\" > {{ book.subtitle }} </ div > < div class = \"metadata\" > < span * ngFor = \"let author of book.authors; last as l\" > {{ author }} < span * ngIf = \"!l\" > , </ span > </ span > < br /> ISBN {{ book.isbn }} </ div > </ div > </ a > </ div > book-list-item < img class = \"ui tiny image\" * ngIf = \"book.thumbnails && book.thumbnails[0] && book.thumbnails[0].url\" [ src ]=\" book . thumbnails [ 0 ]. url \" /> < div class = \"content\" > < div class = \"header\" > {{ book.title }} </ div > < div * ngIf = \"book.subtitle\" class = \"description\" > {{ book.subtitle }} </ div > < div class = \"metadata\" > < span * ngFor = \"let author of book.authors; last as l\" > {{ author }} < span * ngIf = \"!l\" > , </ span > </ span > < br /> ISBN {{ book.isbn }} </ div > </ div > book-list (neu - zun\u00e4chst) < div class = \"ui middle aligned selection divided list\" > < a * ngFor = \"let book of books\" class = \"item\" > <!-- dieses Anchorelement (Hyperlink <a>) wird gleich ge\u00e4ndert aber die Direktive *ngFor bleibt --> </ a > </ div > Nachdem wir den oben gelb unterlegten Teil nach book-list-item.component.html geschoben haben, f\u00e4llt auf, dass die Variable book in der Komponente book-list-item (noch) unbekannt ist. Dies wird nun ge\u00e4ndert. Zun\u00e4chst \u00e4ndern das HTML-Element, das uns die Details eines Buches anzeigen soll von <a> nach <app-book-list-item> - das ist der Selektor unserer neuen Komponente. book-list.component.html 1 2 3 4 5 6 < div class = \"ui middle aligned selection divided list\" > < app-book-list-item class = \"item\" * ngFor = \"let b of books\" [ book ]=\" b \" > </ app-book-list-item > </ div > In Zeile 2 erkennt man die Verwendung des Selektors app-book-list-item , hier erfolgt der \"Aufruf\" unserer neuen Komponente. In Zeile 3 wird die bereits bekannte Direktive *ngFor angewendet (siehe Angular\u2192*Strukturdirektiven ), mit der wir durch unser Array von B\u00fcchern ( Book[] ) laufen. In Zeile 4 findet nun das property binding statt (siehe Angular \u2192 [Property Bindings] )). Der Eigenschaft book wird jeweils der Wert der Variable b \u00fcbergeben. Das bedeutet, dass wir in der Elternkomponente book-list die Kindkomponente book-list-item aufrufen und in der Elternkomponente einer Eigenschaft der Kindkomponente book einen Wert zuweisen. Es erfolgt also ein Datenfluss von der Elternkoponente zur Kindkomponente unter Verwendung von property binding . Es fehlt nur noch zwei Sachen: die Eigenschaft book (vom Typ Book ) muss noch als Eigenschaft (Objektvariable) der Komponente book-list-tem deklariert werden. es muss mithilfe des Decorators @Input() aggeben werden, dass die Werte (Daten) f\u00fcr diese Eigenschaft \"in die Komponente hineinflie\u00dfen\". Beides erreichen wir durch \u00c4nderungen der Datei book-list-item.component.ts wie folgt: book-list-item.component.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { Component , Input , OnInit } from '@angular/core' ; import { Book } from '../shared/book' ; @ Component ({ selector : 'app-book-list-item' , templateUrl : './book-list-item.component.html' , styleUrls : [ './book-list-item.component.css' ] }) export class BookListItemComponent implements OnInit { @ Input () book : Book ; constructor () { } ngOnInit () : void { } } Wesentlich ist die Zeile 10. Dort sehen Sie die Deklaration der Eigenschaft book: Book und die Verwendung der Directive @Input() . Sowohl das Interface Book als auch die Directive @Input m\u00fcssen noch eingebunden werden (Zeilen 1 und 2). Lassen Sie dies am besten Ihre IDE erledigen. Gehen Sie mit der Maus \u00fcber die rot dargestellten Bezeichner ( Book und @Input() ) und w\u00e4hlen Sie jeweils den automatischen Korrekturvorschlag aus. Success Der dritte Teil unserer B\u00fccher-App ist erstellt! Leider hat sich in der Ansicht nichts ge\u00e4ndert. Zwar wissen wir jetzt, wie der Datenfluss von Eltern- auf Kindkomponenten erfolgt (n\u00e4mlich mit property binding und der Deklaration der Eigenschaft (property) mithilfe des @Input() -Decorators). Aber der Wechsel der Ansicht ist noch nicht realisiert. Dieser soll durch ein Ereignis ausgel\u00f6st werden, n\u00e4mlich wenn wir auf eines der B\u00fccher aus der Liste klicken. Die Behandlung von Ereignissen ( event binding ) ist Thema des n\u00e4chsten Abschnittes.","title":"Datenfluss von Eltern- auf Kindkomponenten"},{"location":"books/#datenfluss-von-kind-auf-elternkomponenten","text":"Der Datenfluss von Kind- auf Elternkomponenten kann mithilfe von event binding organisiert werden (siehe dazu Angular\u2192Eigene Ereignisse ). Wir werden eine BookDetailsComponent erzeugen. Diese zeigt die Details eines Buches. In unserer BookListComponent definieren wir ein Ereignis, das diese Detail-Ansicht aufruft und dabei das entsprechende Buch \u00fcbergibt. In der BookDetailsComponent definieren wir ein Ereignis, das die Listendarstellung aller B\u00fccher wieder aufruft. Wir erzeugen zun\u00e4chst die BookDetailsComponent : ng g c book-details Wir planen folgende Kommunikation zwischen den Komponenten (Abbildung ebenfalls aus eingangs erw\u00e4hntem Buch ): Wir erweitern zun\u00e4chst die Komponente AppComponent um zwei weitere Eigenschaften: book vom Typ Book (die Daten eines Buches sollen ja an die Komponente BookDetailsComponent mithilfe von property binding weitergegeben werden) und einen viewState , der zwischen den beiden Ansichten BookList und BookDetails umschalten soll. Dazu vereinbaren wir einen neuen Typ ViewState , der 2 verschiedene Werte annehmen kann list und details . Die neue app.component.ts sieht dann so aus: app.component.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import { Component } from '@angular/core' ; import { Book } from './shared/book' ; type ViewState = 'list' | 'details' ; @ Component ({ selector : 'app-root' , templateUrl : './app.component.html' , styleUrls : [ './app.component.css' ] }) export class AppComponent { book : Book ; viewState : ViewState = 'list' ; showList () { this . viewState = 'list' ; } showDetails ( book : Book ) { this . book = book ; this . viewState = 'details' ; } } Neben den beiden Eigenschaften book und viewState ( viewState ist vom Typ ViewState - dieser wurde in Zeile 5 erstellt) wurde auch zwei Methoden hinzugef\u00fcgt: showList() und showDetails(book: Book) . showList() wird von der Kindkomponente BookDetailsComponent als Ereignis aufgerufen ( event binding ). showDetails() wird von der Kindkomponente BookListComponent als Ereignis aufgerufen und liefert als payload des Ereignisses die Informationen \u00fcber das Buch mit, auf das innerhalb der Liste geklickt wurde (siehe auch Angular\u2192Eigene Ereignisse ). Die beiden Methoden schalten jeweils zwischen den viewState s um. Im Template der AppComponent wird mittels der *ngIf -Direktive zwischen den Ansichten der beiden Komponenten BookDetailsComponent und BookListeComponent umgeschaltet, je nachdem, welcher Wert viewState aufweist: app.component.html 1 2 3 4 5 6 7 8 9 10 < app-book-list * ngIf = \"viewState === 'list'\" ( showDetailsEvent )=\" showDetails ($ event )\" ></ app-book-list > < app-book-details * ngIf = \"viewState === 'details'\" ( showListEvent )=\" showList ()\" [ book ]=\" book \" ></ app-book-details > < router-outlet ></ router-outlet > Die beiden Events showDetailsEvent und showListEvent der beiden Komponenten BookListComponent bzw. BookDetailsComponent sind noch nicht in den jeweiligen Komponenten angelegt, ebenso noch nicht die Eigenschaft book in der BookDetailsComponent . Das machen wir jetzt in beginnen mit der BookListComponent . In der BookListComponent soll ein eigenes Event ( showDetailsEvent ) definiert werden. Wir gehen dazu vor, wie in Angular\u2192Eigene Ereignisse beschrieben. Wichtig ist, dass wir einen payload des Events \u00fcbergeben, n\u00e4mlich das jeweilige Buch auf das geklickt wurde. Dieser payload wird in der Methode showDetails($event) der AppComponent verarbeitet. Wir \u00f6ffnen die book-list.component.ts und f\u00fcgen hinzu : Caution Achten Sie darauf, dass Sie nur den Teil hinzuf\u00fcgen, der noch nicht in Ihrer book-list.component.ts enthalten ist. Diese Datei ist durch das JSON schon recht lang. Es kommen nur die Zeilen 8 und 14-16 hinzu und in der ersten Zeile werden EventEmitter und Output aus @angular/core importiert! book-list.component.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { Component , EventEmitter , OnInit , Output } from '@angular/core' ; import { Book } from '../shared/book' ; @ Component ({ /* bleibt wie es ist */ }) export class BookListComponent implements OnInit { books : Book []; @ Output () showDetailsEvent = new EventEmitter < Book > (); constructor () { } ngOnInit () : void { /* bleibt wie es ist */ } showDetails ( book : Book ) { this . showDetailsEvent . emit ( book ); } } Im Template der BookListComponent kommt nur ein event binding hinzu. Wir binden das native DOM-Ereignis click an die Ereignisbehandlung showDetails() und \u00fcbergeben dabei als payload das entsprechende Buch b . Das bedeutet, dass jetzt jedes einzelne BookItem (es gibt f\u00fcr jedes Buch eine eigens BookItem - siehe *ngFor ) ein Click-Ereignis existiert. Klicken wir also auf einen Eintrag in unserer BookList , dann wird das showDetails() -Ereignis ausgel\u00f6st, das entsprechende Buch als payload \u00fcbergeben und an die AppComponent weitergereicht, die dann auf die BookDetails -Ansicht umschaltet. Die um diese eine Zeile (Zeile 5) erweiterte book-list.component.html sieht nun so: book-list.component.html 1 2 3 4 5 6 7 < div class = \"ui middle aligned selection divided list\" > < app-book-list-item class = \"item\" * ngFor = \"let b of books\" [ book ]=\" b \" ( click )=\" showDetails ( b )\" > </ app-book-list-item > </ div > Reflexion Wir sehen in dem obigen kleinen Beispiel book-list.component.html sehr sch\u00f6n vier Konzepte: 1. die Komponente BookListComponent ruft die Komponente BookListItemComponent auf. Damit ist BookListComponent eine Elternkomponente der Kindkomponente BookListItemComponent (Zeile 2). 2. der Einsatz der Direktive *ngFor . F\u00fcr jeden einzelnen Eintrag aus dem Array books wird ein neues HTML-Element <app-book-list-item> erzeugt. 3. Ein property binding , bei der der Ausdruck \"b\" and die Eigenschaft book gebunden wird und 4. ein event binding , bei der wir die Ereignisbehandlung showDetails(b) an das native DOM-Element click binden. Jetzt k\u00fcmmern wir uns noch um unsere neue Komponente BookDetailsComponent . Zwei Konzepte kennen wir bereits: definieren wir uns eine Eigenschaft book , deren Wert wir als @Input() von der Elternkomponente AppComponent erhalten (siehe dazu Datenfluss von Eltern- auf Kindkomponenten ). definieren wir uns ein eigenes Ereignis, welches an die Elternkomponente AppComponent weitergereicht wird (siehe dazu book-list.component.ts oben) Es wird noch eine dritte Kleinigkeit eingef\u00fcgt: eine Methode getRating(number) , die f\u00fcr eine gegebene Zahl ein Array der \u00fcbergebenen L\u00e4nge zur\u00fcckgibt. Wir werden im Template sehen, was es damit auf sich hat. Die book-details.component.ts sieht dann wie folgt aus: book-details.component.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { Component , EventEmitter , Input , OnInit , Output } from '@angular/core' ; import { Book } from '../shared/book' ; @ Component ({ selector : 'app-book-details' , templateUrl : './book-details.component.html' , styleUrls : [ './book-details.component.css' ] }) export class BookDetailsComponent implements OnInit { @ Input () book : Book ; @ Output () showListEvent = new EventEmitter < any > (); ngOnInit () { } getRating ( num : number ) { return new Array ( num ); } showBookList () { this . showListEvent . emit (); } } Das zugeh\u00f6rige Template ist recht umfangreich. Wir gehen auf einzelne Details ein, zeigen es aber zun\u00e4chst: book-details.component.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 < div * ngIf = \"book\" > < h1 > {{ book.title }} </ h1 > < h3 * ngIf = \"book.subtitle\" > {{ book.subtitle }} </ h3 > < div class = \"ui divider\" ></ div > < div class = \"ui grid\" > < div class = \"four wide column\" > < h4 > Autoren </ h4 > < ng-container * ngFor = \"let author of book.authors\" > {{ author }} < br > </ ng-container > </ div > < div class = \"four wide column\" > < h4 > ISBN </ h4 > {{ book.isbn }} </ div > < div class = \"four wide column\" > < h4 > Erschienen </ h4 > {{ book.published }} </ div > < div class = \"four wide column\" > < h4 > Rating </ h4 > < i class = \"yellow star icon\" * ngFor = \"let r of getRating(book.rating)\" ></ i > </ div > </ div > < h4 > Beschreibung </ h4 > < p > {{ book.description }} </ p > < div class = \"ui small images\" > < img * ngFor = \"let thumbnail of book.thumbnails\" [ src ]=\" thumbnail . url \" > </ div > < button class = \"ui red button\" ( click )=\" showBookList ()\" > Zur\u00fcck zur Buchliste </ button > </ div > Die Detailansicht sollte dann etwa so aussehen: Success Der vierte Teil unserer B\u00fccher-App ist erstellt! Wir wissen jetzt, wie wir Ereignisse behandeln und sogar eigene Ereignisse erstellen k\u00f6nnen und wie wir mit diesen eigenen Ereignissen und event bining Daten an die Elternklasse \u00fcbergeben k\u00f6nnen. Damit k\u00f6nnen wir jetzt sowohl von Eltern- nach Kindklassen als auch zur\u00fcck Daten transferieren und durch Ereignisse zwischen verschiedenen Komponenten hin- und herwechseln. F\u00fcr viele Komponenten und eine tiefe Verschachtelung ist die Komplexit\u00e4t jedoch mit diesen Konzepten zu hoch. Wir lernen zwei weitere Konzepte kennen, die uns helfen, diese Komplexit\u00e4t zu meistern: Services und Routing .","title":"Datenfluss von Kind- auf Elternkomponenten"},{"location":"books/#service-bookstoreservice","text":"Derzeit ist die Liste (genauer: das Array) unserer B\u00fccher statisch als JSON innerhalb der Komponente BookListComponent gespeichert (siehe in ngOnInit() this.books = [ ... ] ). Die BookListComponent verwaltet somit die B\u00fccher und stellt diese auch noch als Liste dar. Wir wollen die Darstellung unabh\u00e4ngig von der \"Datenspeicherung\" gestalten und die Datenverwaltung (Speicherung und Bereitstellung) in einen Service auslagern (siehe Angular\u2192Services ). Um einen Service mithilfe der CLI anzulegen (zu generieren), verwenden wir das Attribut service anstelle von component . Au\u00dferdem ist es guter Stil, Services in den shared -Ordner abzulegen, da ja alle Komponenten einen Service nutzen k\u00f6nnen. Wir erzeugen einen Service BookStoreService : ng g service shared/book-store Nach der Erzeugung sieht der Service zun\u00e4chst so aus: book-store.service.ts import { Injectable } from '@angular/core' ; @ Injectable ({ providedIn : 'root' }) export class BookStoreService { constructor () { } } F\u00fcr Services gibt es keine Lifecycle-Hooks. Wir finden hier deshalb auch keine ngOnInit() -Methode. W\u00e4hrend Komponenten den Decorator @Component() aufweisen, wird f\u00fcr Services der Decorator @Injectable() verwendet. Mit diesem Decorator geben wir an, dass der Service weitere Abh\u00e4ngigkeiten einbinden kann. Dies geschieht typischerweise \u00fcber einen Parameter im Konstruktor - eine soganannte dependency injection (wenn \u00fcber den Konstruktor, dann constructor injection ). Auch wenn wir eine solche Abh\u00e4ngigkeit nicht einbinden, sollte der Decorator @Injectable() stets f\u00fcr einen Service angegeben werden. Dies liegt daran, dass wir diesen Decorator um die providedIn -Eigenschaft erweitern. Mit providedIn: 'root' geben wir an, dass der Service allen Komponenten (im gesamten Root-Modul) zur Verf\u00fcgung steht, er also von allen Komponenten genutzt werden kann. In unseren Service integrieren wir nun folgende Eigenschaften: das Book -Array books aus der BookListComponent und die Methode getAll() , die dieses Array zur\u00fcckgibt, also alle B\u00fccher aus dem Array books . book-store.service.ts import { Injectable } from '@angular/core' ; import { Book } from './book' ; @ Injectable ({ providedIn : 'root' }) export class BookStoreService { books : Book []; constructor () { this . books = [ { isbn : '9783864906466' , /* das gesamte Array aus book-list.component.ts hier her bewegen */ }, } getAll () : Book [] { return this . books ; } } book-list.component.ts import { Component , EventEmitter , OnInit , Output } from '@angular/core' ; import { Book } from '../shared/book' ; @ Component ({ selector : 'app-book-list' , templateUrl : './book-list.component.html' , styleUrls : [ './book-list.component.css' ] }) export class BookListComponent implements OnInit { books : Book []; @ Output () showDetailsEvent = new EventEmitter < Book > (); constructor () { } ngOnInit () : void { } showDetails ( book : Book ) { this . showDetailsEvent . emit ( book ); } } Es wurde also die gesamte Wertebelegung f\u00fcr this.books mit dem JSON von der Datei book-list.component.ts (dort aus ngOnInit() ) nach book-store.service.ts (hier in den Konstruktor constructor() - Liefecycle-hooks gibt es f\u00fcr Services ja nicht) verschoben. Dazu wurde dem Service die Eigenschaft books hinzugef\u00fcgt (Typ Book[] - das Interface Book muss dazu importiert werden). Au\u00dferdem wurde in dem Service die Methode getAll() implementiert. Nun kann der Service in der BookListComponent verwendet werden. Dazu werden der BookService importiert, der BookService mittels dependency injection ( constructor injection ) in die Komponente eingebunden und die Methode getAll() des Services aufgerufen, um die Eigenschaft this.books mit dem Book -Array zu initialisieren. book-list.component.ts import { Component , EventEmitter , OnInit , Output } from '@angular/core' ; import { Book } from '../shared/book' ; import { BookStoreService } from '../shared/book-store.service' ; @ Component ({ selector : 'app-book-list' , templateUrl : './book-list.component.html' , styleUrls : [ './book-list.component.css' ] }) export class BookListComponent implements OnInit { books : Book []; @ Output () showDetailsEvent = new EventEmitter < Book > (); constructor ( private bs : BookStoreService ) { } ngOnInit () : void { this . books = this . bs . getAll (); } showDetails ( book : Book ) { this . showDetailsEvent . emit ( book ); } } Beachten Sie, dass die dependency injection des Services dazu f\u00fchrt, dass bs eine Eigenschaft der BookListComponent ist, ohne dass diese Eigenschaft explizit deklariert wird. In ngOnInit() wird \u00fcber this.bs auf den Service zugegriffen. Die Anwendung sieht zwar genauso aus wie vorher, aber wir haben die BookListComponent davon entlastet, das B\u00fccher-Array speichern zu m\u00fcssen. Diesen Dienst haben wir in einen Service augelagert, der au\u00dferdem noch die Methode getAll() zur Verf\u00fcgung stellt, mit dem das gesamte B\u00fccher-Array zur\u00fcckgegeben wird. Success Der f\u00fcnfte Teil unserer B\u00fccher-App ist erstellt! Die Anwendung sieht zwar genauso aus wie vorher, aber wir haben die BookListComponent davon entlastet, das B\u00fccher-Array speichern zu m\u00fcssen. Diesen Dienst haben wir in einen Service augelagert, der au\u00dferdem noch die Methode getAll() zur Verf\u00fcgung stellt, mit dem das gesamte B\u00fccher-Array zur\u00fcckgegeben wird. Nun wollen wir mithilfe von Routing besser durch unsere Anwendung navigieren.","title":"Service BookStoreService"},{"location":"books/#routing","text":"Derzeit hat unsere App zwei Sichten: einerseits die Listenansicht aller B\u00fccher (Template der BookListComponent , wobei jede Zeile der Liste/jedes Buch durch das Template der BookListItemComponent dargestellt wird) und die Detailansicht eines Buches (Template der BookDetailsComponent ). Zwischen diesen Sichten ( views ) wechseln wir durch Nutzereignisse hin- und her. Von der Listenansicht auf die Detailansicht kommen wir durch Anklicken einer Buchzeile und zur\u00fcck kommen wir durch Klicken des Buttons \"Zur\u00fcck zur Buchliste\". Unsere URL bleibt jedoch immer gleich, n\u00e4mlich localhost:4200 . Ein direkter Zugriff auf die Detailansicht eines Buches ist nicht m\u00f6glich, sondern erfolgt immer \u00fcber die Listenansicht. Dies soll im folgenden ge\u00e4ndert werden. Zum Beispiel k\u00f6nnte die Detailansicht des Buches mit der ISBN 9783864906466 mithilfe der URL localhost:4200/books/9783864906466 erfolgen. Eine solche URL h\u00e4tte auch den Vorteil, dass man diese URL an andere versenden k\u00f6nnte, um auf ein konkretes Buch aufmerksam zu machen. Zur Erstellung solcher Pfade wird das Konzept des Routings in Angular verwendet (siehe Angular \u2192 Routing ). Wir erweitern unsere B\u00fccher-App zun\u00e4chst um eine weitere Komponente home . ng g c home","title":"Routing"},{"location":"books/#routen-konfigurieren","text":"In der app-routing.module.ts werden wir 4 Routen konfigurieren: /home zeigt die HomeComponent / wird auf die /home -Route umgeleitet, zeigt also ebenfalls auf die HomeComponent /books zeigt auf die BookListComponent /books/:isbn zeigt auf die BooksDetailsComponent f\u00fcr das entsprechende Buch mit der isbn des Parameterwertes app-routing.module.ts import { NgModule } from '@angular/core' ; import { Routes , RouterModule } from '@angular/router' ; import { HomeComponent } from './home/home.component' ; import { BookDetailsComponent } from './book-details/book-details.component' ; import { BookListComponent } from './book-list/book-list.component' ; const routes : Routes = [ { path : '' , redirectTo : 'home' , pathMatch : 'full' }, { path : 'home' , component : HomeComponent }, { path : 'books' , component : BookListComponent }, { path : 'books/:isbn' , component : BookDetailsComponent }, ]; @ NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { } app.component.html < router-outlet ></ router-outlet > Die app.component.html enth\u00e4lt nun nur noch das <router-outlet></router-outlet> -Element. Wenn wir nun http://localhost:4200 aufrufen, werden wir zu http://localhost:4200/home umgeleitet und es erscheint die View der HomeComponent ( home works! ). Wir k\u00f6nnen aber auch http://localhost:4200/books eingeben und es erscheint die View der BookListComponent , also die gesamte Liste unserer B\u00fccher.","title":"Routen konfigurieren"},{"location":"books/#parametrisierte-route-auslesen","text":"Wenn wir z.B. http://localhost:4200/books/9783864906466 aufrufen, also eine ISBN \u00fcbergeben, bleibt die angezeigte Seite der BookDetailsComponent leer. Das liegt daran, dass die in der URL \u00fcbergebene ISBN noch nicht verwaltet wird, um das entsprechende Buch herauszusuchen und anzuzeigen. Dazu erweitern wir zun\u00e4chst den BookStoreService : Caution Achten Sie darauf, dass Sie nur den Teil hinzuf\u00fcgen, der noch nicht in Ihrer book-store.service.ts enthalten ist. Diese Datei ist durch das JSON schon recht lang. Es kommen nur die Zeilen 18-20 hinzu! shared/book-store.service.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { Injectable } from '@angular/core' ; import { Book } from './book' ; @ Injectable ({ providedIn : 'root' }) export class BookStoreService { books : Book []; constructor () { this . books = [ /* alle Eintr\u00e4ge */ ]; } getAll () : Book [] { return this . books ; } getSingle ( isbn : string ) : Book { return this . books . find ( book => ( book . isbn === isbn )); } } Wir m\u00fcssen nun noch die ISBN auslesen, die in der URL \u00fcbergeben wird. Das Auslesen von Parameterwerten aus URLs ist in Angular \u2192 Parameter an Routen beschrieben. Dazu wird book-details.component.ts wie folgt erweitert : ActivatedRoute wird importiert und dem Konstruktor injiziert, um mithilfe von route.snapshot.paramMap die aktuellen Werte der in der URL \u00fcbergebenen Parameter abzufragen. Der BookStoreService wird importiert und dem Konstruktor injiziert, um auf das Array aller B\u00fccher, insbesondere aber auf die getSingle(isbn: string) -Funktion zuzugreifen, die das Buch mit der \u00fcbergebenen isbn zur\u00fcckgibt. Daf\u00fcr entfallen einige Sachen aus der book-details.component.ts : Wir wechseln die Ansichten nicht mehr durch ein Ereignis, sondern \u00fcberlassen dies dem Router. Deshalb entfernen wir die @Output() -Eigenschaft showListEvent und die Methode showBookList() . Das ausgew\u00e4hlte Buch gelangt nun nicht mehr \u00fcber property binding in das Template, sondern \u00fcber die Eigenschaft this.book (die ihren Wert von der Methode getSingle() des BookStoreService erh\u00e4lt). Wir k\u00f6nnen deshalb auch den @Input() -Decorator von book: Book entfernen. book-details.component.ts (neu) import { Component , OnInit } from '@angular/core' ; import { Book } from '../shared/book' ; @ Component ({ selector : 'app-book-details' , templateUrl : './book-details.component.html' , styleUrls : [ './book-details.component.css' ] }) export class BookDetailsComponent implements OnInit { @ Input () book : Book ; @ Output () showListEvent = new EventEmitter < any > (); ngOnInit () { } getRating ( num : number ) { return new Array ( num ); } showBookList () { this . showListEvent . emit (); } } book-details.component.ts (alt) import { Component , EventEmitter , Input , OnInit , Output } from '@angular/core' ; import { Book } from '../shared/book' ; @ Component ({ selector : 'app-book-details' , templateUrl : './book-details.component.html' , styleUrls : [ './book-details.component.css' ] }) export class BookDetailsComponent implements OnInit { @ Input () book : Book ; @ Output () showListEvent = new EventEmitter < any > (); ngOnInit () { } getRating ( num : number ) { return new Array ( num ); } showBookList () { this . showListEvent . emit (); } } In der book-details.component.html wird der Button entfernt, also der folgende Teil gel\u00f6scht: < button class = \"ui red button\" ( click )=\" showBookList ()\" > Zur\u00fcck zur Buchliste </ button > Success Jetzt wird die Detail-Ansicht eines jeden Buches angezeigt, wenn Sie eine existierende isbn \u00fcbergeben. Also z.B. http://localhost:4200/books/9783864906466 (oder http://localhost:4200/books/9783864903274 oder http://localhost:4200/books/978-3-86490-578-0 ). Bei einer nicht existierenden isbn (z.B. http://localhost:4200/books/123 ) bleibt die Seite leer.","title":"Parametrisierte Route auslesen"},{"location":"books/#routen-verlinken","text":"Derzeit m\u00fcssen wir die Routen noch jeweils als URL in den Browser eingeben. Wir wollen uns nun ein Navigationsmen\u00fc erzeugen, in dem wir die jeweiligen Routen als Links hinterlegen und somit \u00fcber Klicks die jeweiligen Komponenten aufrufen. Das prinzipielle Vorgehen ist in Angular \u2192 Routen verlinken beschrieben. Unsere Navigationsleiste f\u00fcgen wir am besten in die AppComponent ein, damit sie immer sichtbar bleibt. app.component.html < div class = \"ui menu\" > < a routerLink = \"home\" class = \"item\" > Home </ a > < a routerLink = \"books\" class = \"item\" > B\u00fccher </ a > </ div > < router-outlet ></ router-outlet > Jetzt binden wir in unserer Listen-Ansicht aller B\u00fccher noch die isbn -Eigenschaft an die routerLink -Property, um ein konkretes Buch mit der entsprechenden isbn auszuw\u00e4hlen. Wir passen dazu die book-list.component.html wie folgt an: book-list.component.html 1 2 3 4 5 6 7 < div class = \"ui middle aligned selection divided list\" > < app-book-list-item class = \"item\" * ngFor = \"let b of books\" [ book ]=\" b \" [ routerLink ]=\" b . isbn \" > </ app-book-list-item > </ div > Das click -Ereignis wird nun also nicht mehr ben\u00f6tigt und behandelt. Stattdessen binden wir mit property binding die isbn als Pfad an die Eigenschaft routerLink . Der Pfad ergibt sich somit aus der aktuellen Komponente ( /books ) und der isbn des Buches, auf das wir klicken. Daraus ergibt sich der Pfad /books/isbn ( isbn wird durch den konkreten String ersetzt). Wir erweitern noch das Template der HomeComponent um einen Button, mit dem wir zur B\u00fccherliste kommen: home.component.html 1 2 3 4 5 6 < h1 > Home </ h1 > < p > Herzlich willkommen zur B\u00fccher-App! </ p > < a routerLink = \"../books\" class = \"ui red button\" > B\u00fccherliste anzeigen < i class = \"right arrow icon\" ></ i > </ a > Der Pfad ../books ist releativ zur HomeComponent , also erst \"raus\" aus /home und dann nach /books .","title":"Routen verlinken"},{"location":"books/#aktive-links-stylen-und-aufraumen","text":"Den jeweils aktiven Men\u00fcpunkt werden wir nun noch farbig gestalten, damit wir am Men\u00fc erkennen, wo wir uns in unserer Anwendung gerade befinden. Wir gehen vor wie in Angular \u2192 Styles f\u00fcr aktive Routen beschrieben und nutzen die CSS-Klasse active des Semantic-UI-CSS-Frameworks . Wir f\u00fcgen also zwei Mal routerLinkActive=\"active\" in unsere app.component.html ein: app.component.html 1 2 3 4 5 < div class = \"ui menu\" > < a routerLink = \"home\" routerLinkActive = \"active\" class = \"item\" > Home </ a > < a routerLink = \"books\" routerLinkActive = \"active\" class = \"item\" > B\u00fccher </ a > </ div > < router-outlet ></ router-outlet > In unserer Navigationsleiste ist nun das jeweilige Element grau hinterlegt, je nachdem, wo wir uns befinden. Wir r\u00e4umen in unseren Komponenten noch ein wenig auf: in BookDetailsComponent haben wir bereits showListEvent , showBookList() , @Input() -Decorator und die entsprechenden Importe ( Input , Output und EventEmitter ) gel\u00f6scht in BookListComponent l\u00f6schen wir showDetailsEvent , showDetails() und die entsprechenden Importe ( Output und EventEmitter ) in AppComponent l\u00f6schen wir book , viewState , showList() , showDetails() und den Typ ViewState sowie den Import f\u00fcr Book book-details.component.ts import { Component , OnInit } from '@angular/core' ; import { Book } from '../shared/book' ; @ Component ({ selector : 'app-book-details' , templateUrl : './book-details.component.html' , styleUrls : [ './book-details.component.css' ] }) export class BookDetailsComponent implements OnInit { @ Input () book : Book ; @ Output () showListEvent = new EventEmitter < any > (); ngOnInit () { } getRating ( num : number ) { return new Array ( num ); } showBookList () { this . showListEvent . emit (); } } book-list.component.ts import { Component , OnInit } from '@angular/core' ; import { Book } from '../shared/book' ; import { BookStoreService } from '../shared/book-store.service' ; @ Component ({ selector : 'app-book-list' , templateUrl : './book-list.component.html' , styleUrls : [ './book-list.component.css' ] }) export class BookListComponent implements OnInit { books : Book []; constructor ( private bs : BookStoreService ) { } ngOnInit () : void { this . books = this . bs . getAll (); } } app.component.ts import { Component } from '@angular/core' ; @ Component ({ selector : 'app-root' , templateUrl : './app.component.html' , styleUrls : [ './app.component.css' ] }) export class AppComponent { } Success Der sechste Teil unserer B\u00fccher-App ist erstellt! Wir haben unsere Anwendung um ein Routing erg\u00e4nzt. Wir k\u00f6nnen Routen konfigurieren, parametrisierte Routen auslesen, Routen verlinken und aktive Links stylen. Die Zust\u00e4nde unserer Anwendung werden nun \u00fcber lesbare URL-Pfade abgebildet. RouterOutlets sind Platzhalter f\u00fcr die zu ladenden Komponenten. Kindkomponenten werden in das RouterOutlet der Elternkomponente geladen. Routen lassen sich so verschachteln.","title":"Aktive Links stylen und aufr\u00e4umen"},{"location":"css/","text":"CSS \u00b6 Selektoren \u00b6","title":"CSS"},{"location":"css/#css","text":"","title":"CSS"},{"location":"css/#selektoren","text":"","title":"Selektoren"},{"location":"html/","text":"HTML \u00b6 Einleitung \u00b6 HTML steht f\u00fcr H yper T ext M arkup L anguage. HTML ist eine sogenannte Auszeichnungssprache . Das bedeutet, dass Textelementen sogenannte Tags (HTML-Elemente) zugeordnet werden, um dem Text, der von einem solchen Tag umschlossen wird, eine Bedeutung zuzuweisen - der Text wird ausgezeichnet. Beispiel: < h1 > Gro\u00dfe \u00dcberschrift </ h1 > Im obigen Beispiel wurde der Text Gro\u00dfe \u00dcberschrift durch das HTML-Element h1 ausgezeichnet. Die Bedeutung dieses Elementes ist, dass es sich bei dem ausgezeichneten Text um eine \u00dcberschrift handelt. Es gibt 6 HTML-Elemente, die \u00dcberschriften charakterisieren: h1 , h2 , h3 , h4 , h5 , h6 . Die Nummern geben die Gr\u00f6\u00dfe der \u00dcberschrift an: h1 ist die gr\u00f6\u00dfte \u00dcberschrift, h6 die kleinste. Klicken Sie im folgenden Fenster auf den Reiter \"Result\" , um die Unterschiede zu sehen: Hierarchische Anordnung der HTML-Elemente \u00b6 HTML-Elemente bestehen - bis auf wenige Ausnahmen - aus einem Start-Tag <tag> und einem Ende-Tag </tag> (tag steht hier f\u00fcr den Namen eines beliebigen Elementes). Wird ein neues HTML-Element el2 innerhalb eines anderen HTML-Elementes el1 ge\u00f6ffnet, so muss el2 auch geschlossen werden, bevor el1 geschlossen wird. Success < el1 > diese Anordnung der < el2 > Elemente ist korrekt </ el2 > </ el1 > Failure < el1 > diese Anordnung der < el2 > Elemente ist falsch </ el1 > </ el2 > Es gibt nur wenige HTML-Elemente, die nicht aus einem Start- und einem Ende-Tag bestehen, sondern sogenannte stand-alone Tags sind. Ein typisches Beispiel ist der Zeilenumbruch <br> . Um einerseits zu symbolisieren, dass es sich um Start- und Ende-Tag in einem handelt, insbesondere aber, um XHTML -konform zu sein, geben wir f\u00fcr solche stand-alone Tags den Slash vor der schlie\u00dfenden spitzen Klammer an, d.h. wir schreiben <br /> . Grundger\u00fcst einer HTML-Seite \u00b6 Prinzipiell besteht eine HTML-Seite aus einem <head> - und einem <body> -Bereich. Im -Bereich k\u00f6nnen Metadaten \u00fcber die Seite definiert werden. Der <body> -Bereich definiert den sichtbaren Bereich der Seite, also das, was im Browser dargestellt wird. Eingeschlossen werden der <head> - und der <body> -Bereich von einem <html> -Element. <!DOCTYPE html> < html > < head > < title > Seitentitel </ title > </ head > < body > < h1 > Das ist eine gro\u00dfe \u00dcberschrift </ h1 > < p > Das ist ein Absatz. </ p > </ body > </ html > Das obige Beispiel zeigt ein Grundger\u00fcst einer HTML-Seite. <!DOCTYPE html> gibt dem Browser an, dass es sich um eine HTML-Datei handelt, die vom Browser \"gerendert\" , d.h. dargestellt wird. Der <head> -Bereich enth\u00e4lt in diesem Beispiel nur ein <title> -Element. Dieser Titel wird im Browser im Reiter (Tab) gezeigt. Au\u00dferdem wird der Titel in der Ergebnisliste einer Suchmaschine verwendet. Das <body> -Element, also der im Browser dargestellte Bereich, enth\u00e4lt eine \u00dcberschrift ( <h1> ) und einen Absatz ( <p> ). Aufgabe: Erstellen Sie eine Datei index.html und f\u00fcgen Sie obigen HTML-Code ein. Rufen Sie die Datei im Browser auf. Metadaten im Head \u00b6 Block- und Inline-Elemente \u00b6 Generell wird zwischen zwei Arten von HTML-Elementen unterschieden: Blockelemente Inline-Elemente Blockelemente verwenden die gesamte Breite der Browseransicht (des sogenannten Viewports ). Das bedeutet, dass ein Blockelement stets in einer neuen Zeile beginnt und neben einem Blockelement kein weiteres Element ist (sondern in einer neuen Zeile beginnt). Inline-Elemente nehmen genau so viel Breite ein, wie n\u00f6tig (Breite des Inhalts) und beginnen nicht in einer neuen Zeile und enden auch nicht mit einem Zeilenumbruch. Beispiele f\u00fcr Inline- und Blockelemente (Reiter \"Result\" w\u00e4hlen, um Ergebnis zu sehen): Eine \u00dcbersicht \u00fcber alle HTML-Elemente mit Erl\u00e4uterungen findet sich hier. Aufgabe: Erweitern Sie Ihre Datei index.html und f\u00fcgen Sie mindestens folgende Elemente ein: 2 verschiedene \u00dcberschriften ( h1 , ..., h6 ) eine nummerierte Liste (ordered list - ol ) mit 3 Eintr\u00e4gen (list items - li ) eine Strichpunktliste (unordered list - ul ) mit 3 Eintr\u00e4gen ( li ) eine Tabelle ( table ); diese besteht aus einem Tabellenkopf (table head - thead ) und einem Tabellenk\u00f6rper (table body - tbody ) der thead enth\u00e4lt eine Zeile (table row - tr ) als Tabellen\u00fcberschrift, wobei jede einzelne \u00dcberschrift (eine Spalte) als th definiert wird der tbody enth\u00e4lt mehrere Zeilen ( tr ); jede Zeile enth\u00e4lt so viele Dateneintr\u00e4ge (table data - td ) wie es Spalten gibt einen Hyperlink (anchor - a ), der ein Verweis auf die HTW-Seite enth\u00e4lt ein Bild (image - img ) Rufen Sie die Datei im Browser auf. Attribute \u00b6 Weitere Informationen \u00fcber HTML \u00b6 Folien HTML HTTP \u00b6 https://de.wikipedia.org/wiki/Hypertext_Transfer_Protocol URLs \u00b6","title":"HTML"},{"location":"html/#html","text":"","title":"HTML"},{"location":"html/#einleitung","text":"HTML steht f\u00fcr H yper T ext M arkup L anguage. HTML ist eine sogenannte Auszeichnungssprache . Das bedeutet, dass Textelementen sogenannte Tags (HTML-Elemente) zugeordnet werden, um dem Text, der von einem solchen Tag umschlossen wird, eine Bedeutung zuzuweisen - der Text wird ausgezeichnet. Beispiel: < h1 > Gro\u00dfe \u00dcberschrift </ h1 > Im obigen Beispiel wurde der Text Gro\u00dfe \u00dcberschrift durch das HTML-Element h1 ausgezeichnet. Die Bedeutung dieses Elementes ist, dass es sich bei dem ausgezeichneten Text um eine \u00dcberschrift handelt. Es gibt 6 HTML-Elemente, die \u00dcberschriften charakterisieren: h1 , h2 , h3 , h4 , h5 , h6 . Die Nummern geben die Gr\u00f6\u00dfe der \u00dcberschrift an: h1 ist die gr\u00f6\u00dfte \u00dcberschrift, h6 die kleinste. Klicken Sie im folgenden Fenster auf den Reiter \"Result\" , um die Unterschiede zu sehen:","title":"Einleitung"},{"location":"html/#hierarchische-anordnung-der-html-elemente","text":"HTML-Elemente bestehen - bis auf wenige Ausnahmen - aus einem Start-Tag <tag> und einem Ende-Tag </tag> (tag steht hier f\u00fcr den Namen eines beliebigen Elementes). Wird ein neues HTML-Element el2 innerhalb eines anderen HTML-Elementes el1 ge\u00f6ffnet, so muss el2 auch geschlossen werden, bevor el1 geschlossen wird. Success < el1 > diese Anordnung der < el2 > Elemente ist korrekt </ el2 > </ el1 > Failure < el1 > diese Anordnung der < el2 > Elemente ist falsch </ el1 > </ el2 > Es gibt nur wenige HTML-Elemente, die nicht aus einem Start- und einem Ende-Tag bestehen, sondern sogenannte stand-alone Tags sind. Ein typisches Beispiel ist der Zeilenumbruch <br> . Um einerseits zu symbolisieren, dass es sich um Start- und Ende-Tag in einem handelt, insbesondere aber, um XHTML -konform zu sein, geben wir f\u00fcr solche stand-alone Tags den Slash vor der schlie\u00dfenden spitzen Klammer an, d.h. wir schreiben <br /> .","title":"Hierarchische Anordnung der HTML-Elemente"},{"location":"html/#grundgerust-einer-html-seite","text":"Prinzipiell besteht eine HTML-Seite aus einem <head> - und einem <body> -Bereich. Im -Bereich k\u00f6nnen Metadaten \u00fcber die Seite definiert werden. Der <body> -Bereich definiert den sichtbaren Bereich der Seite, also das, was im Browser dargestellt wird. Eingeschlossen werden der <head> - und der <body> -Bereich von einem <html> -Element. <!DOCTYPE html> < html > < head > < title > Seitentitel </ title > </ head > < body > < h1 > Das ist eine gro\u00dfe \u00dcberschrift </ h1 > < p > Das ist ein Absatz. </ p > </ body > </ html > Das obige Beispiel zeigt ein Grundger\u00fcst einer HTML-Seite. <!DOCTYPE html> gibt dem Browser an, dass es sich um eine HTML-Datei handelt, die vom Browser \"gerendert\" , d.h. dargestellt wird. Der <head> -Bereich enth\u00e4lt in diesem Beispiel nur ein <title> -Element. Dieser Titel wird im Browser im Reiter (Tab) gezeigt. Au\u00dferdem wird der Titel in der Ergebnisliste einer Suchmaschine verwendet. Das <body> -Element, also der im Browser dargestellte Bereich, enth\u00e4lt eine \u00dcberschrift ( <h1> ) und einen Absatz ( <p> ). Aufgabe: Erstellen Sie eine Datei index.html und f\u00fcgen Sie obigen HTML-Code ein. Rufen Sie die Datei im Browser auf.","title":"Grundger\u00fcst einer HTML-Seite"},{"location":"html/#metadaten-im-head","text":"","title":"Metadaten im Head"},{"location":"html/#block-und-inline-elemente","text":"Generell wird zwischen zwei Arten von HTML-Elementen unterschieden: Blockelemente Inline-Elemente Blockelemente verwenden die gesamte Breite der Browseransicht (des sogenannten Viewports ). Das bedeutet, dass ein Blockelement stets in einer neuen Zeile beginnt und neben einem Blockelement kein weiteres Element ist (sondern in einer neuen Zeile beginnt). Inline-Elemente nehmen genau so viel Breite ein, wie n\u00f6tig (Breite des Inhalts) und beginnen nicht in einer neuen Zeile und enden auch nicht mit einem Zeilenumbruch. Beispiele f\u00fcr Inline- und Blockelemente (Reiter \"Result\" w\u00e4hlen, um Ergebnis zu sehen): Eine \u00dcbersicht \u00fcber alle HTML-Elemente mit Erl\u00e4uterungen findet sich hier. Aufgabe: Erweitern Sie Ihre Datei index.html und f\u00fcgen Sie mindestens folgende Elemente ein: 2 verschiedene \u00dcberschriften ( h1 , ..., h6 ) eine nummerierte Liste (ordered list - ol ) mit 3 Eintr\u00e4gen (list items - li ) eine Strichpunktliste (unordered list - ul ) mit 3 Eintr\u00e4gen ( li ) eine Tabelle ( table ); diese besteht aus einem Tabellenkopf (table head - thead ) und einem Tabellenk\u00f6rper (table body - tbody ) der thead enth\u00e4lt eine Zeile (table row - tr ) als Tabellen\u00fcberschrift, wobei jede einzelne \u00dcberschrift (eine Spalte) als th definiert wird der tbody enth\u00e4lt mehrere Zeilen ( tr ); jede Zeile enth\u00e4lt so viele Dateneintr\u00e4ge (table data - td ) wie es Spalten gibt einen Hyperlink (anchor - a ), der ein Verweis auf die HTW-Seite enth\u00e4lt ein Bild (image - img ) Rufen Sie die Datei im Browser auf.","title":"Block- und Inline-Elemente"},{"location":"html/#attribute","text":"","title":"Attribute"},{"location":"html/#weitere-informationen-uber-html","text":"Folien HTML","title":"Weitere Informationen \u00fcber HTML"},{"location":"html/#http","text":"https://de.wikipedia.org/wiki/Hypertext_Transfer_Protocol","title":"HTTP"},{"location":"html/#urls","text":"","title":"URLs"},{"location":"javascript/","text":"Type- und JavaScript \u00b6 JavaScript wurde 1995 von Brendan Eich entwickelt. Er arbeitete damals bei Netscape und entwickelte mit dem damals sogenannten LiveScript eine Skriptsprache f\u00fcr den damaligen Netscape-Browser. Ein damaliger Browser \"verstand\" HTML und CSS. HTML sah f\u00fcr Nutzerinteraktionen nur das Klicken auf Hyperlinks vor. Andere Nutzerinteraktionen waren nicht vorgesehen. Mithilfe von JavaScript wurde eine Schnittstelle geschaffen, um durch Nutzerinteraktionen den HTML-Code zu manipulieren, ohne dass ein weiteres Nachladen vom Webserver notwendig wurde. Mit der Einf\u00fchrung von JavaScript wurden die F\u00e4higkeiten von Browsern erweiteret, indem nun nicht mehr nur HTML und CSS interpriert wurde, sondern auch JavaScript - alles Client-seitig, also durch den Browser selbst. JavaScript ist eine sogenannte Skriptsprache , d.h. der Quellcode wird nicht compiliert und dann der \u00fcbersetzte Byte- oder Maschinencode ausgef\u00fchrt, sondern der Quellcode wird durch einen Interpreter interpretiert. Allerdings wird f\u00fcr Optimierungen JavaScript - insbesondere serverseitig in Node.js - durch sogenannte Engines doch in Maschinencode \u00fcbersetzt, welcher ausgef\u00fchrt wird. Die bekannteste dieser Engines ist die Google-Engine V8 . Die Technologie der Compilierung wird als Just-in-time-Kompilierung (JIT) bezeichnet. JavaScript kennt (im Gegensatz zu TypeScript) keine Klassen. Das Objektmodell von JavaScript basiert auf Prototypen . Eigenschaften und Methoden k\u00f6nnen zur Laufzeit den Objekten hinzugef\u00fcgt werden. Neben diesem dynamischen Objektmodell ist auch die Typisierung in JavaScript dynamisch. Der Typ einer Variable h\u00e4ngt vom Wert ab. Mit dem Wert kann sich auch der Typ der Variable \u00e4ndern. JavaScript \u00b6 var , let und const \u00b6 Mithilfe der Schl\u00fcsselw\u00f6rter var , let und const k\u00f6nnen in JavaScript Variablen deklariert werden. Wenn Sie eine Variable mit var deklarieren, dann ist diese Variable innerhalb der gesamten Funktion, in der Sie die Variable deklarieren, g\u00fcltig. Dagegen hat let nur eine Blockg\u00fcltigkeit , d.h. eine mit let deklarierte Variable ist nur in dem Anweisungsblock g\u00fcltig, in dem sie deklariert wurde. Eine mit let deklarierte Variable verh\u00e4lt sich also wie eine in Java deklarierte Variable. const wird zur Deklaration von Konstanten verwendet. Es ist zu bachten: Falls es sich bei der mit const deklarierten Konstante um eine Referenzvariable handelt (also auf ein Objekt oder Array zeigt), dann kann diese Variable ihre Referenz zwar nicht mehr \u00e4ndern, das jeweilige Objekt, auf das die Variable (konstant) zeigt, kann sich aber schon \u00e4ndern. Arrow-Funktionen \u00b6 Arrow-Funktionen werden auch als Lambda-Ausdr\u00fccke bezeichnet. Eine Arrow-Funktion ist eine Kurzschreibweise f\u00fcr eine anonyme Funktion. Anstelle von function() schreibt man nur noch einen Pfeil. Enth\u00e4lt die anonyme Funktion sogar nur ein Argument (Parameter), kann man links vom Pfeil sogar die runden Klammern weglassen. Auch die geschweiften Klammern des Funktionsk\u00f6rpers k\u00f6nnen entfallen. Wenn die geschweiften Klammwern weggelassen werden, dann entspricht die rechte Seite des Pfeils dem R\u00fcckgabewert der Funktion, d.h. es kann sogar return weggelassen werden. Folgende Funktionsdefinitionen sind \u00e4quivalent: function ( foo ) = { return foo + 1 ;} ( foo ) => { return foo + 1 ;} foo => { return foo + 1 ;} foo => foo + 1 ; Callback-Funktionen \u00b6 Eine Callback -Funktion ist eine Funktion, die einer anderen Funktion als Parameter \u00fcbergeben wird. Callback-Funktionen sind z.B. hier erl\u00e4utert. Darin finden Sie auch das folgende einfache Beispiel einer Callback-Funktion: 1 2 3 4 5 6 7 8 9 10 function greeting ( name ) { alert ( 'Hello ' + name ); } function processUserInput ( callback ) { var name = prompt ( 'Please enter your name.' ); callback ( name ); } processUserInput ( greeting ); In den Zeilen 1-3 wird eine Funktion greeting() definiert, welche einen name erwartet. Diese Funktion gibt Hello zusammen mit dem Namen in einem Alarmfenster aus. Die Funktion greeting() wird als Callback -Funktion in der Funktion processUserInput() (Zeilen 5-8) verwendet. Das hei\u00dft, die Funktion greeting() wird der Funktion processUserInput() als Parameter \u00fcbergeben. Innerhalb der Funktion processUserInput() hei\u00dft die Referenz auf die Funktion greeting() callback . Der Parametername kann beliebig gew\u00e4hlt werden. Wir die Funktion processUserInput() aufgerufen (Zeile 10) und die Funktion greeting() als Parameter \u00fcbergeben, dann erscheint zun\u00e4chst ein Eingabefenster, in dem der Name eingeben wird und dieser Name wird der greeting() -Funktion als Parameter \u00fcbergeben. Es erscheint das Alarmfenster mit der Ausgabe Hello plus dem Namen. Der Funktion processUserInput() k\u00f6nnte auch jede andere Funktion als Callback-Funktion \u00fcbergeben werden. JSON \u00b6 JavaScript Object Notation Promises \u00b6 Eine Promise ist das Ergebnis einer asynchronen Operation. Es gibt vier Status einer Promis (uns interessiert in der Regel nur resolved oder rejected ): Status Erkl\u00e4rung pending die Promise wartet noch auf die Beendigung der asynchronen Operation settled die asynchrone Operation wurde beendet resolved die asynchrone Operation wurde erfolgreich beendet rejected die asynchrone Operation ist fehlgeschlagen Um das Prinzip einer Promise zu erl\u00e4utern, schauen wir uns ein Beispiel aus Node.js \u2192 Eine Movie-Datenbank an: function getAll () { return new Promise (( resolve , reject ) => { const query = 'SELECT * FROM Movies' ; connection . query ( query , ( error , results ) => { if ( error ) reject ( error ); else resolve ( results ); }) }); } Die Funktion getAll() gibt eine Promise zur\u00fcck. Diese wird mit dem Konstruktor erzeugt. Dem Konstruktor wird eine Callback-Funktion \u00fcbergeben. Hier ist diese Funktion die Anfrage an die Datenbank connection.query() . Diese Funktion ist asynchron, d.h. sie wird ausgef\u00fchrt, ohne dass andere Funktionsaufrufe stoppen m\u00fcssen. Man kann auch sagen, dass die Promise die asynchrone Funktion kapselt . Die asynchrone Funktion enth\u00e4lt ebenfalls eine Callback-Funktion. Hier wurden als Parameternamen der Callback-Funktion error und results gew\u00e4hlt. Der erste Parameter wirft einen Fehler, wenn die asynchrone Funktion fehlschl\u00e4gt, der zweite Parameter enth\u00e4lt die Daten bei Erfolg. Mit reject gibt man den Fehler zur\u00fcck (im Fehlerfall) und mit resolve die Daten (im Erfolgsfall). return new Promise() Wir merken uns also: die getAll() -Funktion gibt ein Promise -Objekt zur\u00fcck. Wie kann eine solche Promise nun verwendet werden? Dazu schauen wir uns erneut das Beispiel aus Node.js \u2192 Eine Movie-Datenbank an: function listAction ( request , response ) { model . getAll (). then ( movies => response . send ( view ( movies )), error => response . send ( error ), ); } Der entscheidende Punkt ist, dass ein Promise-Objekt eine then -Methode besitzt. Dieser then -Methode k\u00f6nnen wiederum zwei Callback-Funktionen \u00fcbergeben werden. Die erste Funktion wird durch die resolve -Funktion der Promise aufgerufen, die zweite Funktion, falls die Promise die reject -Funktion aufruft. Werden der resolve - und der reject -Funktion Argumente \u00fcbergeben (so wie oben resolve(results) und reject(error) ), dann k\u00f6nnen diese Argumente in der jeweiligen Callback-Funktion ausgewertet werden ( results \u2192 movies bzw. error \u2192 error ). Die then -Funktion selbst gibt \u00fcbrigens wieder ein Promise -Objekt zur\u00fcck. Somit k\u00f6nnen mehrere Promises verkettet werden.","title":"JavaScript"},{"location":"javascript/#type-und-javascript","text":"JavaScript wurde 1995 von Brendan Eich entwickelt. Er arbeitete damals bei Netscape und entwickelte mit dem damals sogenannten LiveScript eine Skriptsprache f\u00fcr den damaligen Netscape-Browser. Ein damaliger Browser \"verstand\" HTML und CSS. HTML sah f\u00fcr Nutzerinteraktionen nur das Klicken auf Hyperlinks vor. Andere Nutzerinteraktionen waren nicht vorgesehen. Mithilfe von JavaScript wurde eine Schnittstelle geschaffen, um durch Nutzerinteraktionen den HTML-Code zu manipulieren, ohne dass ein weiteres Nachladen vom Webserver notwendig wurde. Mit der Einf\u00fchrung von JavaScript wurden die F\u00e4higkeiten von Browsern erweiteret, indem nun nicht mehr nur HTML und CSS interpriert wurde, sondern auch JavaScript - alles Client-seitig, also durch den Browser selbst. JavaScript ist eine sogenannte Skriptsprache , d.h. der Quellcode wird nicht compiliert und dann der \u00fcbersetzte Byte- oder Maschinencode ausgef\u00fchrt, sondern der Quellcode wird durch einen Interpreter interpretiert. Allerdings wird f\u00fcr Optimierungen JavaScript - insbesondere serverseitig in Node.js - durch sogenannte Engines doch in Maschinencode \u00fcbersetzt, welcher ausgef\u00fchrt wird. Die bekannteste dieser Engines ist die Google-Engine V8 . Die Technologie der Compilierung wird als Just-in-time-Kompilierung (JIT) bezeichnet. JavaScript kennt (im Gegensatz zu TypeScript) keine Klassen. Das Objektmodell von JavaScript basiert auf Prototypen . Eigenschaften und Methoden k\u00f6nnen zur Laufzeit den Objekten hinzugef\u00fcgt werden. Neben diesem dynamischen Objektmodell ist auch die Typisierung in JavaScript dynamisch. Der Typ einer Variable h\u00e4ngt vom Wert ab. Mit dem Wert kann sich auch der Typ der Variable \u00e4ndern.","title":"Type- und JavaScript"},{"location":"javascript/#javascript","text":"","title":"JavaScript"},{"location":"javascript/#var-let-und-const","text":"Mithilfe der Schl\u00fcsselw\u00f6rter var , let und const k\u00f6nnen in JavaScript Variablen deklariert werden. Wenn Sie eine Variable mit var deklarieren, dann ist diese Variable innerhalb der gesamten Funktion, in der Sie die Variable deklarieren, g\u00fcltig. Dagegen hat let nur eine Blockg\u00fcltigkeit , d.h. eine mit let deklarierte Variable ist nur in dem Anweisungsblock g\u00fcltig, in dem sie deklariert wurde. Eine mit let deklarierte Variable verh\u00e4lt sich also wie eine in Java deklarierte Variable. const wird zur Deklaration von Konstanten verwendet. Es ist zu bachten: Falls es sich bei der mit const deklarierten Konstante um eine Referenzvariable handelt (also auf ein Objekt oder Array zeigt), dann kann diese Variable ihre Referenz zwar nicht mehr \u00e4ndern, das jeweilige Objekt, auf das die Variable (konstant) zeigt, kann sich aber schon \u00e4ndern.","title":"var, let und const"},{"location":"javascript/#arrow-funktionen","text":"Arrow-Funktionen werden auch als Lambda-Ausdr\u00fccke bezeichnet. Eine Arrow-Funktion ist eine Kurzschreibweise f\u00fcr eine anonyme Funktion. Anstelle von function() schreibt man nur noch einen Pfeil. Enth\u00e4lt die anonyme Funktion sogar nur ein Argument (Parameter), kann man links vom Pfeil sogar die runden Klammern weglassen. Auch die geschweiften Klammern des Funktionsk\u00f6rpers k\u00f6nnen entfallen. Wenn die geschweiften Klammwern weggelassen werden, dann entspricht die rechte Seite des Pfeils dem R\u00fcckgabewert der Funktion, d.h. es kann sogar return weggelassen werden. Folgende Funktionsdefinitionen sind \u00e4quivalent: function ( foo ) = { return foo + 1 ;} ( foo ) => { return foo + 1 ;} foo => { return foo + 1 ;} foo => foo + 1 ;","title":"Arrow-Funktionen"},{"location":"javascript/#callback-funktionen","text":"Eine Callback -Funktion ist eine Funktion, die einer anderen Funktion als Parameter \u00fcbergeben wird. Callback-Funktionen sind z.B. hier erl\u00e4utert. Darin finden Sie auch das folgende einfache Beispiel einer Callback-Funktion: 1 2 3 4 5 6 7 8 9 10 function greeting ( name ) { alert ( 'Hello ' + name ); } function processUserInput ( callback ) { var name = prompt ( 'Please enter your name.' ); callback ( name ); } processUserInput ( greeting ); In den Zeilen 1-3 wird eine Funktion greeting() definiert, welche einen name erwartet. Diese Funktion gibt Hello zusammen mit dem Namen in einem Alarmfenster aus. Die Funktion greeting() wird als Callback -Funktion in der Funktion processUserInput() (Zeilen 5-8) verwendet. Das hei\u00dft, die Funktion greeting() wird der Funktion processUserInput() als Parameter \u00fcbergeben. Innerhalb der Funktion processUserInput() hei\u00dft die Referenz auf die Funktion greeting() callback . Der Parametername kann beliebig gew\u00e4hlt werden. Wir die Funktion processUserInput() aufgerufen (Zeile 10) und die Funktion greeting() als Parameter \u00fcbergeben, dann erscheint zun\u00e4chst ein Eingabefenster, in dem der Name eingeben wird und dieser Name wird der greeting() -Funktion als Parameter \u00fcbergeben. Es erscheint das Alarmfenster mit der Ausgabe Hello plus dem Namen. Der Funktion processUserInput() k\u00f6nnte auch jede andere Funktion als Callback-Funktion \u00fcbergeben werden.","title":"Callback-Funktionen"},{"location":"javascript/#json","text":"JavaScript Object Notation","title":"JSON"},{"location":"javascript/#promises","text":"Eine Promise ist das Ergebnis einer asynchronen Operation. Es gibt vier Status einer Promis (uns interessiert in der Regel nur resolved oder rejected ): Status Erkl\u00e4rung pending die Promise wartet noch auf die Beendigung der asynchronen Operation settled die asynchrone Operation wurde beendet resolved die asynchrone Operation wurde erfolgreich beendet rejected die asynchrone Operation ist fehlgeschlagen Um das Prinzip einer Promise zu erl\u00e4utern, schauen wir uns ein Beispiel aus Node.js \u2192 Eine Movie-Datenbank an: function getAll () { return new Promise (( resolve , reject ) => { const query = 'SELECT * FROM Movies' ; connection . query ( query , ( error , results ) => { if ( error ) reject ( error ); else resolve ( results ); }) }); } Die Funktion getAll() gibt eine Promise zur\u00fcck. Diese wird mit dem Konstruktor erzeugt. Dem Konstruktor wird eine Callback-Funktion \u00fcbergeben. Hier ist diese Funktion die Anfrage an die Datenbank connection.query() . Diese Funktion ist asynchron, d.h. sie wird ausgef\u00fchrt, ohne dass andere Funktionsaufrufe stoppen m\u00fcssen. Man kann auch sagen, dass die Promise die asynchrone Funktion kapselt . Die asynchrone Funktion enth\u00e4lt ebenfalls eine Callback-Funktion. Hier wurden als Parameternamen der Callback-Funktion error und results gew\u00e4hlt. Der erste Parameter wirft einen Fehler, wenn die asynchrone Funktion fehlschl\u00e4gt, der zweite Parameter enth\u00e4lt die Daten bei Erfolg. Mit reject gibt man den Fehler zur\u00fcck (im Fehlerfall) und mit resolve die Daten (im Erfolgsfall). return new Promise() Wir merken uns also: die getAll() -Funktion gibt ein Promise -Objekt zur\u00fcck. Wie kann eine solche Promise nun verwendet werden? Dazu schauen wir uns erneut das Beispiel aus Node.js \u2192 Eine Movie-Datenbank an: function listAction ( request , response ) { model . getAll (). then ( movies => response . send ( view ( movies )), error => response . send ( error ), ); } Der entscheidende Punkt ist, dass ein Promise-Objekt eine then -Methode besitzt. Dieser then -Methode k\u00f6nnen wiederum zwei Callback-Funktionen \u00fcbergeben werden. Die erste Funktion wird durch die resolve -Funktion der Promise aufgerufen, die zweite Funktion, falls die Promise die reject -Funktion aufruft. Werden der resolve - und der reject -Funktion Argumente \u00fcbergeben (so wie oben resolve(results) und reject(error) ), dann k\u00f6nnen diese Argumente in der jeweiligen Callback-Funktion ausgewertet werden ( results \u2192 movies bzw. error \u2192 error ). Die then -Funktion selbst gibt \u00fcbrigens wieder ein Promise -Objekt zur\u00fcck. Somit k\u00f6nnen mehrere Promises verkettet werden.","title":"Promises"},{"location":"node/","text":"Node.js \u00b6 Viele der folgenden Beispiele sind dem Buch Sebastian Springer: \"Node.js. Das umfassende Handbuch\" 3., aktualisierte und erweiterte Auflage 2018, Rheinwerk Computing, ISBN 978-3-8362-6255-2 Link entnommen (und nur unwesentlich ge\u00e4ndert). Installation \u00b6 Installationsanweisungen f\u00fcr Ihr Betriebssystem finden Sie auf der Node.js-Webseite https://nodejs.org/ . Nach der Installation k\u00f6nnen Sie \u00fcberpr\u00fcfen, ob node erfolgreich installiert wurde. Geben Sie dazu im Terminal node -v ein. Es sollte die Versionsnummer erscheinen, z.B. v13.3.0 . Da es sich bei JavaScript um eine Skriptsprache handelt, kann jede Anweisung durch den Interpreter interpretiert und ausgef\u00fchrt werden. Deshalb l\u00e4sst sich Node.js auch als im interaktiven Modus auf der Kommandozeile testen. Geben Sie dazu im Terminal node ein. Es erscheint etwas in der Art Welcome to Node.js v13.3.0. Type \".help\" for more information. > Node.js befindet sich dann im Read-Eval-Print-Loop (REPL) . Die im Terminal eingegebenen Kommandos werden gelesen ( read ), evaluiert ( eval ), ausgegeben ( print ) und auf das n\u00e4chste Kommando gewartet ( loop ). Geben Sie im Terminal console.log(\"Hello FIW!\"); ein. Es erscheint Hello FIW! undefined Sie verlassen REPL durch Eingabe von .exit . Success Somit ist Node.js installiert. Der erste eigene Webserver \u00b6 Wir verwenden Node.js, um einen Webserver zu implementieren. Insbesondere wird dieser Webserver Anfragen ( requests ) unserer Webanwendung (des Clients) empfangen und verarbeiten. Die Verarbeitung wird meistens ein Zugriff auf eine Datenbank sein. Als Antwort ( response ) wird der Webserver die angefragten Daten an unsere Anwendung zur\u00fccksenden. Wir werden nun unseren ersten einfachen Webserver mithilfe von Node.js implementieren. Erstellen Sie sich in Ihrem workspace ein Verzeichnis backend und darin eine Datei server.js (das kann nat\u00fcrlich alles auch anders hei\u00dfen). \u00d6ffnen Sie die Datei mit Ihrer IDE und geben Sie folgendes ein: server.js 1 2 3 4 5 6 7 8 9 10 11 const http = require ( 'http' ); const server = http . createServer ( function ( request , response ) { response . writeHead ( 200 , { 'content-type' : 'text/plain; charset=utf-8' }); response . write ( 'Hello ' ); response . end ( 'FIW!\\n' ); }); server . listen ( 8080 , function () { console . log ( 'Server is listening to http://localhost:8080' ); }); Wechseln Sie im Terminal in Ihr backend -Verzeichnis. Darin befindet sich die server.js . Geben Sie ein: node server.js Sie erhalten die Ausgabe Server is listening to http://localhost:8080 . Port bereits belegt Sollten Sie den Fehler Error: listen EADDRINUSE:::8080 erhalten, so ist der Port 8080 bei Ihnen bereits durch eine andere Anwendung belegt. Dann w\u00e4hlen Sie einen anderen Port, z.B. 8081 . Success Ihr Webserver l\u00e4uft nun! Dies k\u00f6nnen wir auf verschiedene Arten testen: Geben Sie http://localhost:8080 in Ihren Browser ein. Es erscheint Hello FIW! im Browser. Nutzen Sie curl und geben Sie im Terminal curl http://localhost:8080 ein. Es erscheint Hello FIW! im Terminal. Nutzen Sie 'Postman' und geben Sie in das Eingabefeld neben GET die URL http://localhost:8080 ein und klicken auf Send . Es erscheint Hello FIW! im unteren Teil des Fensters (Reiter Body ). Der Webserver l\u00e4uft nun so lange, bis wir ihn beenden. Wir betrachten das obige Listing im Detail. In Zeilennummer 1 wird das http -Modul von Node.js geladen und der Variablen http zugewiesen. Das Laden von Modulen erfolgt in Node.js mithilfe der Funktion require() . In Zeilennummer 3 wird ein Webserver mithilfe des http -Moduls erzeugt ( createServer() ). Das http -Modul bietet auch die M\u00f6glichkeit, einen Client zu erzeugen - aber das machen wir nicht mit Node.js sondern mit Angular. In Zeile 9 geben wir an, dass der Webserver nun permanent am Port 8080 auf Anfragen lauschen soll. Als 2. Parameter der listen() -Funktion h\u00e4tte auch ein HOST angegeben werden k\u00f6nnen, also die IP-Adresse des Webservers. Wird keine IP-Adresse angegeben, so wie hier, ist es in unserem Fall localhost . Dann folgt eine Callback -Funktion , die einen String auf die Konsole ausgibt, sobald die Verbindung steht. In den Zeilen 4 bis 6 ist die Antwort ( response ) des Webservers auf eine Anfrage ( request ) des Clients definiert. Die Funktion, die diese Antwort erstellt, ist eine Callback-Funktion der createServer -Funktion (in Zeile 3). Diese Callback-Funktion besitzt die beiden Parameter request und response . In diesem ersten Beispiel wird nur eine Response definiert. Diese besteht aus einem HTTP-Header ( writeHead() ) und einem HTTP-Body ( write() + end() ). Die Funktion writeHead() , die den HTTP-Header erzeugt, besitzt 2 Parameter. Der erste Parameter ist der HTTP-Status-Code . Der Status-Code 200 besagt, dass die Anfrage ( request ) vom Server empfangen wurde und die Antwort ( response ) in dieser Nachricht enthalten ist. Der eigentliche HTTP-Header wird mit dem zweiten Parameter \u00fcbertragen. In diesem Fall \u00fcbermittelt der Server dem Client die Informationen, dass es sich bei der Antwort um reinen Text handelt ( content-type:text-plain ) und dass der HTTP-Body unter Verwendung des Zeichensatzes UTF-8 ( charset=utf-8 ) kodiert ist. Der HTTP-Body wird mit der write() -Funktion \u00fcbertragen und mit der end() -Funktion abgeschlossen. In diesem Fall besteht der Body aus der Zeichenkette Hello FIW! . Eine Erweiterung der Antwort \u00b6 Im obigen Beispiel bestand die Antwort aus reinem Text. Wir erweitern die Antwort nun und senden vom Webserver an den Client als Body eine vollst\u00e4ndige HTML-Seite. server.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const http = require ( 'http' ); const server = http . createServer ( function ( request , response ) { response . writeHead ( 200 , { 'content-type' : 'text/html; charset=utf-8' }); const body = `<!DOCTYPE html> <html> <head> <meta charset=\"utf-8\"> <title>WebTech - Node.js</title> </head> <body> <h1 style=\"color:#76B900\">Hello FIW!</h1> </body> </html>` ; response . end ( body ); }); server . listen ( 8080 , function () { console . log ( 'Server is listening to http://localhost:8080' ); }); Achten Sie darauf, dass der content-type nun text/html ist, nicht mehr text/plain (Zeile 4). Sollte Ihr Server aus dem vorherigen Beispiel noch laufen, so m\u00fcssen Sie ihn zun\u00e4chst beenden. Geben Sie im Termina zum Beenden des Prozesses node server.js einfach Strg+C ( Ctrl+C ) und sarten Sie den Server unter Eingabe von node server.js erneut. Rufen Sie im Browser http://localhost:8080/ auf. Es erscheint Sie k\u00f6nnen ja auch mal den content-type erneut auf text/plain setzen und den Server erneut starten (1. Ctrl+C und 2. node server.js ), um zu sehen, welche Bedeutung die Angabe des content-type hat. Template-String \u00b6 Im obigen Beispiel ist der String body in Backtick-Zeichen ` eingeschlossen. Das nennt man Template-String und erm\u00f6glicht mithilfe von ${} Ausdr\u00fccke bzw. Variablen auszuwerten. Im Folgenden ist eine solche Verwendung einer Variable gezeigt. Template-String 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const http = require ( 'http' ); const server = http . createServer ( function ( request , response ) { response . writeHead ( 200 , { 'content-type' : 'text/html; charset=utf-8' }); const name = 'FIW!' ; const body = `<!DOCTYPE html> <html> <head> <meta charset=\"utf-8\"> <title>WebTech - Node.js</title> </head> <body> <h1 style=\"color:#76B900\">Hello ${ name } </h1> </body> </html>` ; response . end ( body ); }); server . listen ( 8080 , function () { console . log ( 'Server is listening to http://localhost:8080' ); }); In Zeile 6 wird eine Variable name definiert, der der String FIW! zugewiesen wird. In Zeile 14 wird mithilfe von ${ name } der Wert der Variable name in das HTML eingebunden, so dass der Inhalt der \u00dcberschrift <h1> zu Hello FIW! ausgewertet wird. URLs auswerten \u00b6 Eine URL kann um Schl\u00fcssel-Werte-Paare ( Parameter ) erweitert werden, um Daten mit der URL an den Webserver zu senden (siehe HTML \u2192 URLs ). Ein Schl\u00fcssel-Werte-Paar wird immer durch ein = verbunden: key = value Das erste Schl\u00fcssel-Werte-Paar wird hinter ein ? an die URL geh\u00e4ngt. Jedes weitere Paar wird mit einem & angebunden: http://www.example.org/?key1 = value1 & key2 = value2 & key3 = value3 Wir werden jetzt diese Parameter auswerten. Dazu laden wir einerseits ein weiteres Modul, n\u00e4mlich das url -Modul und wir werten die Anfrage ( request ) dahingehend aus, dass wir die Parameter der URL auswerten. server.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 const http = require ( 'http' ); const url = require ( 'url' ); const server = http . createServer ( function ( request , response ) { response . writeHead ( 200 , { 'content-type' : 'text/html; charset=utf-8' }); const parsedUrl = url . parse ( request . url , true ); const params = parsedUrl . query ; const body = `<!DOCTYPE html> <html> <head> <meta charset=\"utf-8\"> <title>WebTech - Node.js</title> </head> <body> <h1 style=\"color:#76B900\">Hello ${ params . name } in ${ params . ort } </h1> </body> </html>` ; response . end ( body ); }); server . listen ( 8080 , function () { console . log ( 'Server is listening to http://localhost:8080' ); }); Nach dem restart des Webservers (1. Ctrl+C und 2. node server.js ) und der Eingabe folgender URL: http://localhost:8080/?name=FIW&ort=Berlin wird im Browser Folgendes angezeigt: Chrome Developer Tools \u00b6 Die Chrome Developer Tools k\u00f6nnen auch zum Debuggen von Node.js-Anwendungen verwendet werden. Rufen Sie daf\u00fcr Ihre Node.js-Anwendung im Terminal mit dem --inspect -Flag auf: node --inspect server.js Im Terminal erscheint eine Ausgabe in der Form: Debugger listening on ws://127.0.0.1:9229/dc995a6a-61eb-4143-af7e-ac8e4599dcd7 For help, see: https://nodejs.org/en/docs/inspector Server is listening to http://localhost:8080 Im Chrome-Browser k\u00f6nnen Sie nun einerseits wie gewohnt die URL http://localhost:8080/?name=FIW&ort=Berlin eingeben, aber das Debuggen kann unter Eingabe der URL chrome://inspect/ erfolgen. Es erscheint folgende Seite im Browser: F\u00fcr weitere Informationen zum Debuggen siehe z.B. https://nodejs.org/en/docs/guides/debugging-getting-started/ . Success Wir haben mithilfe von Node.js einen ersten eigenen Webserver erstellt. Wir haben uns mit dem Konzept von Request und Response vertraut gemacht und eine eigene Response erstellt. Wir haben Argumente aus der URL ausgelesen und somit dynamisch unsere Response angepasst. Wir wollen nun zun\u00e4chst ein Framework kennenlernen, das uns manche Arbeiten erleichtert: Express. Express \u00b6 Express ist ein Node.js-Framework, das einerseits recht einfach gehalten wurde, andererseits aber alle wesentlichen Funktionen f\u00fcr eine Web-Anwendung bereith\u00e4lt. So m\u00fcssen wir uns beispielsweise bei der Verwendung von Express nicht mehr selbst um das Parsen der URL k\u00fcmmern. Wir werden im Folgenden ein kleines Projekt zu Verwaltung von Filmen erstellen. Dies geschieht mithilfe von npm . npm ist der Node package manager . Bisher enth\u00e4lt unser Ordner backend nur die Datei server.js . Das ist jedoch insofern noch kein wirkliches Node.js-Projekt, da es noch nicht vom Paketmanager, also npm verwaltet wird. Um dies zu tun wechseln wir in den Ordner backend und initialisieren dann unser Node.js-Projekt: im Ordner backend npm init Sie werden nun einige Sachen gefragt und k\u00f6nnen eigentlich immer jeweils mit Enter best\u00e4tigen. Es erfolgt also ungef\u00e4hr ein solcher Dialog im Terminal: % npm init This utility will walk you through creating a package.json file. It only covers the most common items, and tries to guess sensible defaults. See ` npm help init ` for definitive documentation on these fields and exactly what they do . Use ` npm install <pkg> ` afterwards to install a package and save it as a dependency in the package.json file. Press ^C at any time to quit. package name: ( backend ) backend version: ( 1 .0.0 ) description: Node.js-Backend entry point: ( server.js ) test command: git repository: keywords: author: license: ( ISC ) About to write to /Users/jornfreiheit/workspace/backend/package.json: { \"name\" : \"backend\" , \"version\" : \"1.0.0\" , \"description\" : \"Node.js-Backend\" , \"main\" : \"server.js\" , \"scripts\" : { \"test\" : \"echo \\\"Error: no test specified\\\" && exit 1\" , \"start\" : \"node server.js\" } , \"author\" : \"\" , \"license\" : \"ISC\" } Is this OK? ( yes ) Das wesentliche Ergebnis der Initialisierung ist die Erstellung der package.json -Datei. Darin k\u00f6nnen wir Paketabh\u00e4ngigkeiten definieren. Au\u00dferdem ist in dem Ordner backend ein Unterordner node_modules entstanden, der die Node.js-Module enth\u00e4lt, die wir ben\u00f6tigen. Als erstes installieren wir Express: npm install express Nun bauen wir uns eine kleine index.js -Datei, die unsere erste Express-Anwendung darstellt. 1 2 3 4 5 6 7 8 9 10 const express = require ( 'express' ); const app = express (); app . get ( '/' , ( req , res ) => { res . send ( 'My first express application' ); }); app . listen ( 8080 , () => { console . log ( 'Server listening on port 8080' ); }); In Zeile 1 wird das Express-Paket eingebunden. In Zeile 2 wird eine Express-App mit Basiskonfiguration erzeugt (hier ein app -Objekt). Die get() -Funktion des app -Objektes erzeugt eine Route, \u00fcber die man sich mit dem Browser mit der App verbinden kann (Zeilen 4 - 6 ). Als Response ( res ) wird einfach eine Zeichenkette gesendet ( send ). In den Zeilen 8 - 10 wird die App an den Port 8080 gebunden. Hier erfolgt intern die Erstellung eines Node.js-Servers mit http -Modul. Wenn Sie nun node index.js innerhalb des backend -Ordners aufrufen, wird der Node.js-Server erstellt und Sie k\u00f6nnen im Browser unter der URL localhost:8080 darauf zugreifen. Es erscheint: Im obigen Beispiel erkennt man in Zeile 4 zwei Parameter der Routing-Callback-Funktion innerhalb der app.get() -Methode: das Request -Objekt req und das Response -Objekt res . Beide Objekte geh\u00f6ren zu den elementaren Elementen einer Applikation. Request \u00b6 Die Eigenschaften des Request -Objektes req sind in https://expressjs.com/de/api.html#req erl\u00e4utert. Hier folgt eine kurze unvollst\u00e4ndige Auflistung: Eigenschaft Bedeutung method HTTP-Methode, mit der die Anfrage gesendet wurde (z.B. GET oder POST) originalUrl enth\u00e4lt die Anfrage-URL params enth\u00e4lt die variablen Anteile der Anfrage-URL protocol enth\u00e4lt das Protokoll der Anfrage (z.B. http oder https) query ist ein Objekt, das alle Parameter der Anfrage-URL enth\u00e4lt Response \u00b6 Die Eigenschaften des Response -Objektes res sind in https://expressjs.com/de/api.html#res erl\u00e4utert. Hier folgt eine kurze unvollst\u00e4ndige Auflistung: Methode Bedeutung get(field) gibt den Response-Header von field zur\u00fcck (z.B. get('Content-Type') ) set(field[,value]) setzt den Wert des angegebenen Header-Feldes json([body]) sendet eine JSON-Response ( [body] ist das JSON-Objekt) cookie(name,value[,options]) setzt einen Cookie-Wert name=value redirect([status,]path) Weiterleitung der Anfrage nach path status(code) setzt den Status der Antwort auf code send([body]) sendet die HTTP-Antwort end([data][,encoding]) beendet den Antwortprozess Router \u00b6 Wie man der API-Dokumentation von Express entnehmen kann, sind die Grundelemente einer Express-Anwendung die express() -Funktion , die die Express-Anwendung erstellt, die Eigenschaften und Methoden , die dieser Anwendung zur Verf\u00fcgung stehen, das Request -Objekt , das Response -Objekt sowie der Router . Mit Letzterem besch\u00e4ftigen wir uns jetzt. Unser Projekt soll folgende Struktur aufweisen: backend +---- movie | +---- model.js | +---- view.js | +---- controller.js | +---- movierouter.js +---- node_modules +---- index.js +---- package.json backend , movie und node_modules sind jeweils Ordner. node_modules wurde automatisch erzeugt (durch npm init und enth\u00e4lt alle eingebundenen Node.js-Pakete). Wir erstellen zun\u00e4chst die Datei movie/movierouter.js 1 und \"specken\" die index.js etwas ab (die get() -Funktion wird gel\u00f6scht). movie/movierouter.js 1 2 3 4 5 6 7 8 9 10 const express = require ( 'express' ); const router = express . Router (); const data = [ /* siehe Reiter \"const data\" */ ]; router . get ( '/' , ( req , res ) => { res . send ( data ); }); module . exports = router ; index.js 1 2 3 4 5 6 7 const express = require ( 'express' ); const app = express (); app . listen ( 8080 , () => { console . log ( 'Server listening on port 8080' ); }); const data 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const data = [ { id : 1 , title : 'Die Verurteilten' , year : '1994' }, { id : 2 , title : 'Der Pate' , year : '1972' }, { id : 3 , title : 'Der Pate 2' , year : '1974' }, { id : 4 , title : 'The Dark Knight' , year : '2008' }, { id : 5 , title : 'Die zw\u00f6lf Geschworenen' , year : '1957' }, { id : 6 , title : 'Schindlers Liste' , year : '1993' }, { id : 7 , title : 'Der Herr der Ringe: Die R\u00fcckkehr des K\u00f6nigs' , year : '2003' }, { id : 8 , title : 'Pulp Fiction' , year : '1994' }, { id : 9 , title : 'Zwei glorreiche Halunken' , year : '1966' }, { id : 10 , title : 'Fight Club' , year : '1999' }, { id : 11 , title : 'Der Herr der Ringe: Die Gef\u00e4hrten' , year : '2001' }, { id : 12 , title : 'Forrest Gump' , year : '1994' }, { id : 13 , title : 'Inception' , year : '2010' }, { id : 14 , title : 'Das Imperium schl\u00e4gt zur\u00fcck' , year : '1980' }, { id : 15 , title : 'Der Herr der Ringe: Die zwei T\u00fcrme' , year : '2002' }, { id : 16 , title : 'Matrix' , year : '1999' }, { id : 17 , title : 'GoodFellas \u2013 Drei Jahrzehnte in der Mafia' , year : '1990' }, { id : 18 , title : 'Einer flog \u00fcber das Kuckucksnest' , year : '1975' }, { id : 19 , title : 'Joker' , year : '2019' }, { id : 20 , title : 'Die sieben Samurai' , year : '1954' }, ]; Beachten Sie, dass in den obigen Listings aus Gr\u00fcnden der \u00dcbersichtlichkeit in der movie/movierouter.js das JSON-Objekt herausgel\u00f6scht und im Reiter \"const data\" zur Verf\u00fcgung gestellt wurde (muss dann hineinkopiert werden). In der movie/movierouter.js wird das Router -Objekt, das in Zeile 2 erzeugt wird, in Zeile 10 exportiert. Im Folgenden wird gezeigt, wie der Router nun in unsere Anwendung eingebunden wird. Dies passiert in der index.js . Die hinzugef\u00fcgten Zeilen sind markiert. index.js 1 2 3 4 5 6 7 8 9 10 11 12 const express = require ( 'express' ); const movieRouter = require ( './movie/movierouter' ); const app = express (); app . get ( '/' , ( req , res ) => res . redirect ( '/movie' )); app . use ( '/movie' , movieRouter ); app . listen ( 8080 , () => { console . log ( 'Server listening on port 8080' ); }); Beim Laden des Moduls wird die .js -Endung nicht mit angegeben. Das hei\u00dft, der Router wird aus der movie/movierouter.js -Datei mittels require('./movie/movierouter') geladen (siehe Zeile 2 ). W\u00e4re der Router sogar in einer Datei movie/index.js , m\u00fcsste dieser Name nicht angegeben werden, es w\u00fcrde also gen\u00fcgen, den Router \u00fcber den Pfad /movie zu laden (entspricht also /movie/index ). Die use() -Methode in Zeile 8 gibt an, dass der movieRouter (aus movie/index.js ) f\u00fcr das Routing des Pfades url /movie zust\u00e4ndig ist. Die get() -Methode aus Zeile 6 sorgt daf\u00fcr, dass der Aufruf url / (also z.B. localhost:8080 ) nach url /movie (also z.B. localhost:8080/movie ) weitergeleitet wird. Rufen Sie nun im backend -Ordner node index.js auf und geben Sie im Browser localhost:8080 ein. Beobachten Sie, dass auf die URL localhost:8080/movie weitergeleitet wird. Es erscheint im Browser (entweder parsed oder raw - Abh\u00e4ngig von Browser und Browser-Plugins): Model-View-Controller \u00b6 Bis jetzt steckt alles im Router ( /movie/movierouter.js ). Wir werden im ersten Schritt die Daten (die eigentlich zum Model geh\u00f6ren) und eine Aktion ( listAction ) im Controller ( movie/controller.js ) definieren. movie/controller.js 1 2 3 4 5 6 7 8 9 const data = [ /* siehe Reiter \"const data\" */ ]; function listAction ( request , response ) { response . send ( data ); } module . exports = { listAction , }; movie/movierouter.js 1 2 3 4 5 6 7 8 const express = require ( 'express' ); const router = express . Router (); const { listAction } = require ( './controller' ); router . get ( '/' , listAction ); module . exports = router ; const data 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const data = [ { id : 1 , title : 'Die Verurteilten' , year : '1994' }, { id : 2 , title : 'Der Pate' , year : '1972' }, { id : 3 , title : 'Der Pate 2' , year : '1974' }, { id : 4 , title : 'The Dark Knight' , year : '2008' }, { id : 5 , title : 'Die zw\u00f6lf Geschworenen' , year : '1957' }, { id : 6 , title : 'Schindlers Liste' , year : '1993' }, { id : 7 , title : 'Der Herr der Ringe: Die R\u00fcckkehr des K\u00f6nigs' , year : '2003' }, { id : 8 , title : 'Pulp Fiction' , year : '1994' }, { id : 9 , title : 'Zwei glorreiche Halunken' , year : '1966' }, { id : 10 , title : 'Fight Club' , year : '1999' }, { id : 11 , title : 'Der Herr der Ringe: Die Gef\u00e4hrten' , year : '2001' }, { id : 12 , title : 'Forrest Gump' , year : '1994' }, { id : 13 , title : 'Inception' , year : '2010' }, { id : 14 , title : 'Das Imperium schl\u00e4gt zur\u00fcck' , year : '1980' }, { id : 15 , title : 'Der Herr der Ringe: Die zwei T\u00fcrme' , year : '2002' }, { id : 16 , title : 'Matrix' , year : '1999' }, { id : 17 , title : 'GoodFellas \u2013 Drei Jahrzehnte in der Mafia' , year : '1990' }, { id : 18 , title : 'Einer flog \u00fcber das Kuckucksnest' , year : '1975' }, { id : 19 , title : 'Joker' , year : '2019' }, { id : 20 , title : 'Die sieben Samurai' , year : '1954' }, ]; Controller \u00b6 Der Controller verwaltet perspektivisch die View und das Model. Beides haben wir jetzt noch nicht. Zun\u00e4chst wird im Controller eine Aktion listAction definiert, die alle Daten in einer Response ( response.send(data) ) sendet 2 . Diese Aktion wird mittels exports anderen Modulen zur Verf\u00fcgung gestellt. Der Router ( movierouter.js ) wurde entsprechend angepasst. Einerseits haben wir die Daten aus dem Router entfernt, andererseits enth\u00e4lt die get() -Methode nun nicht mehr die direkte Implementierung (die ja in den Controller ausgelagert wurde), sondern ruft die Methode listAction des Controllers auf. Dazu muss sie eingebunden werden. Dies w\u00fcrde normalerweise wie folgt geschehen: const controller = require ( './controller' ); const listAction = controller . listAction ; Da ein solches Konstrukt h\u00e4ufig vorkommt, wurde ein sogenanntes destructuring eingef\u00fchrt. Obiger Code wird mithilfe von destructuring durch const { listAction } = require ( './controller' ); ersetzt und verzichtet somit auf die Hilfsvariable controller . Die Eigenschaft, die im Controller listAction hei\u00dft (und importiert wird), wird direkt geladen. Model \u00b6 Das Model ( movie/model.js ) verwaltet die Daten. Dazu werden wir zun\u00e4chst die Daten aus dem Controller in das Model verschieben. Au\u00dferdem stellt das Model eine Funktion ( getAll() ) zum Auslesen aller Daten zur Verf\u00fcgung: movie/model.js 1 2 3 4 5 6 7 const data = [ /* siehe Reiter \"const data\" */ ]; module . exports = { getAll () { return data ; }, }; movie/controller.js 1 2 3 4 5 6 7 8 9 const model = require ( './model' ); function listAction ( request , response ) { response . send ( model . getAll ()); } module . exports = { listAction , }; const data 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const data = [ { id : 1 , title : 'Die Verurteilten' , year : '1994' }, { id : 2 , title : 'Der Pate' , year : '1972' }, { id : 3 , title : 'Der Pate 2' , year : '1974' }, { id : 4 , title : 'The Dark Knight' , year : '2008' }, { id : 5 , title : 'Die zw\u00f6lf Geschworenen' , year : '1957' }, { id : 6 , title : 'Schindlers Liste' , year : '1993' }, { id : 7 , title : 'Der Herr der Ringe: Die R\u00fcckkehr des K\u00f6nigs' , year : '2003' }, { id : 8 , title : 'Pulp Fiction' , year : '1994' }, { id : 9 , title : 'Zwei glorreiche Halunken' , year : '1966' }, { id : 10 , title : 'Fight Club' , year : '1999' }, { id : 11 , title : 'Der Herr der Ringe: Die Gef\u00e4hrten' , year : '2001' }, { id : 12 , title : 'Forrest Gump' , year : '1994' }, { id : 13 , title : 'Inception' , year : '2010' }, { id : 14 , title : 'Das Imperium schl\u00e4gt zur\u00fcck' , year : '1980' }, { id : 15 , title : 'Der Herr der Ringe: Die zwei T\u00fcrme' , year : '2002' }, { id : 16 , title : 'Matrix' , year : '1999' }, { id : 17 , title : 'GoodFellas \u2013 Drei Jahrzehnte in der Mafia' , year : '1990' }, { id : 18 , title : 'Einer flog \u00fcber das Kuckucksnest' , year : '1975' }, { id : 19 , title : 'Joker' , year : '2019' }, { id : 20 , title : 'Die sieben Samurai' , year : '1954' }, ]; Die Funktion getAll() im Model ( movie/model.js ) wird jetzt direkt dort implementiert, wo sie auch exportiert wird. Die Implementierung h\u00e4tte man auch auf eine Variable legen k\u00f6nnen (wie listAction beim Controller) und dann exportieren. Der Controller ( movie/controller.js ) liest das Model ein (Zeile 1 ) und verwendet die getAll() -Funktion, um die Daten zu senden (Zeile 4 ). View \u00b6 Die View ist f\u00fcr die Darstellung verantwortlich. Sp\u00e4ter wird diese von uns in Angular umgesetzt. Hier wird es nur zur Verdeutlichung gezeigt. Wir verwenden JavaScript-Template-Strings (sozusagen eine Mischung aus JavaScript und HTML). Wer m\u00f6chte, kann diesen Abschnitt auch \u00fcberspringen, da wir sp\u00e4ter unsere Oberfl\u00e4che viel aufwendiger mit Angular gestalten. movie/view.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 module . exports = function render ( movies ) { return ` <!DOCTYPE html> <html lang=\"de\"> <head> <meta charset=\"UTF-8\"> <title>Movie-list</title> </head> <body> <table> <thead> <tr> <th>Id</th> <th>Title</th> </tr> </thead> <tbody> ${ movies . map ( movie => `<tr><td> ${ movie . id } </td> <td> ${ movie . title } </td></tr>` ). join ( '' ) } </tbody> </table> </body> </html> ` }; movie/controller.js 1 2 3 4 5 6 7 8 9 10 11 12 const model = require ( './model' ); const view = require ( './view' ); function listAction ( request , response ) { const movies = model . getAll (); const body = view ( movies ); response . send ( body ); } module . exports = { listAction , }; In der View ( movie/view.js ) wird also eine HTML-Tabelle ( <table> ) erzeugt. Der Funktion render werden die anzuzeigenden Daten als JSON-Array \u00fcbergeben. Die JavaScript-Funktion map() durchl\u00e4uft jeden einzelnen Eintrag des Arrays und speichert ihn jeweils in die Variable movie . Jeder movie wird in einer Tabllenzeile ( <tr> ) dargestellt und besteht aus einer id und einem title (siehe const data im Model). Auf diese Elemente wird zugegriffen und in einzelnen Dateneintr\u00e4gen der Tabelle ( <td> ) dargestellt. Die JavaScript-Funktion join() verbindet diese Struktur zu einem String (Konkatenation mit '' ), so dass der Template-String tats\u00e4chlich ein String ist. Im Controller ( movie/controller.js ) wird die View eingebunden (Zeile 2 ) und dieser View die Movie-Daten \u00fcbergeben, so dass body dann den durch movie.render() erzeugten String enth\u00e4lt (die HTML-Seite). Dieser wird als Response gesendet. Nach einem Neustart der Anwendung ( node index.js im Ordner backend ) erscheint im Browser ( localhost:8080 ) folgende Seite: Success Wir haben mit Express das bekannteste Node.js-Framework verwendet, um die Verarbeitung von Daten im Rahmen des Model-View-Controller-Konzeptes umzusetzen. Im obigen Beispiel haben wir die Daten (die Filme) direkt im JSON-Format im Model gespeichert. Das ist nat\u00fcrlich nicht flexibel. Wir werden die Daten nun in eine Datenbank auslagern. Anbindung von Datenbanken \u00b6 Wir wollen Node.js haupts\u00e4chlich daf\u00fcr verwenden, im Backend mit einer Datenbank zu kommunizieren. Wir wollen dies hier exemplarisch mit MySQL (siehe Werkzeuge \u2192 MySQL ) erl\u00e4utern. Die Verwendung von z.B. PostgreSQL ist \u00e4quivelent - Sie ben\u00f6tigen nur einen anderen Datenbanktreiber. Wir werden zun\u00e4chst das Node.js-Paket, das den mysql -Treiber enth\u00e4lt, installieren: npm install mysql Danach ist in der package.json die Abh\u00e4ngigkeit vom mysql -Paket hinterlegt (siehe \"dependencies\" ): package.json { \"name\" : \"backend\" , \"version\" : \"1.0.0\" , \"description\" : \"Node.js-Backend for MySQL\" , \"main\" : \"server.js\" , \"scripts\" : { \"test\" : \"echo \\\"Error: no test specified\\\" && exit 1\" , \"start\" : \"node server.js\" }, \"author\" : \"\" , \"license\" : \"ISC\" , \"dependencies\" : { \"mysql\" : \"^2.18.1\" } } Eine Movie-Datenbank \u00b6 Wir werden die Anbindung von Datenbanken exemplarisch an der Movie -Datenbank zeigen, die wir bereits im obigen Express -Abschnitt verwendet haben. Dazu erstellen wir uns eine Datenbank namens movie-db und bef\u00fcllen diese mit einigen Filmen (Tabelle Movie ). Sie k\u00f6nnen diese Datenbak auf verschiedenen Wegen erstellen. Am einfachsten ist es, wenn Sie phpMyadmin verwenden. Dort k\u00f6nnen Sie folgende SQL-Anfrage im Reiter SQL eingeben (Sie k\u00f6nnen auch im Terminal SQL -Anfragen eingeben nachdem Sie sich dort per mysql -u root -p mit dem MySQL-Server verbunden haben): CREATE DATABASE ` movie - db ` ; USE ` movie - db ` ; CREATE TABLE ` Movies ` ( ` id ` int ( 11 ) NOT NULL AUTO_INCREMENT , ` title ` varchar ( 255 ) DEFAULT NULL , ` year ` int ( 11 ) DEFAULT NULL , PRIMARY KEY ( ` id ` ) ) ENGINE = InnoDB DEFAULT CHARSET = utf8 ; INSERT INTO ` Movies ` ( ` title ` , ` year ` ) VALUES ( 'Die Verurteilten' , '1994' ), ( 'Der Pate' , '1972' ), ( 'Der Pate 2' , '1974' ), ( 'The Dark Knight' , '2008' ), ( 'Die zw\u00f6lf Geschworenen' , '1957' ), ( 'Schindlers Liste' , '1993' ), ( 'Der Herr der Ringe: Die R\u00fcckkehr des K\u00f6nigs' , '2003' ), ( 'Pulp Fiction' , '1994' ), ( 'Zwei glorreiche Halunken' , '1966' ), ( 'Fight Club' , '1999' ), ( 'Der Herr der Ringe: Die Gef\u00e4hrten' , '2001' ), ( 'Forrest Gump' , '1994' ), ( 'Inception' , '2010' ), ( 'Das Imperium schl\u00e4gt zur\u00fcck' , '1980' ), ( 'Der Herr der Ringe: Die zwei T\u00fcrme' , '2002' ), ( 'Matrix' , '1999' ), ( 'GoodFellas \u2013 Drei Jahrzehnte in der Mafia' , '1990' ), ( 'Einer flog \u00fcber das Kuckucksnest' , '1975' ), ( 'Joker' , '2019' ), ( 'Die sieben Samurai' , '1954' ); Wir verwenden das Projekt, das wir bereits im obigen Express -Abschnitt verwendet haben, also die Dateien aus backend : backend +---- movie | +---- model.js | +---- view.js | +---- controller.js | +---- movierouter.js +---- node_modules +---- index.js +---- package.json Zun\u00e4chst \u00e4ndern wir die movie/model.js . Darin werden nun nicht mehr die Daten gehalten, sondern die Verbindung zur Datenbank aufgebaut. Au\u00dferdem sehen wir 4 Funktionen zur Datenverwaltung vor, wovon wir eine ( getAll() ) gleich implementieren 3 : movie/model.js const mysql = require ( 'mysql' ); const connection = mysql . createConnection ({ host : 'localhost' , user : 'root' , password : 'password' , /* hier muss Ihr Passwort hin */ database : 'movie-db' , }); connection . connect (); function getAll () { return new Promise (( resolve , reject ) => { const query = 'SELECT * FROM Movies' ; connection . query ( query , ( error , results ) => { if ( error ) reject ( error ); else resolve ( results ); }) }); } module . exports = { getAll , }; movie/controller.js const model = require ( './model' ); const view = require ( './view' ); function listAction ( request , response ) { model . getAll (). then ( movies => { response . send ( view ( movies )); }, error => response . send ( error ), ); } module . exports = { listAction , }; Im Model ( /movie/model.js ) wird zun\u00e4chst die Verbindung zur Datenbank aufgebaut (Zeilen 2-7 und connection.connect() ). Die getAll() -Funktion stellt mithilfe von connection.query() eine Anfrage an die Datenbank (erster Parameter der connection.query() -Funktion). In unserem Beispiel ist die Anfrage die SQL-Query SELECT * FROM Movies . Die getAll() -Funktion gibt ein Promise -Objekt zur\u00fcck. Promises werden in JavaScript\u2192Promises erl\u00e4utert. Im Controller ( /movie/controller.js ) wird das Promise -Objekt in der then -Funktion ausgewertet. Wird in der Promise die resolve -Methode aufgerufen, werden die results \u00fcbergeben, also das Ergebnis der Datenbankanfrage. Diese Werte werden in der ersten Callback-Funktion der then -Methode dem Parameter movies \u00fcbergeben. Soll nur das JSON gesendet werden, wird die view nicht ben\u00f6tigt (statt response.send(view(movies)); gen\u00fcgt dann response.send(movies); ). Hier kapselt die View die Daten noch in einen HTML-Template-String. Im Falle eines Fehlers ruft die Promise die reject -Funktion auf und \u00fcbergibt den Parameter error . Diese Funktion ruft dann in der then -Funktion die zweite Callback-Funktion f\u00fcr die Fehlerauswertung auf. Success Wir haben jetzt eine MySQL-datenbank angebunden und die Anbindung anhand einer getAll() -Funktion, die alle in der Datenbank gespeicherten Filme zur\u00fcckgibt, gezeigt. Wir haben somit einen lesenden Zugriff auf alle Datenbankeintr\u00e4ge realisiert. Im folgenden werden wir auch weitere Zugriffe (create, update, delete) umsetzen. Allerdings haben wir bisher auch eine View mithilfe von Node.js erstellt und verwendet. Die Idee im folgenden ist, dass unser Backend nicht mehr f\u00fcr die Darstellung zust\u00e4ndig ist, sondern die Ergebnisse der Datenbankabfragen im JSON-Format zur\u00fcckgibt. Unser mit Angular erstelltes Frontend soll f\u00fcr die Darstellung zust\u00e4ndig sein. Wir stellen unser Backend vollst\u00e4ndig auf das REST-Konzept um. Unser Backend als reiner REST-Server \u00b6 Representional State Transfer (REST) ist ein Architekturkonzept und wird in vielen Webanwendungen verwendet. REST beschreibt die Schnittstelle zwischen Frontend und Backend und ist dabei sehr stark an HTTP angelehnt: jede Ressource wird \u00fcber eine eindeutige URL aufgerufen (z.B. alle Filme \u00fcber localhost:8080/movies , den Film mit der id=3 \u00fcber localhost:8080/movie/3 ) es wird definiert, mit welcher HTTP-Anfrage auf die Ressource zugegriffen wird (z.B. get zum Lesen, post zum Anlegen, put zum \u00c4ndern von Ressourcen) jede Anfrage ist zustandslos, d.h. eine Anfrage muss alle notwendigen Informationen beinhalten und fr\u00fchere Anfragen (und deren Responses) werden nicht gespeichert Wir werden unsere View im Backend von nun an also nicht mehr ben\u00f6tigen. Unser Projekt sieht derzeit so aus: index.js const express = require ( 'express' ); const movieRouter = require ( './movie/movierouter' ); const app = express (); app . get ( '/' , ( req , res ) => res . redirect ( '/movie' )); app . use ( '/movie' , movieRouter ); app . listen ( 8080 , () => { console . log ( 'Server listening on port 8080' ); }); movie/model.js const mysql = require ( 'mysql' ); const connection = mysql . createConnection ({ host : 'localhost' , user : 'root' , password : 'password' , /* hier muss Ihr Passwort hin */ database : 'movie-db' , }); connection . connect (); function getAll () { return new Promise (( resolve , reject ) => { const query = 'SELECT * FROM Movies' ; connection . query ( query , ( error , results ) => { if ( error ) reject ( error ); else resolve ( results ); }) }); } module . exports = { getAll , }; movie/controller.js const model = require ( './model' ); function listAction ( request , response ) { model . getAll (). then ( movies => { response . send ( movies ); }, error => response . send ( error ), ); } module . exports = { listAction , }; movie/movierouter.js const express = require ( 'express' ); const router = express . Router (); const { listAction } = require ( './controller' ); router . get ( '/' , listAction ); module . exports = router ; Geben wir also die die URL localhost:8080 an, dann passiert folgendes: die Route wird weitergeleitet an localhost:8080/movie (siehe in index.js die Anweisung app.get('/', (req, res) => res.redirect('/movie')); ) dadurch wird der movie/movierouter.js aufgerufen und dieser ruft die Funktion listAction auf listAction ruft die Promise auf, die in der Funktion model.getAll() definiert wird in getAll() erfolgt eine Anfrage an die Datenbank wird diese Anfrage erfolgreich ausgef\u00fchrt, ruft die Promise die resolve -Funktion auf und \u00fcbergibt alle Resultate der Anfrage in listAction werden diese Resultate als Resonse gesendet Wir rufen Postman zum Testen dieser Anfrage auf und geben localhost:8080 in das URL-Feld ein und senden die Anfrage mittels GET -Methode ab. Es erscheint: Das gleiche Ergebnis bekommen wir, wenn wir als URL localhost:8080/movie eingeben (darauf wird ja eh umgeleitet). Wir k\u00f6nnen die Ausgabe auch mithilfe von curl testen: % curl http://localhost:8080/movie [{ \"id\" :1, \"title\" : \"Die Verurteilten\" , \"year\" :1994 } , { \"id\" :2, \"title\" : \"Der Pate\" , \"year\" :1972 } , { \"id\" :3, \"title\" : \"Der Pate 2\" , \"year\" :1974 } , { \"id\" :4, \"title\" : \"The Dark Knight\" , \"year\" :2008 } , { \"id\" :5, \"title\" : \"Die zw\u00f6lf Geschworenen\" , \"year\" :1957 } , { \"id\" :6, \"title\" : \"Schindlers Liste\" , \"year\" :1993 } , { \"id\" :7, \"title\" : \"Der Herr der Ringe: Die R\u00fcckkehr des K\u00f6nigs\" , \"year\" :2003 } , { \"id\" :8, \"title\" : \"Pulp Fiction\" , \"year\" :1994 } , { \"id\" :9, \"title\" : \"Zwei glorreiche Halunken\" , \"year\" :1966 } , { \"id\" :10, \"title\" : \"Fight Club\" , \"year\" :1999 } , { \"id\" :11, \"title\" : \"Der Herr der Ringe: Die Gef\u00e4hrten\" , \"year\" :2001 } , { \"id\" :12, \"title\" : \"Forrest Gump\" , \"year\" :1994 } , { \"id\" :13, \"title\" : \"Inception\" , \"year\" :2010 } , { \"id\" :14, \"title\" : \"Das Imperium schl\u00e4gt zur\u00fcck\" , \"year\" :1980 } , { \"id\" :15, \"title\" : \"Der Herr der Ringe: Die zwei T\u00fcrme\" , \"year\" :2002 } , { \"id\" :16, \"title\" : \"Matrix\" , \"year\" :1999 } , { \"id\" :17, \"title\" : \"GoodFellas \u2013 Drei Jahrzehnte in der Mafia\" , \"year\" :1990 } , { \"id\" :18, \"title\" : \"Einer flog \u00fcber das Kuckucksnest\" , \"year\" :1975 } , { \"id\" :19, \"title\" : \"Joker\" , \"year\" :2019 } , { \"id\" :20, \"title\" : \"Die sieben Samurai\" , \"year\" :1954 }] Wir erweitern unsere Schnittstelle zun\u00e4chst um die Ansicht eines einzelnen Films. Wir wollen nun mit der URL http://localhost:8080/movie/3 den Film angezeigt bekommen, der die id 3 hat. Wir wollen also die URLs um die Angabe einer id erweitern und f\u00fcr diesen Endpunkt den entsprechenden Film zur\u00fcckgesendet bekommen. Dazu erweitern wir (untem im Listing jeweils gelb markiert) die movie/model.js um eine Funktion getOne(id) ; das Model stellt nach au\u00dfen die Funktion get(id) zur Verf\u00fcgung, die als Response den Film sendet, der die entsprechende id hat, die movie/controller.js um eine Funktion detailAction() , die den Parameter id aus der URL ausliest und die Funktion model.get(id) aufruft, den movie/movierouter.js um eine weitere Route, n\u00e4mlich router.get('/:id', detailAction); , so dass eine id an die URL geh\u00e4ngt werden kann und f\u00fcr diesen Fall die detailAction aufgerufen wird movie/model.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 const mysql = require ( 'mysql' ); const connection = mysql . createConnection ({ host : 'localhost' , user : 'root' , password : 'password' , /* hier muss Ihr Passwort hin */ database : 'movie-db' , }); connection . connect (); function getAll () { return new Promise (( resolve , reject ) => { const query = 'SELECT * FROM Movies' ; connection . query ( query , ( error , results ) => { if ( error ) reject ( error ); else resolve ( results ); }) }); } function getOne ( id ) { return new Promise (( resolve , reject ) => { const query = 'SELECT * FROM Movies WHERE id=?' ; connection . query ( query , [ id ], ( error , results ) => { if ( error ) reject ( error ); else resolve ( results [ 0 ]); }); }); } module . exports = { getAll , get ( id ) { return getOne ( id )}, }; movie/controller.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const model = require ( './model' ); function listAction ( request , response ) { model . getAll (). then ( movies => { response . send ( movies ); }, error => response . send ( error ), ); } function detailAction ( request , response ) { model . get ( request . params . id ). then ( movie => response . send ( movie ), error => response . send ( error ), ); } module . exports = { listAction , detailAction , }; movie/movierouter.js 1 2 3 4 5 6 7 8 const express = require ( 'express' ); const router = express . Router (); const { listAction , detailAction } = require ( './controller' ); router . get ( '/' , listAction ); router . get ( '/:id' , detailAction ); module . exports = router ; Content-Type und Fehlerbehandlung \u00b6 Zwar senden wir bereits die Resultate der Requests als JSON zur\u00fcck, jedoch ist der content-type unserer Response noch content-type:text/html , da wir die Response mithilfe der send() -Funktion senden ( response.send() ). Wir \u00e4ndern dies in response.json() . Dadurch teilen wir dem Client mit, dass der gesendetete content-type ein JSON ist ( content-type:application/json ). F\u00fcr eine erfolgreiche Bearbeitung eines Requests wird mit der Response der HTTP-Statuscode 200 gesendet. F\u00fcr den Fehlerfall wollen wir nun daf\u00fcr sorgen, dass der HTTP-Statuscode 500 - Internal Server Error \u00fcbertragen wird. Dies erreichen wir im Fehlerfall mit error => response.status(500).json(error) . Unser Controller sieht nun also so aus: movie/controller.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const model = require ( './model' ); function listAction ( request , response ) { model . getAll (). then ( movies => { response . json ( movies ); }, error => response . status ( 500 ). json ( error ), ); } function detailAction ( request , response ) { model . get ( request . params . id ). then ( movie => response . json ( movie ), error => response . status ( 500 ). json ( error ), ); } module . exports = { listAction , detailAction , }; POST - einen neuen Datensatz anlegen \u00b6 Um einen neuen Datensatz anzulegen, m\u00fcssen wir zwei Dinge beachten: die HTTP-Anfrage ist POST (anstelle von GET , das wir zum Lesen verwenden) der Request \u00fcbergibt im Body den neuen Datensatz (als JSON) \u2192 dazu ben\u00f6tigen wir das Paket body-parser von Node.js und nutzen davon die json() -Funktion zum Einlesen des neuen Datensatzes im JSON-Format Wir passen zun\u00e4chst die index.js entsprechend an: index.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const express = require ( 'express' ); const bodyParser = require ( 'body-parser' ); const movieRouter = require ( './movie/movierouter' ); const app = express (); app . use ( bodyParser . json ()); app . get ( '/' , ( req , res ) => res . redirect ( '/movie' )); app . use ( '/movie' , movieRouter ); app . listen ( 8080 , () => { console . log ( 'Server listening on port 8080' ); }); Um nun einen neuen Datensatz in der Datenbank anzulegen, erweitern wir unser Projekt wie folgt: in movie/model.js wird eine insert() -Funktion definiert, welche durch eine save() -Funktion aufgerufen wird ( save() wird nach au\u00dfen zur Verf\u00fcgung gestellt 4 ), in movie/controller.js wird eine createAction() definiert, die den neuen Datensatz aus dem request,body ausliest und die model.save() aufruft, in movie/movierouter.js wird der neue Endpunkt router.post('/', createAction); festgelegt movie/model.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 const mysql = require ( 'mysql' ); const connection = mysql . createConnection ({ host : 'localhost' , user : 'root' , password : 'password' , /* hier muss Ihr Passwort hin */ database : 'movie-db' , }); connection . connect (); function getAll () { /* bleibt so */ } function getOne ( id ) { /* bleibt so */ } function insert ( movie ) { return new Promise (( resolve , reject ) => { const query = 'INSERT INTO Movies (title, year) VALUES (?, ?)' ; connection . query ( query , [ movie . title , movie . year ], ( error , results ) => { if ( error ) reject ( error ); else resolve ( results ); }); }); } module . exports = { getAll , get ( id ) { return getOne ( id )}, save ( movie ) { if ( ! movie . id ) return insert ( movie ); }, }; movie/controller.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const model = require ( './model' ); function listAction ( request , response ) { /* bleibt so */ } function detailAction ( request , response ) { /* bleibt so */ } function createAction ( request , response ) { const movie = { id : request . body . id , title : request . body . title , year : request . body . year , }; model . save ( movie ). then ( newMovie => response . status ( 201 ). json ( newMovie ), error => response . status ( 500 ). json ( error ), ); } module . exports = { listAction , detailAction , createAction , }; movie/movierouter.js 1 2 3 4 5 6 7 8 9 const express = require ( 'express' ); const router = express . Router (); const { listAction , detailAction , createAction } = require ( './controller' ); router . get ( '/' , listAction ); router . get ( '/:id' , detailAction ); router . post ( '/' , createAction ); module . exports = router ; Die Funktionen im Model haben alle den gleichen Aufbau. Es wird eine Promise erzeugt und mithilfe von connection.query() eine Anfrage an die Datenbank gestellt. Im Erfolgsfall wird die resolve() -Funktion der Promise aufgerufen, im Fehlerfall die reject() -Funktion. Im Controller wird der request verarbeitet und eine response erzeugt. Im Router werden die Endpunkte und die dazugeh\u00f6rigen HTTP-Methoden (z.B. get oder post ) definiert. Um die createAction -Funktion zu testen, rufen wir Postman auf und tragen in die URL http://localhost:8080/movie/ ein. Wichtig: es muss nun POST ausgew\u00e4hlt werden. Mit dem Request \u00fcbergeben wir im Body nun ein JSON, das einen neuen Film enth\u00e4lt, d.h. das JSON muss die Eigensc haften title und year enthalten (nicht id , denn diese wird automatisch durch das Datenbanksystem erzeugt). Die Anfrage sieht in Postman wie folgt aus: Es kann auch mit curl getestet werden: curl -X POST -H \"Content-Type: application/json\" -d '{\"title\": \"Noch ein Test\", \"year\": \"2019\"}' http://localhost:8080/movie { \"fieldCount\" :0, \"affectedRows\" :1, \"insertId\" :23, \"serverStatus\" :2, \"warningCount\" :0, \"message\" : \"\" , \"protocol41\" :true, \"changedRows\" :0 } PUT - einen Datensatz \u00e4ndern \u00b6 Das \u00c4ndern eines Datensatzes erfolgt in \u00e4hnlicher Weise wie das Anlegen eines Datensatzes. Es wird im Body der Anfrage das neue JSON gesendet und der Content-Type der Anfrage ist application/json (im Header gesetzt). Zum \u00c4ndern eines Datensatzes wird die HTTP-Methode put verwendet. Um nun einen Datensatz in der Datenbank zu \u00e4ndern, erweitern wir unser Projekt wie folgt: in movie/model.js wird eine update() -Funktion definiert, welche durch die save() -Funktion aufgerufen wird ( save() wird nach au\u00dfen zur Verf\u00fcgung gestellt), in movie/controller.js wird eine updateAction() definiert, die genauso aussieht wie die createAction() , au\u00dfer dass die id aus der URL ausgelesen wird und nicht aus dem Request-Body in movie/movierouter.js wird der neue Endpunkt router.put('/', updateActionAction); festgelegt movie/model.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const mysql = require ( 'mysql' ); const connection = mysql . createConnection ({ host : 'localhost' , user : 'root' , password : 'password' , /* hier muss Ihr Passwort hin */ database : 'movie-db' , }); connection . connect (); function getAll () { /* bleibt so */ } function getOne ( id ) { /* bleibt so */ } function insert ( movie ) { /* bleibt so */ } function update ( movie ) { return new Promise (( resolve , reject ) => { const query = 'UPDATE Movies SET title = ?, year = ? WHERE id = ?' ; connection . query ( query , [ movie . title , movie . year , movie . id ], ( error , results ) => { if ( error ) reject ( error ); else resolve ( results ); }); }); } module . exports = { getAll , get ( id ) { return getOne ( id )}, save ( movie ) { if ( ! movie . id ) return insert ( movie ); else return update ( movie ); }, }; movie/controller.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 const model = require ( './model' ); function listAction ( request , response ) { /* bleibt so */ } function detailAction ( request , response ) { /* bleibt so */ } function createAction ( request , response ) { /* bleibt so */ } function updateAction ( request , response ) { const movie = { id : request . params . id , title : request . body . title , year : request . body . year , }; model . save ( movie ). then ( movie => response . status ( 201 ). json ( movie ), error => response . status ( 500 ). json ( error ), ); } module . exports = { listAction , detailAction , createAction , updateAction , }; movie/movierouter.js 1 2 3 4 5 6 7 8 9 10 const express = require ( 'express' ); const router = express . Router (); const { listAction , detailAction , createAction , updateAction } = require ( './controller' ); router . get ( '/' , listAction ); router . get ( '/:id' , detailAction ); router . post ( '/' , createAction ); router . put ( '/:id' , updateAction ); module . exports = router ; Um die Update-Funktion in Postman auszuprobieren, geben Sie als URL z.B. http://localhost:8080/movie/3 ein (um den Film mit der id=3 zu \u00e4ndern) und w\u00e4hlen als HTTP-Methode PUT . Im Request-Body geben Sie dann z.B. { \"title\" : \"Der Pate 3\" , \"year\" : \"1990\" } ein. Sie erhalten: Nat\u00fcrlich k\u00f6nnen Sie zum Testen auch curl verwenden. Die Anfrage ist \u00e4hnlich zur POST -Anfrage, nur mit curl -X PUT . DELETE - einen Datensatz \u00e4ndern \u00b6 Um einen Datensatz zu l\u00f6schen, w\u00e4hlen wir die HTTP-Methode DELETE . Alles andere bleibt wie gehabt. Wir pr\u00e4sentieren gleich die L\u00f6sung: movie/model.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 const mysql = require ( 'mysql' ); const connection = mysql . createConnection ({ host : 'localhost' , user : 'root' , password : 'password' , /* hier muss Ihr Passwort hin */ database : 'movie-db' , }); connection . connect (); function getAll () { /* bleibt so */ } function getOne ( id ) { /* bleibt so */ } function insert ( movie ) { /* bleibt so */ } function update ( movie ) { /* bleibt so */ } function remove ( id ) { return new Promise (( resolve , reject ) => { const query = 'DELETE FROM Movies WHERE id = ?' ; connection . query ( query , [ id ], ( error , results ) => { if ( error ) reject ( error ); else resolve ( results [ 0 ]); }); }); } module . exports = { getAll , get ( id ) { return getOne ( id )}, save ( movie ) { if ( ! movie . id ) return insert ( movie ); else return update ( movie ); }, delete ( id ) { return remove ( id )}, }; movie/controller.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 const model = require ( './model' ); function listAction ( request , response ) { /* bleibt so */ } function detailAction ( request , response ) { /* bleibt so */ } function createAction ( request , response ) { /* bleibt so */ } function updateAction ( request , response ) { /* bleibt so */ } function deleteAction ( request , response ) { const id = parseInt ( request . params . id , 10 ); model . delete ( id ) . then ( () => response . status ( 204 ). send (), error => response . status ( 500 ). json ( error ) ); } module . exports = { listAction , detailAction , createAction , updateAction , deleteAction }; movie/movierouter.js 1 2 3 4 5 6 7 8 9 10 11 const express = require ( 'express' ); const router = express . Router (); const { listAction , detailAction , createAction , updateAction , deleteAction } = require ( './controller' ); router . get ( '/' , listAction ); router . get ( '/:id' , detailAction ); router . post ( '/' , createAction ); router . put ( '/:id' , updateAction ); router . delete ( '/:id' , deleteAction ); module . exports = router ; Success Wir haben nun eine vollst\u00e4ndige REST-Schnittstelle des Backends implementiert. Es k\u00f6nnen alle Datens\u00e4tze oder ein Datensatz gelesen ( read mithilfe von get ), ein Datensatz erzeugt ( create mithilfe von post ), ein Datensatz aktualisiert ( update mithilfe von put ) und ein Datensatz gel\u00f6scht ( delete mithilfe von delete ) werden. JSON Web Tokens zur Authentifizierung \u00b6 Unsere Backend-Schnittstelle ist bis jetzt offen f\u00fcr jeden, d.h. jeder, der die Endpunkte kennt, kann die Ressourcen abfragen und somit Daten auslesen, l\u00f6schen, \u00e4ndern usw. Das kann nat\u00fcrlich nicht richtig sein, insbesondere wenn mit sensiblen Daten gearbeitet wird. Wir k\u00f6nnen im Backend auch nicht ein Anmeldeformular vorsehen, da das Backend nur Services anbietet. Au\u00dferdem ist die Kommunikation mit der REST-Schnittstelle zustandslos, d.h. es kann gar nicht gespeichert werden, ob eine Nutzerin bereits angemeldet ist oder nicht. Eine L\u00f6sung f\u00fcr diese Probleme sind JSON Web Tokens (JWT) . Ein JWT ist eine codierte Zeichenkette, die einen Header enth\u00e4lt, einen Payload und eine Signatur. Hier ein Screenshot der jwt.io-Webseite mit einem Beispiel daf\u00fcr: Datenbank und Model \u00b6 Wir erzeugen zun\u00e4chst eine Tabelle in unserer Datenbank, um Nutzername und zugeh\u00f6riges Passwort zu speichern. Erzeugen eines JWT \u00b6 F\u00fcr die Erzeugung eines JWT verwenden wir das Nodes-Paket jsonwebtoken . Dieses installieren wir im Ordner backend mit dem Befehl npm install jsonwebtoken Wir erstellen uns eine Route, \u00fcber die die Benutzer ihre Anmeldedaten an das Backend schicken k\u00f6nnen Die Bezeichnung movierouter.js f\u00fcr diese Datei ist hier noch verwirrend, da sie zun\u00e4chst auch die Daten enthalten wird. Wir werden nach und nach die Funktionen so gestalten und auslagern, dass die Datei nur noch den Router enth\u00e4lt und f\u00fcr alles andere ein Model, eine View und ein Controller entstehen werden. \u21a9 Beachten Sie auch hier wieder, dass aus Gr\u00fcnden der \u00dcbersichtlichkeit die Daten in den Reiter const data ausgelagert wurden. Die m\u00fcssen Sie hineinkopieren. \u21a9 Achten Sie darauf, Ihr korrektes Passwort einzutragen. \u21a9 Wir werden die save() -Funktion sp\u00e4ter noch erweitern. Beim Anlegen eines neuen Datensatzes werden zwar der Titel und das Entstehungsjahr des Films mitgesendet, nicht jedoch die id . Die id wird durch das Datenbanksystems vergeben. F\u00fcr den Fall, dass der save() -Funktion auch die id des Films mitgegeben wird, gehen wir davon aus, dass der Film in der Datenbank aktualisiert ( update() ) wird, sich also ein Eintrag ge\u00e4ndert hat. \u21a9","title":"Node.js"},{"location":"node/#nodejs","text":"Viele der folgenden Beispiele sind dem Buch Sebastian Springer: \"Node.js. Das umfassende Handbuch\" 3., aktualisierte und erweiterte Auflage 2018, Rheinwerk Computing, ISBN 978-3-8362-6255-2 Link entnommen (und nur unwesentlich ge\u00e4ndert).","title":"Node.js"},{"location":"node/#installation","text":"Installationsanweisungen f\u00fcr Ihr Betriebssystem finden Sie auf der Node.js-Webseite https://nodejs.org/ . Nach der Installation k\u00f6nnen Sie \u00fcberpr\u00fcfen, ob node erfolgreich installiert wurde. Geben Sie dazu im Terminal node -v ein. Es sollte die Versionsnummer erscheinen, z.B. v13.3.0 . Da es sich bei JavaScript um eine Skriptsprache handelt, kann jede Anweisung durch den Interpreter interpretiert und ausgef\u00fchrt werden. Deshalb l\u00e4sst sich Node.js auch als im interaktiven Modus auf der Kommandozeile testen. Geben Sie dazu im Terminal node ein. Es erscheint etwas in der Art Welcome to Node.js v13.3.0. Type \".help\" for more information. > Node.js befindet sich dann im Read-Eval-Print-Loop (REPL) . Die im Terminal eingegebenen Kommandos werden gelesen ( read ), evaluiert ( eval ), ausgegeben ( print ) und auf das n\u00e4chste Kommando gewartet ( loop ). Geben Sie im Terminal console.log(\"Hello FIW!\"); ein. Es erscheint Hello FIW! undefined Sie verlassen REPL durch Eingabe von .exit . Success Somit ist Node.js installiert.","title":"Installation"},{"location":"node/#der-erste-eigene-webserver","text":"Wir verwenden Node.js, um einen Webserver zu implementieren. Insbesondere wird dieser Webserver Anfragen ( requests ) unserer Webanwendung (des Clients) empfangen und verarbeiten. Die Verarbeitung wird meistens ein Zugriff auf eine Datenbank sein. Als Antwort ( response ) wird der Webserver die angefragten Daten an unsere Anwendung zur\u00fccksenden. Wir werden nun unseren ersten einfachen Webserver mithilfe von Node.js implementieren. Erstellen Sie sich in Ihrem workspace ein Verzeichnis backend und darin eine Datei server.js (das kann nat\u00fcrlich alles auch anders hei\u00dfen). \u00d6ffnen Sie die Datei mit Ihrer IDE und geben Sie folgendes ein: server.js 1 2 3 4 5 6 7 8 9 10 11 const http = require ( 'http' ); const server = http . createServer ( function ( request , response ) { response . writeHead ( 200 , { 'content-type' : 'text/plain; charset=utf-8' }); response . write ( 'Hello ' ); response . end ( 'FIW!\\n' ); }); server . listen ( 8080 , function () { console . log ( 'Server is listening to http://localhost:8080' ); }); Wechseln Sie im Terminal in Ihr backend -Verzeichnis. Darin befindet sich die server.js . Geben Sie ein: node server.js Sie erhalten die Ausgabe Server is listening to http://localhost:8080 . Port bereits belegt Sollten Sie den Fehler Error: listen EADDRINUSE:::8080 erhalten, so ist der Port 8080 bei Ihnen bereits durch eine andere Anwendung belegt. Dann w\u00e4hlen Sie einen anderen Port, z.B. 8081 . Success Ihr Webserver l\u00e4uft nun! Dies k\u00f6nnen wir auf verschiedene Arten testen: Geben Sie http://localhost:8080 in Ihren Browser ein. Es erscheint Hello FIW! im Browser. Nutzen Sie curl und geben Sie im Terminal curl http://localhost:8080 ein. Es erscheint Hello FIW! im Terminal. Nutzen Sie 'Postman' und geben Sie in das Eingabefeld neben GET die URL http://localhost:8080 ein und klicken auf Send . Es erscheint Hello FIW! im unteren Teil des Fensters (Reiter Body ). Der Webserver l\u00e4uft nun so lange, bis wir ihn beenden. Wir betrachten das obige Listing im Detail. In Zeilennummer 1 wird das http -Modul von Node.js geladen und der Variablen http zugewiesen. Das Laden von Modulen erfolgt in Node.js mithilfe der Funktion require() . In Zeilennummer 3 wird ein Webserver mithilfe des http -Moduls erzeugt ( createServer() ). Das http -Modul bietet auch die M\u00f6glichkeit, einen Client zu erzeugen - aber das machen wir nicht mit Node.js sondern mit Angular. In Zeile 9 geben wir an, dass der Webserver nun permanent am Port 8080 auf Anfragen lauschen soll. Als 2. Parameter der listen() -Funktion h\u00e4tte auch ein HOST angegeben werden k\u00f6nnen, also die IP-Adresse des Webservers. Wird keine IP-Adresse angegeben, so wie hier, ist es in unserem Fall localhost . Dann folgt eine Callback -Funktion , die einen String auf die Konsole ausgibt, sobald die Verbindung steht. In den Zeilen 4 bis 6 ist die Antwort ( response ) des Webservers auf eine Anfrage ( request ) des Clients definiert. Die Funktion, die diese Antwort erstellt, ist eine Callback-Funktion der createServer -Funktion (in Zeile 3). Diese Callback-Funktion besitzt die beiden Parameter request und response . In diesem ersten Beispiel wird nur eine Response definiert. Diese besteht aus einem HTTP-Header ( writeHead() ) und einem HTTP-Body ( write() + end() ). Die Funktion writeHead() , die den HTTP-Header erzeugt, besitzt 2 Parameter. Der erste Parameter ist der HTTP-Status-Code . Der Status-Code 200 besagt, dass die Anfrage ( request ) vom Server empfangen wurde und die Antwort ( response ) in dieser Nachricht enthalten ist. Der eigentliche HTTP-Header wird mit dem zweiten Parameter \u00fcbertragen. In diesem Fall \u00fcbermittelt der Server dem Client die Informationen, dass es sich bei der Antwort um reinen Text handelt ( content-type:text-plain ) und dass der HTTP-Body unter Verwendung des Zeichensatzes UTF-8 ( charset=utf-8 ) kodiert ist. Der HTTP-Body wird mit der write() -Funktion \u00fcbertragen und mit der end() -Funktion abgeschlossen. In diesem Fall besteht der Body aus der Zeichenkette Hello FIW! .","title":"Der erste eigene Webserver"},{"location":"node/#eine-erweiterung-der-antwort","text":"Im obigen Beispiel bestand die Antwort aus reinem Text. Wir erweitern die Antwort nun und senden vom Webserver an den Client als Body eine vollst\u00e4ndige HTML-Seite. server.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const http = require ( 'http' ); const server = http . createServer ( function ( request , response ) { response . writeHead ( 200 , { 'content-type' : 'text/html; charset=utf-8' }); const body = `<!DOCTYPE html> <html> <head> <meta charset=\"utf-8\"> <title>WebTech - Node.js</title> </head> <body> <h1 style=\"color:#76B900\">Hello FIW!</h1> </body> </html>` ; response . end ( body ); }); server . listen ( 8080 , function () { console . log ( 'Server is listening to http://localhost:8080' ); }); Achten Sie darauf, dass der content-type nun text/html ist, nicht mehr text/plain (Zeile 4). Sollte Ihr Server aus dem vorherigen Beispiel noch laufen, so m\u00fcssen Sie ihn zun\u00e4chst beenden. Geben Sie im Termina zum Beenden des Prozesses node server.js einfach Strg+C ( Ctrl+C ) und sarten Sie den Server unter Eingabe von node server.js erneut. Rufen Sie im Browser http://localhost:8080/ auf. Es erscheint Sie k\u00f6nnen ja auch mal den content-type erneut auf text/plain setzen und den Server erneut starten (1. Ctrl+C und 2. node server.js ), um zu sehen, welche Bedeutung die Angabe des content-type hat.","title":"Eine Erweiterung der Antwort"},{"location":"node/#template-string","text":"Im obigen Beispiel ist der String body in Backtick-Zeichen ` eingeschlossen. Das nennt man Template-String und erm\u00f6glicht mithilfe von ${} Ausdr\u00fccke bzw. Variablen auszuwerten. Im Folgenden ist eine solche Verwendung einer Variable gezeigt. Template-String 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const http = require ( 'http' ); const server = http . createServer ( function ( request , response ) { response . writeHead ( 200 , { 'content-type' : 'text/html; charset=utf-8' }); const name = 'FIW!' ; const body = `<!DOCTYPE html> <html> <head> <meta charset=\"utf-8\"> <title>WebTech - Node.js</title> </head> <body> <h1 style=\"color:#76B900\">Hello ${ name } </h1> </body> </html>` ; response . end ( body ); }); server . listen ( 8080 , function () { console . log ( 'Server is listening to http://localhost:8080' ); }); In Zeile 6 wird eine Variable name definiert, der der String FIW! zugewiesen wird. In Zeile 14 wird mithilfe von ${ name } der Wert der Variable name in das HTML eingebunden, so dass der Inhalt der \u00dcberschrift <h1> zu Hello FIW! ausgewertet wird.","title":"Template-String"},{"location":"node/#urls-auswerten","text":"Eine URL kann um Schl\u00fcssel-Werte-Paare ( Parameter ) erweitert werden, um Daten mit der URL an den Webserver zu senden (siehe HTML \u2192 URLs ). Ein Schl\u00fcssel-Werte-Paar wird immer durch ein = verbunden: key = value Das erste Schl\u00fcssel-Werte-Paar wird hinter ein ? an die URL geh\u00e4ngt. Jedes weitere Paar wird mit einem & angebunden: http://www.example.org/?key1 = value1 & key2 = value2 & key3 = value3 Wir werden jetzt diese Parameter auswerten. Dazu laden wir einerseits ein weiteres Modul, n\u00e4mlich das url -Modul und wir werten die Anfrage ( request ) dahingehend aus, dass wir die Parameter der URL auswerten. server.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 const http = require ( 'http' ); const url = require ( 'url' ); const server = http . createServer ( function ( request , response ) { response . writeHead ( 200 , { 'content-type' : 'text/html; charset=utf-8' }); const parsedUrl = url . parse ( request . url , true ); const params = parsedUrl . query ; const body = `<!DOCTYPE html> <html> <head> <meta charset=\"utf-8\"> <title>WebTech - Node.js</title> </head> <body> <h1 style=\"color:#76B900\">Hello ${ params . name } in ${ params . ort } </h1> </body> </html>` ; response . end ( body ); }); server . listen ( 8080 , function () { console . log ( 'Server is listening to http://localhost:8080' ); }); Nach dem restart des Webservers (1. Ctrl+C und 2. node server.js ) und der Eingabe folgender URL: http://localhost:8080/?name=FIW&ort=Berlin wird im Browser Folgendes angezeigt:","title":"URLs auswerten"},{"location":"node/#chrome-developer-tools","text":"Die Chrome Developer Tools k\u00f6nnen auch zum Debuggen von Node.js-Anwendungen verwendet werden. Rufen Sie daf\u00fcr Ihre Node.js-Anwendung im Terminal mit dem --inspect -Flag auf: node --inspect server.js Im Terminal erscheint eine Ausgabe in der Form: Debugger listening on ws://127.0.0.1:9229/dc995a6a-61eb-4143-af7e-ac8e4599dcd7 For help, see: https://nodejs.org/en/docs/inspector Server is listening to http://localhost:8080 Im Chrome-Browser k\u00f6nnen Sie nun einerseits wie gewohnt die URL http://localhost:8080/?name=FIW&ort=Berlin eingeben, aber das Debuggen kann unter Eingabe der URL chrome://inspect/ erfolgen. Es erscheint folgende Seite im Browser: F\u00fcr weitere Informationen zum Debuggen siehe z.B. https://nodejs.org/en/docs/guides/debugging-getting-started/ . Success Wir haben mithilfe von Node.js einen ersten eigenen Webserver erstellt. Wir haben uns mit dem Konzept von Request und Response vertraut gemacht und eine eigene Response erstellt. Wir haben Argumente aus der URL ausgelesen und somit dynamisch unsere Response angepasst. Wir wollen nun zun\u00e4chst ein Framework kennenlernen, das uns manche Arbeiten erleichtert: Express.","title":"Chrome Developer Tools"},{"location":"node/#express","text":"Express ist ein Node.js-Framework, das einerseits recht einfach gehalten wurde, andererseits aber alle wesentlichen Funktionen f\u00fcr eine Web-Anwendung bereith\u00e4lt. So m\u00fcssen wir uns beispielsweise bei der Verwendung von Express nicht mehr selbst um das Parsen der URL k\u00fcmmern. Wir werden im Folgenden ein kleines Projekt zu Verwaltung von Filmen erstellen. Dies geschieht mithilfe von npm . npm ist der Node package manager . Bisher enth\u00e4lt unser Ordner backend nur die Datei server.js . Das ist jedoch insofern noch kein wirkliches Node.js-Projekt, da es noch nicht vom Paketmanager, also npm verwaltet wird. Um dies zu tun wechseln wir in den Ordner backend und initialisieren dann unser Node.js-Projekt: im Ordner backend npm init Sie werden nun einige Sachen gefragt und k\u00f6nnen eigentlich immer jeweils mit Enter best\u00e4tigen. Es erfolgt also ungef\u00e4hr ein solcher Dialog im Terminal: % npm init This utility will walk you through creating a package.json file. It only covers the most common items, and tries to guess sensible defaults. See ` npm help init ` for definitive documentation on these fields and exactly what they do . Use ` npm install <pkg> ` afterwards to install a package and save it as a dependency in the package.json file. Press ^C at any time to quit. package name: ( backend ) backend version: ( 1 .0.0 ) description: Node.js-Backend entry point: ( server.js ) test command: git repository: keywords: author: license: ( ISC ) About to write to /Users/jornfreiheit/workspace/backend/package.json: { \"name\" : \"backend\" , \"version\" : \"1.0.0\" , \"description\" : \"Node.js-Backend\" , \"main\" : \"server.js\" , \"scripts\" : { \"test\" : \"echo \\\"Error: no test specified\\\" && exit 1\" , \"start\" : \"node server.js\" } , \"author\" : \"\" , \"license\" : \"ISC\" } Is this OK? ( yes ) Das wesentliche Ergebnis der Initialisierung ist die Erstellung der package.json -Datei. Darin k\u00f6nnen wir Paketabh\u00e4ngigkeiten definieren. Au\u00dferdem ist in dem Ordner backend ein Unterordner node_modules entstanden, der die Node.js-Module enth\u00e4lt, die wir ben\u00f6tigen. Als erstes installieren wir Express: npm install express Nun bauen wir uns eine kleine index.js -Datei, die unsere erste Express-Anwendung darstellt. 1 2 3 4 5 6 7 8 9 10 const express = require ( 'express' ); const app = express (); app . get ( '/' , ( req , res ) => { res . send ( 'My first express application' ); }); app . listen ( 8080 , () => { console . log ( 'Server listening on port 8080' ); }); In Zeile 1 wird das Express-Paket eingebunden. In Zeile 2 wird eine Express-App mit Basiskonfiguration erzeugt (hier ein app -Objekt). Die get() -Funktion des app -Objektes erzeugt eine Route, \u00fcber die man sich mit dem Browser mit der App verbinden kann (Zeilen 4 - 6 ). Als Response ( res ) wird einfach eine Zeichenkette gesendet ( send ). In den Zeilen 8 - 10 wird die App an den Port 8080 gebunden. Hier erfolgt intern die Erstellung eines Node.js-Servers mit http -Modul. Wenn Sie nun node index.js innerhalb des backend -Ordners aufrufen, wird der Node.js-Server erstellt und Sie k\u00f6nnen im Browser unter der URL localhost:8080 darauf zugreifen. Es erscheint: Im obigen Beispiel erkennt man in Zeile 4 zwei Parameter der Routing-Callback-Funktion innerhalb der app.get() -Methode: das Request -Objekt req und das Response -Objekt res . Beide Objekte geh\u00f6ren zu den elementaren Elementen einer Applikation.","title":"Express"},{"location":"node/#request","text":"Die Eigenschaften des Request -Objektes req sind in https://expressjs.com/de/api.html#req erl\u00e4utert. Hier folgt eine kurze unvollst\u00e4ndige Auflistung: Eigenschaft Bedeutung method HTTP-Methode, mit der die Anfrage gesendet wurde (z.B. GET oder POST) originalUrl enth\u00e4lt die Anfrage-URL params enth\u00e4lt die variablen Anteile der Anfrage-URL protocol enth\u00e4lt das Protokoll der Anfrage (z.B. http oder https) query ist ein Objekt, das alle Parameter der Anfrage-URL enth\u00e4lt","title":"Request"},{"location":"node/#response","text":"Die Eigenschaften des Response -Objektes res sind in https://expressjs.com/de/api.html#res erl\u00e4utert. Hier folgt eine kurze unvollst\u00e4ndige Auflistung: Methode Bedeutung get(field) gibt den Response-Header von field zur\u00fcck (z.B. get('Content-Type') ) set(field[,value]) setzt den Wert des angegebenen Header-Feldes json([body]) sendet eine JSON-Response ( [body] ist das JSON-Objekt) cookie(name,value[,options]) setzt einen Cookie-Wert name=value redirect([status,]path) Weiterleitung der Anfrage nach path status(code) setzt den Status der Antwort auf code send([body]) sendet die HTTP-Antwort end([data][,encoding]) beendet den Antwortprozess","title":"Response"},{"location":"node/#router","text":"Wie man der API-Dokumentation von Express entnehmen kann, sind die Grundelemente einer Express-Anwendung die express() -Funktion , die die Express-Anwendung erstellt, die Eigenschaften und Methoden , die dieser Anwendung zur Verf\u00fcgung stehen, das Request -Objekt , das Response -Objekt sowie der Router . Mit Letzterem besch\u00e4ftigen wir uns jetzt. Unser Projekt soll folgende Struktur aufweisen: backend +---- movie | +---- model.js | +---- view.js | +---- controller.js | +---- movierouter.js +---- node_modules +---- index.js +---- package.json backend , movie und node_modules sind jeweils Ordner. node_modules wurde automatisch erzeugt (durch npm init und enth\u00e4lt alle eingebundenen Node.js-Pakete). Wir erstellen zun\u00e4chst die Datei movie/movierouter.js 1 und \"specken\" die index.js etwas ab (die get() -Funktion wird gel\u00f6scht). movie/movierouter.js 1 2 3 4 5 6 7 8 9 10 const express = require ( 'express' ); const router = express . Router (); const data = [ /* siehe Reiter \"const data\" */ ]; router . get ( '/' , ( req , res ) => { res . send ( data ); }); module . exports = router ; index.js 1 2 3 4 5 6 7 const express = require ( 'express' ); const app = express (); app . listen ( 8080 , () => { console . log ( 'Server listening on port 8080' ); }); const data 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const data = [ { id : 1 , title : 'Die Verurteilten' , year : '1994' }, { id : 2 , title : 'Der Pate' , year : '1972' }, { id : 3 , title : 'Der Pate 2' , year : '1974' }, { id : 4 , title : 'The Dark Knight' , year : '2008' }, { id : 5 , title : 'Die zw\u00f6lf Geschworenen' , year : '1957' }, { id : 6 , title : 'Schindlers Liste' , year : '1993' }, { id : 7 , title : 'Der Herr der Ringe: Die R\u00fcckkehr des K\u00f6nigs' , year : '2003' }, { id : 8 , title : 'Pulp Fiction' , year : '1994' }, { id : 9 , title : 'Zwei glorreiche Halunken' , year : '1966' }, { id : 10 , title : 'Fight Club' , year : '1999' }, { id : 11 , title : 'Der Herr der Ringe: Die Gef\u00e4hrten' , year : '2001' }, { id : 12 , title : 'Forrest Gump' , year : '1994' }, { id : 13 , title : 'Inception' , year : '2010' }, { id : 14 , title : 'Das Imperium schl\u00e4gt zur\u00fcck' , year : '1980' }, { id : 15 , title : 'Der Herr der Ringe: Die zwei T\u00fcrme' , year : '2002' }, { id : 16 , title : 'Matrix' , year : '1999' }, { id : 17 , title : 'GoodFellas \u2013 Drei Jahrzehnte in der Mafia' , year : '1990' }, { id : 18 , title : 'Einer flog \u00fcber das Kuckucksnest' , year : '1975' }, { id : 19 , title : 'Joker' , year : '2019' }, { id : 20 , title : 'Die sieben Samurai' , year : '1954' }, ]; Beachten Sie, dass in den obigen Listings aus Gr\u00fcnden der \u00dcbersichtlichkeit in der movie/movierouter.js das JSON-Objekt herausgel\u00f6scht und im Reiter \"const data\" zur Verf\u00fcgung gestellt wurde (muss dann hineinkopiert werden). In der movie/movierouter.js wird das Router -Objekt, das in Zeile 2 erzeugt wird, in Zeile 10 exportiert. Im Folgenden wird gezeigt, wie der Router nun in unsere Anwendung eingebunden wird. Dies passiert in der index.js . Die hinzugef\u00fcgten Zeilen sind markiert. index.js 1 2 3 4 5 6 7 8 9 10 11 12 const express = require ( 'express' ); const movieRouter = require ( './movie/movierouter' ); const app = express (); app . get ( '/' , ( req , res ) => res . redirect ( '/movie' )); app . use ( '/movie' , movieRouter ); app . listen ( 8080 , () => { console . log ( 'Server listening on port 8080' ); }); Beim Laden des Moduls wird die .js -Endung nicht mit angegeben. Das hei\u00dft, der Router wird aus der movie/movierouter.js -Datei mittels require('./movie/movierouter') geladen (siehe Zeile 2 ). W\u00e4re der Router sogar in einer Datei movie/index.js , m\u00fcsste dieser Name nicht angegeben werden, es w\u00fcrde also gen\u00fcgen, den Router \u00fcber den Pfad /movie zu laden (entspricht also /movie/index ). Die use() -Methode in Zeile 8 gibt an, dass der movieRouter (aus movie/index.js ) f\u00fcr das Routing des Pfades url /movie zust\u00e4ndig ist. Die get() -Methode aus Zeile 6 sorgt daf\u00fcr, dass der Aufruf url / (also z.B. localhost:8080 ) nach url /movie (also z.B. localhost:8080/movie ) weitergeleitet wird. Rufen Sie nun im backend -Ordner node index.js auf und geben Sie im Browser localhost:8080 ein. Beobachten Sie, dass auf die URL localhost:8080/movie weitergeleitet wird. Es erscheint im Browser (entweder parsed oder raw - Abh\u00e4ngig von Browser und Browser-Plugins):","title":"Router"},{"location":"node/#model-view-controller","text":"Bis jetzt steckt alles im Router ( /movie/movierouter.js ). Wir werden im ersten Schritt die Daten (die eigentlich zum Model geh\u00f6ren) und eine Aktion ( listAction ) im Controller ( movie/controller.js ) definieren. movie/controller.js 1 2 3 4 5 6 7 8 9 const data = [ /* siehe Reiter \"const data\" */ ]; function listAction ( request , response ) { response . send ( data ); } module . exports = { listAction , }; movie/movierouter.js 1 2 3 4 5 6 7 8 const express = require ( 'express' ); const router = express . Router (); const { listAction } = require ( './controller' ); router . get ( '/' , listAction ); module . exports = router ; const data 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const data = [ { id : 1 , title : 'Die Verurteilten' , year : '1994' }, { id : 2 , title : 'Der Pate' , year : '1972' }, { id : 3 , title : 'Der Pate 2' , year : '1974' }, { id : 4 , title : 'The Dark Knight' , year : '2008' }, { id : 5 , title : 'Die zw\u00f6lf Geschworenen' , year : '1957' }, { id : 6 , title : 'Schindlers Liste' , year : '1993' }, { id : 7 , title : 'Der Herr der Ringe: Die R\u00fcckkehr des K\u00f6nigs' , year : '2003' }, { id : 8 , title : 'Pulp Fiction' , year : '1994' }, { id : 9 , title : 'Zwei glorreiche Halunken' , year : '1966' }, { id : 10 , title : 'Fight Club' , year : '1999' }, { id : 11 , title : 'Der Herr der Ringe: Die Gef\u00e4hrten' , year : '2001' }, { id : 12 , title : 'Forrest Gump' , year : '1994' }, { id : 13 , title : 'Inception' , year : '2010' }, { id : 14 , title : 'Das Imperium schl\u00e4gt zur\u00fcck' , year : '1980' }, { id : 15 , title : 'Der Herr der Ringe: Die zwei T\u00fcrme' , year : '2002' }, { id : 16 , title : 'Matrix' , year : '1999' }, { id : 17 , title : 'GoodFellas \u2013 Drei Jahrzehnte in der Mafia' , year : '1990' }, { id : 18 , title : 'Einer flog \u00fcber das Kuckucksnest' , year : '1975' }, { id : 19 , title : 'Joker' , year : '2019' }, { id : 20 , title : 'Die sieben Samurai' , year : '1954' }, ];","title":"Model-View-Controller"},{"location":"node/#controller","text":"Der Controller verwaltet perspektivisch die View und das Model. Beides haben wir jetzt noch nicht. Zun\u00e4chst wird im Controller eine Aktion listAction definiert, die alle Daten in einer Response ( response.send(data) ) sendet 2 . Diese Aktion wird mittels exports anderen Modulen zur Verf\u00fcgung gestellt. Der Router ( movierouter.js ) wurde entsprechend angepasst. Einerseits haben wir die Daten aus dem Router entfernt, andererseits enth\u00e4lt die get() -Methode nun nicht mehr die direkte Implementierung (die ja in den Controller ausgelagert wurde), sondern ruft die Methode listAction des Controllers auf. Dazu muss sie eingebunden werden. Dies w\u00fcrde normalerweise wie folgt geschehen: const controller = require ( './controller' ); const listAction = controller . listAction ; Da ein solches Konstrukt h\u00e4ufig vorkommt, wurde ein sogenanntes destructuring eingef\u00fchrt. Obiger Code wird mithilfe von destructuring durch const { listAction } = require ( './controller' ); ersetzt und verzichtet somit auf die Hilfsvariable controller . Die Eigenschaft, die im Controller listAction hei\u00dft (und importiert wird), wird direkt geladen.","title":"Controller"},{"location":"node/#model","text":"Das Model ( movie/model.js ) verwaltet die Daten. Dazu werden wir zun\u00e4chst die Daten aus dem Controller in das Model verschieben. Au\u00dferdem stellt das Model eine Funktion ( getAll() ) zum Auslesen aller Daten zur Verf\u00fcgung: movie/model.js 1 2 3 4 5 6 7 const data = [ /* siehe Reiter \"const data\" */ ]; module . exports = { getAll () { return data ; }, }; movie/controller.js 1 2 3 4 5 6 7 8 9 const model = require ( './model' ); function listAction ( request , response ) { response . send ( model . getAll ()); } module . exports = { listAction , }; const data 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const data = [ { id : 1 , title : 'Die Verurteilten' , year : '1994' }, { id : 2 , title : 'Der Pate' , year : '1972' }, { id : 3 , title : 'Der Pate 2' , year : '1974' }, { id : 4 , title : 'The Dark Knight' , year : '2008' }, { id : 5 , title : 'Die zw\u00f6lf Geschworenen' , year : '1957' }, { id : 6 , title : 'Schindlers Liste' , year : '1993' }, { id : 7 , title : 'Der Herr der Ringe: Die R\u00fcckkehr des K\u00f6nigs' , year : '2003' }, { id : 8 , title : 'Pulp Fiction' , year : '1994' }, { id : 9 , title : 'Zwei glorreiche Halunken' , year : '1966' }, { id : 10 , title : 'Fight Club' , year : '1999' }, { id : 11 , title : 'Der Herr der Ringe: Die Gef\u00e4hrten' , year : '2001' }, { id : 12 , title : 'Forrest Gump' , year : '1994' }, { id : 13 , title : 'Inception' , year : '2010' }, { id : 14 , title : 'Das Imperium schl\u00e4gt zur\u00fcck' , year : '1980' }, { id : 15 , title : 'Der Herr der Ringe: Die zwei T\u00fcrme' , year : '2002' }, { id : 16 , title : 'Matrix' , year : '1999' }, { id : 17 , title : 'GoodFellas \u2013 Drei Jahrzehnte in der Mafia' , year : '1990' }, { id : 18 , title : 'Einer flog \u00fcber das Kuckucksnest' , year : '1975' }, { id : 19 , title : 'Joker' , year : '2019' }, { id : 20 , title : 'Die sieben Samurai' , year : '1954' }, ]; Die Funktion getAll() im Model ( movie/model.js ) wird jetzt direkt dort implementiert, wo sie auch exportiert wird. Die Implementierung h\u00e4tte man auch auf eine Variable legen k\u00f6nnen (wie listAction beim Controller) und dann exportieren. Der Controller ( movie/controller.js ) liest das Model ein (Zeile 1 ) und verwendet die getAll() -Funktion, um die Daten zu senden (Zeile 4 ).","title":"Model"},{"location":"node/#view","text":"Die View ist f\u00fcr die Darstellung verantwortlich. Sp\u00e4ter wird diese von uns in Angular umgesetzt. Hier wird es nur zur Verdeutlichung gezeigt. Wir verwenden JavaScript-Template-Strings (sozusagen eine Mischung aus JavaScript und HTML). Wer m\u00f6chte, kann diesen Abschnitt auch \u00fcberspringen, da wir sp\u00e4ter unsere Oberfl\u00e4che viel aufwendiger mit Angular gestalten. movie/view.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 module . exports = function render ( movies ) { return ` <!DOCTYPE html> <html lang=\"de\"> <head> <meta charset=\"UTF-8\"> <title>Movie-list</title> </head> <body> <table> <thead> <tr> <th>Id</th> <th>Title</th> </tr> </thead> <tbody> ${ movies . map ( movie => `<tr><td> ${ movie . id } </td> <td> ${ movie . title } </td></tr>` ). join ( '' ) } </tbody> </table> </body> </html> ` }; movie/controller.js 1 2 3 4 5 6 7 8 9 10 11 12 const model = require ( './model' ); const view = require ( './view' ); function listAction ( request , response ) { const movies = model . getAll (); const body = view ( movies ); response . send ( body ); } module . exports = { listAction , }; In der View ( movie/view.js ) wird also eine HTML-Tabelle ( <table> ) erzeugt. Der Funktion render werden die anzuzeigenden Daten als JSON-Array \u00fcbergeben. Die JavaScript-Funktion map() durchl\u00e4uft jeden einzelnen Eintrag des Arrays und speichert ihn jeweils in die Variable movie . Jeder movie wird in einer Tabllenzeile ( <tr> ) dargestellt und besteht aus einer id und einem title (siehe const data im Model). Auf diese Elemente wird zugegriffen und in einzelnen Dateneintr\u00e4gen der Tabelle ( <td> ) dargestellt. Die JavaScript-Funktion join() verbindet diese Struktur zu einem String (Konkatenation mit '' ), so dass der Template-String tats\u00e4chlich ein String ist. Im Controller ( movie/controller.js ) wird die View eingebunden (Zeile 2 ) und dieser View die Movie-Daten \u00fcbergeben, so dass body dann den durch movie.render() erzeugten String enth\u00e4lt (die HTML-Seite). Dieser wird als Response gesendet. Nach einem Neustart der Anwendung ( node index.js im Ordner backend ) erscheint im Browser ( localhost:8080 ) folgende Seite: Success Wir haben mit Express das bekannteste Node.js-Framework verwendet, um die Verarbeitung von Daten im Rahmen des Model-View-Controller-Konzeptes umzusetzen. Im obigen Beispiel haben wir die Daten (die Filme) direkt im JSON-Format im Model gespeichert. Das ist nat\u00fcrlich nicht flexibel. Wir werden die Daten nun in eine Datenbank auslagern.","title":"View"},{"location":"node/#anbindung-von-datenbanken","text":"Wir wollen Node.js haupts\u00e4chlich daf\u00fcr verwenden, im Backend mit einer Datenbank zu kommunizieren. Wir wollen dies hier exemplarisch mit MySQL (siehe Werkzeuge \u2192 MySQL ) erl\u00e4utern. Die Verwendung von z.B. PostgreSQL ist \u00e4quivelent - Sie ben\u00f6tigen nur einen anderen Datenbanktreiber. Wir werden zun\u00e4chst das Node.js-Paket, das den mysql -Treiber enth\u00e4lt, installieren: npm install mysql Danach ist in der package.json die Abh\u00e4ngigkeit vom mysql -Paket hinterlegt (siehe \"dependencies\" ): package.json { \"name\" : \"backend\" , \"version\" : \"1.0.0\" , \"description\" : \"Node.js-Backend for MySQL\" , \"main\" : \"server.js\" , \"scripts\" : { \"test\" : \"echo \\\"Error: no test specified\\\" && exit 1\" , \"start\" : \"node server.js\" }, \"author\" : \"\" , \"license\" : \"ISC\" , \"dependencies\" : { \"mysql\" : \"^2.18.1\" } }","title":"Anbindung von Datenbanken"},{"location":"node/#eine-movie-datenbank","text":"Wir werden die Anbindung von Datenbanken exemplarisch an der Movie -Datenbank zeigen, die wir bereits im obigen Express -Abschnitt verwendet haben. Dazu erstellen wir uns eine Datenbank namens movie-db und bef\u00fcllen diese mit einigen Filmen (Tabelle Movie ). Sie k\u00f6nnen diese Datenbak auf verschiedenen Wegen erstellen. Am einfachsten ist es, wenn Sie phpMyadmin verwenden. Dort k\u00f6nnen Sie folgende SQL-Anfrage im Reiter SQL eingeben (Sie k\u00f6nnen auch im Terminal SQL -Anfragen eingeben nachdem Sie sich dort per mysql -u root -p mit dem MySQL-Server verbunden haben): CREATE DATABASE ` movie - db ` ; USE ` movie - db ` ; CREATE TABLE ` Movies ` ( ` id ` int ( 11 ) NOT NULL AUTO_INCREMENT , ` title ` varchar ( 255 ) DEFAULT NULL , ` year ` int ( 11 ) DEFAULT NULL , PRIMARY KEY ( ` id ` ) ) ENGINE = InnoDB DEFAULT CHARSET = utf8 ; INSERT INTO ` Movies ` ( ` title ` , ` year ` ) VALUES ( 'Die Verurteilten' , '1994' ), ( 'Der Pate' , '1972' ), ( 'Der Pate 2' , '1974' ), ( 'The Dark Knight' , '2008' ), ( 'Die zw\u00f6lf Geschworenen' , '1957' ), ( 'Schindlers Liste' , '1993' ), ( 'Der Herr der Ringe: Die R\u00fcckkehr des K\u00f6nigs' , '2003' ), ( 'Pulp Fiction' , '1994' ), ( 'Zwei glorreiche Halunken' , '1966' ), ( 'Fight Club' , '1999' ), ( 'Der Herr der Ringe: Die Gef\u00e4hrten' , '2001' ), ( 'Forrest Gump' , '1994' ), ( 'Inception' , '2010' ), ( 'Das Imperium schl\u00e4gt zur\u00fcck' , '1980' ), ( 'Der Herr der Ringe: Die zwei T\u00fcrme' , '2002' ), ( 'Matrix' , '1999' ), ( 'GoodFellas \u2013 Drei Jahrzehnte in der Mafia' , '1990' ), ( 'Einer flog \u00fcber das Kuckucksnest' , '1975' ), ( 'Joker' , '2019' ), ( 'Die sieben Samurai' , '1954' ); Wir verwenden das Projekt, das wir bereits im obigen Express -Abschnitt verwendet haben, also die Dateien aus backend : backend +---- movie | +---- model.js | +---- view.js | +---- controller.js | +---- movierouter.js +---- node_modules +---- index.js +---- package.json Zun\u00e4chst \u00e4ndern wir die movie/model.js . Darin werden nun nicht mehr die Daten gehalten, sondern die Verbindung zur Datenbank aufgebaut. Au\u00dferdem sehen wir 4 Funktionen zur Datenverwaltung vor, wovon wir eine ( getAll() ) gleich implementieren 3 : movie/model.js const mysql = require ( 'mysql' ); const connection = mysql . createConnection ({ host : 'localhost' , user : 'root' , password : 'password' , /* hier muss Ihr Passwort hin */ database : 'movie-db' , }); connection . connect (); function getAll () { return new Promise (( resolve , reject ) => { const query = 'SELECT * FROM Movies' ; connection . query ( query , ( error , results ) => { if ( error ) reject ( error ); else resolve ( results ); }) }); } module . exports = { getAll , }; movie/controller.js const model = require ( './model' ); const view = require ( './view' ); function listAction ( request , response ) { model . getAll (). then ( movies => { response . send ( view ( movies )); }, error => response . send ( error ), ); } module . exports = { listAction , }; Im Model ( /movie/model.js ) wird zun\u00e4chst die Verbindung zur Datenbank aufgebaut (Zeilen 2-7 und connection.connect() ). Die getAll() -Funktion stellt mithilfe von connection.query() eine Anfrage an die Datenbank (erster Parameter der connection.query() -Funktion). In unserem Beispiel ist die Anfrage die SQL-Query SELECT * FROM Movies . Die getAll() -Funktion gibt ein Promise -Objekt zur\u00fcck. Promises werden in JavaScript\u2192Promises erl\u00e4utert. Im Controller ( /movie/controller.js ) wird das Promise -Objekt in der then -Funktion ausgewertet. Wird in der Promise die resolve -Methode aufgerufen, werden die results \u00fcbergeben, also das Ergebnis der Datenbankanfrage. Diese Werte werden in der ersten Callback-Funktion der then -Methode dem Parameter movies \u00fcbergeben. Soll nur das JSON gesendet werden, wird die view nicht ben\u00f6tigt (statt response.send(view(movies)); gen\u00fcgt dann response.send(movies); ). Hier kapselt die View die Daten noch in einen HTML-Template-String. Im Falle eines Fehlers ruft die Promise die reject -Funktion auf und \u00fcbergibt den Parameter error . Diese Funktion ruft dann in der then -Funktion die zweite Callback-Funktion f\u00fcr die Fehlerauswertung auf. Success Wir haben jetzt eine MySQL-datenbank angebunden und die Anbindung anhand einer getAll() -Funktion, die alle in der Datenbank gespeicherten Filme zur\u00fcckgibt, gezeigt. Wir haben somit einen lesenden Zugriff auf alle Datenbankeintr\u00e4ge realisiert. Im folgenden werden wir auch weitere Zugriffe (create, update, delete) umsetzen. Allerdings haben wir bisher auch eine View mithilfe von Node.js erstellt und verwendet. Die Idee im folgenden ist, dass unser Backend nicht mehr f\u00fcr die Darstellung zust\u00e4ndig ist, sondern die Ergebnisse der Datenbankabfragen im JSON-Format zur\u00fcckgibt. Unser mit Angular erstelltes Frontend soll f\u00fcr die Darstellung zust\u00e4ndig sein. Wir stellen unser Backend vollst\u00e4ndig auf das REST-Konzept um.","title":"Eine Movie-Datenbank"},{"location":"node/#unser-backend-als-reiner-rest-server","text":"Representional State Transfer (REST) ist ein Architekturkonzept und wird in vielen Webanwendungen verwendet. REST beschreibt die Schnittstelle zwischen Frontend und Backend und ist dabei sehr stark an HTTP angelehnt: jede Ressource wird \u00fcber eine eindeutige URL aufgerufen (z.B. alle Filme \u00fcber localhost:8080/movies , den Film mit der id=3 \u00fcber localhost:8080/movie/3 ) es wird definiert, mit welcher HTTP-Anfrage auf die Ressource zugegriffen wird (z.B. get zum Lesen, post zum Anlegen, put zum \u00c4ndern von Ressourcen) jede Anfrage ist zustandslos, d.h. eine Anfrage muss alle notwendigen Informationen beinhalten und fr\u00fchere Anfragen (und deren Responses) werden nicht gespeichert Wir werden unsere View im Backend von nun an also nicht mehr ben\u00f6tigen. Unser Projekt sieht derzeit so aus: index.js const express = require ( 'express' ); const movieRouter = require ( './movie/movierouter' ); const app = express (); app . get ( '/' , ( req , res ) => res . redirect ( '/movie' )); app . use ( '/movie' , movieRouter ); app . listen ( 8080 , () => { console . log ( 'Server listening on port 8080' ); }); movie/model.js const mysql = require ( 'mysql' ); const connection = mysql . createConnection ({ host : 'localhost' , user : 'root' , password : 'password' , /* hier muss Ihr Passwort hin */ database : 'movie-db' , }); connection . connect (); function getAll () { return new Promise (( resolve , reject ) => { const query = 'SELECT * FROM Movies' ; connection . query ( query , ( error , results ) => { if ( error ) reject ( error ); else resolve ( results ); }) }); } module . exports = { getAll , }; movie/controller.js const model = require ( './model' ); function listAction ( request , response ) { model . getAll (). then ( movies => { response . send ( movies ); }, error => response . send ( error ), ); } module . exports = { listAction , }; movie/movierouter.js const express = require ( 'express' ); const router = express . Router (); const { listAction } = require ( './controller' ); router . get ( '/' , listAction ); module . exports = router ; Geben wir also die die URL localhost:8080 an, dann passiert folgendes: die Route wird weitergeleitet an localhost:8080/movie (siehe in index.js die Anweisung app.get('/', (req, res) => res.redirect('/movie')); ) dadurch wird der movie/movierouter.js aufgerufen und dieser ruft die Funktion listAction auf listAction ruft die Promise auf, die in der Funktion model.getAll() definiert wird in getAll() erfolgt eine Anfrage an die Datenbank wird diese Anfrage erfolgreich ausgef\u00fchrt, ruft die Promise die resolve -Funktion auf und \u00fcbergibt alle Resultate der Anfrage in listAction werden diese Resultate als Resonse gesendet Wir rufen Postman zum Testen dieser Anfrage auf und geben localhost:8080 in das URL-Feld ein und senden die Anfrage mittels GET -Methode ab. Es erscheint: Das gleiche Ergebnis bekommen wir, wenn wir als URL localhost:8080/movie eingeben (darauf wird ja eh umgeleitet). Wir k\u00f6nnen die Ausgabe auch mithilfe von curl testen: % curl http://localhost:8080/movie [{ \"id\" :1, \"title\" : \"Die Verurteilten\" , \"year\" :1994 } , { \"id\" :2, \"title\" : \"Der Pate\" , \"year\" :1972 } , { \"id\" :3, \"title\" : \"Der Pate 2\" , \"year\" :1974 } , { \"id\" :4, \"title\" : \"The Dark Knight\" , \"year\" :2008 } , { \"id\" :5, \"title\" : \"Die zw\u00f6lf Geschworenen\" , \"year\" :1957 } , { \"id\" :6, \"title\" : \"Schindlers Liste\" , \"year\" :1993 } , { \"id\" :7, \"title\" : \"Der Herr der Ringe: Die R\u00fcckkehr des K\u00f6nigs\" , \"year\" :2003 } , { \"id\" :8, \"title\" : \"Pulp Fiction\" , \"year\" :1994 } , { \"id\" :9, \"title\" : \"Zwei glorreiche Halunken\" , \"year\" :1966 } , { \"id\" :10, \"title\" : \"Fight Club\" , \"year\" :1999 } , { \"id\" :11, \"title\" : \"Der Herr der Ringe: Die Gef\u00e4hrten\" , \"year\" :2001 } , { \"id\" :12, \"title\" : \"Forrest Gump\" , \"year\" :1994 } , { \"id\" :13, \"title\" : \"Inception\" , \"year\" :2010 } , { \"id\" :14, \"title\" : \"Das Imperium schl\u00e4gt zur\u00fcck\" , \"year\" :1980 } , { \"id\" :15, \"title\" : \"Der Herr der Ringe: Die zwei T\u00fcrme\" , \"year\" :2002 } , { \"id\" :16, \"title\" : \"Matrix\" , \"year\" :1999 } , { \"id\" :17, \"title\" : \"GoodFellas \u2013 Drei Jahrzehnte in der Mafia\" , \"year\" :1990 } , { \"id\" :18, \"title\" : \"Einer flog \u00fcber das Kuckucksnest\" , \"year\" :1975 } , { \"id\" :19, \"title\" : \"Joker\" , \"year\" :2019 } , { \"id\" :20, \"title\" : \"Die sieben Samurai\" , \"year\" :1954 }] Wir erweitern unsere Schnittstelle zun\u00e4chst um die Ansicht eines einzelnen Films. Wir wollen nun mit der URL http://localhost:8080/movie/3 den Film angezeigt bekommen, der die id 3 hat. Wir wollen also die URLs um die Angabe einer id erweitern und f\u00fcr diesen Endpunkt den entsprechenden Film zur\u00fcckgesendet bekommen. Dazu erweitern wir (untem im Listing jeweils gelb markiert) die movie/model.js um eine Funktion getOne(id) ; das Model stellt nach au\u00dfen die Funktion get(id) zur Verf\u00fcgung, die als Response den Film sendet, der die entsprechende id hat, die movie/controller.js um eine Funktion detailAction() , die den Parameter id aus der URL ausliest und die Funktion model.get(id) aufruft, den movie/movierouter.js um eine weitere Route, n\u00e4mlich router.get('/:id', detailAction); , so dass eine id an die URL geh\u00e4ngt werden kann und f\u00fcr diesen Fall die detailAction aufgerufen wird movie/model.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 const mysql = require ( 'mysql' ); const connection = mysql . createConnection ({ host : 'localhost' , user : 'root' , password : 'password' , /* hier muss Ihr Passwort hin */ database : 'movie-db' , }); connection . connect (); function getAll () { return new Promise (( resolve , reject ) => { const query = 'SELECT * FROM Movies' ; connection . query ( query , ( error , results ) => { if ( error ) reject ( error ); else resolve ( results ); }) }); } function getOne ( id ) { return new Promise (( resolve , reject ) => { const query = 'SELECT * FROM Movies WHERE id=?' ; connection . query ( query , [ id ], ( error , results ) => { if ( error ) reject ( error ); else resolve ( results [ 0 ]); }); }); } module . exports = { getAll , get ( id ) { return getOne ( id )}, }; movie/controller.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const model = require ( './model' ); function listAction ( request , response ) { model . getAll (). then ( movies => { response . send ( movies ); }, error => response . send ( error ), ); } function detailAction ( request , response ) { model . get ( request . params . id ). then ( movie => response . send ( movie ), error => response . send ( error ), ); } module . exports = { listAction , detailAction , }; movie/movierouter.js 1 2 3 4 5 6 7 8 const express = require ( 'express' ); const router = express . Router (); const { listAction , detailAction } = require ( './controller' ); router . get ( '/' , listAction ); router . get ( '/:id' , detailAction ); module . exports = router ;","title":"Unser Backend als reiner REST-Server"},{"location":"node/#content-type-und-fehlerbehandlung","text":"Zwar senden wir bereits die Resultate der Requests als JSON zur\u00fcck, jedoch ist der content-type unserer Response noch content-type:text/html , da wir die Response mithilfe der send() -Funktion senden ( response.send() ). Wir \u00e4ndern dies in response.json() . Dadurch teilen wir dem Client mit, dass der gesendetete content-type ein JSON ist ( content-type:application/json ). F\u00fcr eine erfolgreiche Bearbeitung eines Requests wird mit der Response der HTTP-Statuscode 200 gesendet. F\u00fcr den Fehlerfall wollen wir nun daf\u00fcr sorgen, dass der HTTP-Statuscode 500 - Internal Server Error \u00fcbertragen wird. Dies erreichen wir im Fehlerfall mit error => response.status(500).json(error) . Unser Controller sieht nun also so aus: movie/controller.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const model = require ( './model' ); function listAction ( request , response ) { model . getAll (). then ( movies => { response . json ( movies ); }, error => response . status ( 500 ). json ( error ), ); } function detailAction ( request , response ) { model . get ( request . params . id ). then ( movie => response . json ( movie ), error => response . status ( 500 ). json ( error ), ); } module . exports = { listAction , detailAction , };","title":"Content-Type und Fehlerbehandlung"},{"location":"node/#post-einen-neuen-datensatz-anlegen","text":"Um einen neuen Datensatz anzulegen, m\u00fcssen wir zwei Dinge beachten: die HTTP-Anfrage ist POST (anstelle von GET , das wir zum Lesen verwenden) der Request \u00fcbergibt im Body den neuen Datensatz (als JSON) \u2192 dazu ben\u00f6tigen wir das Paket body-parser von Node.js und nutzen davon die json() -Funktion zum Einlesen des neuen Datensatzes im JSON-Format Wir passen zun\u00e4chst die index.js entsprechend an: index.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const express = require ( 'express' ); const bodyParser = require ( 'body-parser' ); const movieRouter = require ( './movie/movierouter' ); const app = express (); app . use ( bodyParser . json ()); app . get ( '/' , ( req , res ) => res . redirect ( '/movie' )); app . use ( '/movie' , movieRouter ); app . listen ( 8080 , () => { console . log ( 'Server listening on port 8080' ); }); Um nun einen neuen Datensatz in der Datenbank anzulegen, erweitern wir unser Projekt wie folgt: in movie/model.js wird eine insert() -Funktion definiert, welche durch eine save() -Funktion aufgerufen wird ( save() wird nach au\u00dfen zur Verf\u00fcgung gestellt 4 ), in movie/controller.js wird eine createAction() definiert, die den neuen Datensatz aus dem request,body ausliest und die model.save() aufruft, in movie/movierouter.js wird der neue Endpunkt router.post('/', createAction); festgelegt movie/model.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 const mysql = require ( 'mysql' ); const connection = mysql . createConnection ({ host : 'localhost' , user : 'root' , password : 'password' , /* hier muss Ihr Passwort hin */ database : 'movie-db' , }); connection . connect (); function getAll () { /* bleibt so */ } function getOne ( id ) { /* bleibt so */ } function insert ( movie ) { return new Promise (( resolve , reject ) => { const query = 'INSERT INTO Movies (title, year) VALUES (?, ?)' ; connection . query ( query , [ movie . title , movie . year ], ( error , results ) => { if ( error ) reject ( error ); else resolve ( results ); }); }); } module . exports = { getAll , get ( id ) { return getOne ( id )}, save ( movie ) { if ( ! movie . id ) return insert ( movie ); }, }; movie/controller.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const model = require ( './model' ); function listAction ( request , response ) { /* bleibt so */ } function detailAction ( request , response ) { /* bleibt so */ } function createAction ( request , response ) { const movie = { id : request . body . id , title : request . body . title , year : request . body . year , }; model . save ( movie ). then ( newMovie => response . status ( 201 ). json ( newMovie ), error => response . status ( 500 ). json ( error ), ); } module . exports = { listAction , detailAction , createAction , }; movie/movierouter.js 1 2 3 4 5 6 7 8 9 const express = require ( 'express' ); const router = express . Router (); const { listAction , detailAction , createAction } = require ( './controller' ); router . get ( '/' , listAction ); router . get ( '/:id' , detailAction ); router . post ( '/' , createAction ); module . exports = router ; Die Funktionen im Model haben alle den gleichen Aufbau. Es wird eine Promise erzeugt und mithilfe von connection.query() eine Anfrage an die Datenbank gestellt. Im Erfolgsfall wird die resolve() -Funktion der Promise aufgerufen, im Fehlerfall die reject() -Funktion. Im Controller wird der request verarbeitet und eine response erzeugt. Im Router werden die Endpunkte und die dazugeh\u00f6rigen HTTP-Methoden (z.B. get oder post ) definiert. Um die createAction -Funktion zu testen, rufen wir Postman auf und tragen in die URL http://localhost:8080/movie/ ein. Wichtig: es muss nun POST ausgew\u00e4hlt werden. Mit dem Request \u00fcbergeben wir im Body nun ein JSON, das einen neuen Film enth\u00e4lt, d.h. das JSON muss die Eigensc haften title und year enthalten (nicht id , denn diese wird automatisch durch das Datenbanksystem erzeugt). Die Anfrage sieht in Postman wie folgt aus: Es kann auch mit curl getestet werden: curl -X POST -H \"Content-Type: application/json\" -d '{\"title\": \"Noch ein Test\", \"year\": \"2019\"}' http://localhost:8080/movie { \"fieldCount\" :0, \"affectedRows\" :1, \"insertId\" :23, \"serverStatus\" :2, \"warningCount\" :0, \"message\" : \"\" , \"protocol41\" :true, \"changedRows\" :0 }","title":"POST - einen neuen Datensatz anlegen"},{"location":"node/#put-einen-datensatz-andern","text":"Das \u00c4ndern eines Datensatzes erfolgt in \u00e4hnlicher Weise wie das Anlegen eines Datensatzes. Es wird im Body der Anfrage das neue JSON gesendet und der Content-Type der Anfrage ist application/json (im Header gesetzt). Zum \u00c4ndern eines Datensatzes wird die HTTP-Methode put verwendet. Um nun einen Datensatz in der Datenbank zu \u00e4ndern, erweitern wir unser Projekt wie folgt: in movie/model.js wird eine update() -Funktion definiert, welche durch die save() -Funktion aufgerufen wird ( save() wird nach au\u00dfen zur Verf\u00fcgung gestellt), in movie/controller.js wird eine updateAction() definiert, die genauso aussieht wie die createAction() , au\u00dfer dass die id aus der URL ausgelesen wird und nicht aus dem Request-Body in movie/movierouter.js wird der neue Endpunkt router.put('/', updateActionAction); festgelegt movie/model.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const mysql = require ( 'mysql' ); const connection = mysql . createConnection ({ host : 'localhost' , user : 'root' , password : 'password' , /* hier muss Ihr Passwort hin */ database : 'movie-db' , }); connection . connect (); function getAll () { /* bleibt so */ } function getOne ( id ) { /* bleibt so */ } function insert ( movie ) { /* bleibt so */ } function update ( movie ) { return new Promise (( resolve , reject ) => { const query = 'UPDATE Movies SET title = ?, year = ? WHERE id = ?' ; connection . query ( query , [ movie . title , movie . year , movie . id ], ( error , results ) => { if ( error ) reject ( error ); else resolve ( results ); }); }); } module . exports = { getAll , get ( id ) { return getOne ( id )}, save ( movie ) { if ( ! movie . id ) return insert ( movie ); else return update ( movie ); }, }; movie/controller.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 const model = require ( './model' ); function listAction ( request , response ) { /* bleibt so */ } function detailAction ( request , response ) { /* bleibt so */ } function createAction ( request , response ) { /* bleibt so */ } function updateAction ( request , response ) { const movie = { id : request . params . id , title : request . body . title , year : request . body . year , }; model . save ( movie ). then ( movie => response . status ( 201 ). json ( movie ), error => response . status ( 500 ). json ( error ), ); } module . exports = { listAction , detailAction , createAction , updateAction , }; movie/movierouter.js 1 2 3 4 5 6 7 8 9 10 const express = require ( 'express' ); const router = express . Router (); const { listAction , detailAction , createAction , updateAction } = require ( './controller' ); router . get ( '/' , listAction ); router . get ( '/:id' , detailAction ); router . post ( '/' , createAction ); router . put ( '/:id' , updateAction ); module . exports = router ; Um die Update-Funktion in Postman auszuprobieren, geben Sie als URL z.B. http://localhost:8080/movie/3 ein (um den Film mit der id=3 zu \u00e4ndern) und w\u00e4hlen als HTTP-Methode PUT . Im Request-Body geben Sie dann z.B. { \"title\" : \"Der Pate 3\" , \"year\" : \"1990\" } ein. Sie erhalten: Nat\u00fcrlich k\u00f6nnen Sie zum Testen auch curl verwenden. Die Anfrage ist \u00e4hnlich zur POST -Anfrage, nur mit curl -X PUT .","title":"PUT - einen Datensatz \u00e4ndern"},{"location":"node/#delete-einen-datensatz-andern","text":"Um einen Datensatz zu l\u00f6schen, w\u00e4hlen wir die HTTP-Methode DELETE . Alles andere bleibt wie gehabt. Wir pr\u00e4sentieren gleich die L\u00f6sung: movie/model.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 const mysql = require ( 'mysql' ); const connection = mysql . createConnection ({ host : 'localhost' , user : 'root' , password : 'password' , /* hier muss Ihr Passwort hin */ database : 'movie-db' , }); connection . connect (); function getAll () { /* bleibt so */ } function getOne ( id ) { /* bleibt so */ } function insert ( movie ) { /* bleibt so */ } function update ( movie ) { /* bleibt so */ } function remove ( id ) { return new Promise (( resolve , reject ) => { const query = 'DELETE FROM Movies WHERE id = ?' ; connection . query ( query , [ id ], ( error , results ) => { if ( error ) reject ( error ); else resolve ( results [ 0 ]); }); }); } module . exports = { getAll , get ( id ) { return getOne ( id )}, save ( movie ) { if ( ! movie . id ) return insert ( movie ); else return update ( movie ); }, delete ( id ) { return remove ( id )}, }; movie/controller.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 const model = require ( './model' ); function listAction ( request , response ) { /* bleibt so */ } function detailAction ( request , response ) { /* bleibt so */ } function createAction ( request , response ) { /* bleibt so */ } function updateAction ( request , response ) { /* bleibt so */ } function deleteAction ( request , response ) { const id = parseInt ( request . params . id , 10 ); model . delete ( id ) . then ( () => response . status ( 204 ). send (), error => response . status ( 500 ). json ( error ) ); } module . exports = { listAction , detailAction , createAction , updateAction , deleteAction }; movie/movierouter.js 1 2 3 4 5 6 7 8 9 10 11 const express = require ( 'express' ); const router = express . Router (); const { listAction , detailAction , createAction , updateAction , deleteAction } = require ( './controller' ); router . get ( '/' , listAction ); router . get ( '/:id' , detailAction ); router . post ( '/' , createAction ); router . put ( '/:id' , updateAction ); router . delete ( '/:id' , deleteAction ); module . exports = router ; Success Wir haben nun eine vollst\u00e4ndige REST-Schnittstelle des Backends implementiert. Es k\u00f6nnen alle Datens\u00e4tze oder ein Datensatz gelesen ( read mithilfe von get ), ein Datensatz erzeugt ( create mithilfe von post ), ein Datensatz aktualisiert ( update mithilfe von put ) und ein Datensatz gel\u00f6scht ( delete mithilfe von delete ) werden.","title":"DELETE - einen Datensatz \u00e4ndern"},{"location":"node/#json-web-tokens-zur-authentifizierung","text":"Unsere Backend-Schnittstelle ist bis jetzt offen f\u00fcr jeden, d.h. jeder, der die Endpunkte kennt, kann die Ressourcen abfragen und somit Daten auslesen, l\u00f6schen, \u00e4ndern usw. Das kann nat\u00fcrlich nicht richtig sein, insbesondere wenn mit sensiblen Daten gearbeitet wird. Wir k\u00f6nnen im Backend auch nicht ein Anmeldeformular vorsehen, da das Backend nur Services anbietet. Au\u00dferdem ist die Kommunikation mit der REST-Schnittstelle zustandslos, d.h. es kann gar nicht gespeichert werden, ob eine Nutzerin bereits angemeldet ist oder nicht. Eine L\u00f6sung f\u00fcr diese Probleme sind JSON Web Tokens (JWT) . Ein JWT ist eine codierte Zeichenkette, die einen Header enth\u00e4lt, einen Payload und eine Signatur. Hier ein Screenshot der jwt.io-Webseite mit einem Beispiel daf\u00fcr:","title":"JSON Web Tokens zur Authentifizierung"},{"location":"node/#datenbank-und-model","text":"Wir erzeugen zun\u00e4chst eine Tabelle in unserer Datenbank, um Nutzername und zugeh\u00f6riges Passwort zu speichern.","title":"Datenbank und Model"},{"location":"node/#erzeugen-eines-jwt","text":"F\u00fcr die Erzeugung eines JWT verwenden wir das Nodes-Paket jsonwebtoken . Dieses installieren wir im Ordner backend mit dem Befehl npm install jsonwebtoken Wir erstellen uns eine Route, \u00fcber die die Benutzer ihre Anmeldedaten an das Backend schicken k\u00f6nnen Die Bezeichnung movierouter.js f\u00fcr diese Datei ist hier noch verwirrend, da sie zun\u00e4chst auch die Daten enthalten wird. Wir werden nach und nach die Funktionen so gestalten und auslagern, dass die Datei nur noch den Router enth\u00e4lt und f\u00fcr alles andere ein Model, eine View und ein Controller entstehen werden. \u21a9 Beachten Sie auch hier wieder, dass aus Gr\u00fcnden der \u00dcbersichtlichkeit die Daten in den Reiter const data ausgelagert wurden. Die m\u00fcssen Sie hineinkopieren. \u21a9 Achten Sie darauf, Ihr korrektes Passwort einzutragen. \u21a9 Wir werden die save() -Funktion sp\u00e4ter noch erweitern. Beim Anlegen eines neuen Datensatzes werden zwar der Titel und das Entstehungsjahr des Films mitgesendet, nicht jedoch die id . Die id wird durch das Datenbanksystems vergeben. F\u00fcr den Fall, dass der save() -Funktion auch die id des Films mitgegeben wird, gehen wir davon aus, dass der Film in der Datenbank aktualisiert ( update() ) wird, sich also ein Eintrag ge\u00e4ndert hat. \u21a9","title":"Erzeugen eines JWT"},{"location":"tools/","text":"Werkzeuge \u00b6 Angular \u00b6 Integrated Development Environment (IDE) \u00b6 F\u00fcr die Webentwicklung stehen Ihnen viele gute Entwicklungswerkzeuge zur Verf\u00fcgung. F\u00fcr welches Sie sich entscheiden, bleibt Ihnen \u00fcberlassen. Hier eine Auswahl der aus meiner Sicht besten Entwicklungswerkzeuge: IntelliJ IDEA PhpStorm WebStorm Sublime Text Atom Visual Studio Code F\u00fcr die Tools von Jetbrains ben\u00f6tigen Sie einen Account. Mit Ihrer HTW-E-Mail-Adresse bekommen Sie aber eine kostenlose Hochschullizenz und k\u00f6nnen so die Enterprise-Versionen kostenlos nutzen. Sublime Text ist Shareware und fragt regelm\u00e4\u00dfig, ob Sie spenden m\u00f6chten. Git \u00b6 Git ist ein Werkzeug zur Versionskontrolle und zum gemeinsamen Entwickeln in Teams. Nach jeder \u00dcbung committen Sie Ihre L\u00f6sung und pushen Sie auf einen zentralen, netzbasierten Dienst, wie z.B. GitHub GitLab Bibucket Gew\u00e4hren Sie mir Zugriff auf Ihr zentrales Repository. Auf GitHub finden Sie mich unter jfreiheit bzw. meiner E-Mail-Adresse joern.freiheit@htw-berlin.de . Developer Tools \u00b6 Alle Browser sind mit Werkzeugen ausgestattet, die es Web-Entwicklerinnen erm\u00f6glichen, im Browser Informationen \u00fcber die Webanwendung zu erhalten. F\u00fcr einige Browser ist hier angegeben, wie Sie diese Entwicklerwerkzeuge einschalten. Chrome \u00b6 In Chrome sind die Entwicklerwerkzeuge unter dem Men\u00fc neben der URL-Eingabezeile unter Weitere Tools --> Entwicklertools verf\u00fcgbar (siehe folgendes Bild). Die eingeschalteten Entwicklertools offenbaren Ihnen umfassende Informationen \u00fcber die angezeigte Webseite. Besonders interessant ist der Reiter Console : oder auch der Reiter Elements , der Ihnen sowohl den HTML- als auch den jeweiligen CSS-Code anzeigt: Weiterf\u00fchrende Informationen erhalten Sie unter https://developers.google.com/web/tools/chrome-devtools . Firefox \u00b6 Zu den Entwicklertools von Firefox finden Sie Informationen auf https://developer.mozilla.org/de/docs/Tools Firefox Browser Developer Die Entwicklertools lassen sich in Firefox \u00f6ffnen unter Web-Entwickler --> Inspektor : Sie haben die gleichen M\u00f6glichkeiten der Ananlyse wie bei Chrome, bei Safari und anderen Browsern: Safari \u00b6 In Safari m\u00fcssen Sie zun\u00e4chst den Men\u00fceintrag Entwickler aktivieren. Eine Anleitung dazu finden Sie z.B. hier auf heise . Weitere Informationen zu den Entwicklertools erhalten Sie z.B. auf Werkzeuge im Men\u00fc \u201eEntwickler\u201c Safari Developer Help Web Development Tools Curl \u00b6 Curl ist ein Open-Source-Kommandozeilenprogramm, um Daten mittels URL zu transferieren. Curl kann auf der Kommandozeile genutzt werden, um SMTP, HTTP, FTP usw. zu verwenden. Wir werden Curl insbesondere f\u00fcr die HTTP-Anfragemethoden GET und POST verwenden. Eine ausf\u00fchrliche Beschreibung von Curl ist im Buch Everything curl - the book frei verf\u00fcgbar. Die Installation von Curl erfolgt \u00fcber die Curl Download Seite . Zum Testen, ob Curl korrekt funktioniert, k\u00f6nnen Sie im Terminal z.B. curl freiheit.f4.htw-berlin.de/curl.html eingeben. Es sollte folgende Ausgabe erscheinen: <!DOCTYPE html> <html> <head> <title>Curl-Test</title> </head> <body> <p>Hallo FIW!</p> </body> </html> Mit dem -o -Flag k\u00f6nnen Sie die Datei speichern (Sie k\u00f6nnen einen Dateinamen angeben - hier curl.html ): curl -o curl.html freiheit.f4.htw-berlin.de/curl.html Da oben die lokale Datei genau so hei\u00dft wie die remote-Datei, h\u00e4tte man auch curl -O freiheit.f4.htw-berlin.de/curl.html angeben k\u00f6nnen, also gro\u00dfes -O . Mit dem -d -Flag k\u00f6nnen Parameter \u00fcbergeben und die entsprechende Seite mit einer POST-Anfrage aufgerufen werden. Mit dem zus\u00e4tzlichen -G -Flag erfolgt die Anfrage nicht als POST sondern als GET. Mit dem -I -Flag fragen Sie den Header der Anfrage ab, z.B.: curl -I freiheit.f4.htw-berlin.de/curl.html gibt etwas aus in der Art: HTTP/1.1 200 OK Date: Thu, 04 Jun 2020 13 :59:43 GMT Server: Apache/2.4.38 ( Debian ) Last-Modified: Thu, 04 Jun 2020 13 :01:59 GMT ETag: \"78-5a741c004bdb9\" Accept-Ranges: bytes Content-Length: 120 Vary: Accept-Encoding Content-Type: text/html F\u00fcr eine vollst\u00e4ndige \u00dcbersicht aller Flags von Curl siehe Curl manpage . Postman \u00b6 Postman ist eine Anwendung, um Schnittstellen ( Application Programming Interface - API ), die das Backend bereitstellt, zu entwickeln und zu testen. Sie finden Postman unter postman.com . Wir beschr\u00e4nken uns zun\u00e4chst auf den Postman API Client . Laden Sie das Tool herunter und installieren es. Rufen Sie Postman auf und geben in das Eingabefeld https://postman-echo.com/get ein. Lassen Sie die Auswahl links daneben auf GET und klicken auf den Send -Button. Es erscheint folgendes Bild: Neben der GET -Anfrage sind folgende weitere Anfragen (siehe auch HTML \u2192 HTTP ) m\u00f6glich: POST - sendet Daten zur Verarbeitung an den Webserver PUT - l\u00e4dt existierende Daten (eine Datei) auf den Server PATCH - \u00e4ndert Daten (eine Datei), ohne - wie bei PUT - diese vollst\u00e4ndig zu ersetzen DELETE - l\u00f6scht die angegebenen Daten auf dem Server Node.js \u00b6 Node.js ist eine JavaScript-Laufzeitumgebung. Node.js reagiert auf Ereignisse und antwortet asynchron. Das bedeutet, dass die Ausf\u00fchrung einer Ereignisbearbeitung nicht zum Blockieren der Laufzeitumgebung f\u00fchrt, sondern nebenl\u00e4ufig weitere Ereignisse eintreffen k\u00f6nnen, die ebenfalls asynchron behandelt werden. Dies geschieht mithilfe des Callback-Patterns . Callbacks sind Funktionen, die anderen Funktionen als Parameter \u00fcbergeben werden (siehe JavaScript \u2192 Callback-Funktionen ). MySQL \u00b6 MySQL ist eine relationale Datenbank und geh\u00f6rt zu den am meisten verwendeten relationalen Datenbanken bei Webanwendungen. Wir h\u00e4tten uns auch f\u00fcr PostgreSQL entscheiden k\u00f6nnen. F\u00fcr einen kurzen Vergleich von MySQL und PostgreSQL siehe hier . Informationen zur Installation von MySQL finden Sie hier . Nach der Installation finden Sie z.B. auf dem Mac unter Systemeinstellungen \u2192 MySQL : phpMyadmin \u00b6 phpMyadmin ist eine graphische Oberfl\u00e4che zur Verwaltung Ihrer MySQL -Datenbanken. Nach erfolgreicher Installation rufen Sie im Browser localhost/phpmyadmin auf und haben Zugriff auf Ihre Datenbanken bzw. k\u00f6nnen diese erstellen, \u00e4ndern und bef\u00fcllen. Weitere Hilfen \u00b6 Prozesse und Ports \u00b6 Wenn Sie herausbekommen wollen, welche Ports bereits belegt sind und durch welchen Prozess, dann geben Sie im Terminal ein: lsof -i -P | grep -i LISTEN Eventuell m\u00fcssen Sie ein sudo voranstellen. Sie erhalten eine Ausgabe in der Form (variiert nat\u00fcrlich stark): rapportd 372 jornfreiheit 4u IPv4 0x5cee55fd054bd73 0t0 TCP *:57124 (LISTEN) rapportd 372 jornfreiheit 5u IPv6 0x5cee55fab8990c3 0t0 TCP *:57124 (LISTEN) phpstorm 456 jornfreiheit 55u IPv4 0x5cee55faabf19b3 0t0 TCP localhost:6942 (LISTEN) phpstorm 456 jornfreiheit 355u IPv4 0x5cee55fb7f034f3 0t0 TCP localhost:63342 (LISTEN) Dropbox 2638 jornfreiheit 129u IPv6 0x5cee55fb262a223 0t0 TCP *:17500 (LISTEN) Dropbox 2638 jornfreiheit 130u IPv4 0x5cee55fb25ea393 0t0 TCP *:17500 (LISTEN) Dropbox 2638 jornfreiheit 185u IPv4 0x5cee55fb7f00393 0t0 TCP localhost:17600 (LISTEN) Dropbox 2638 jornfreiheit 194u IPv4 0x5cee55fb9e31753 0t0 TCP localhost:17603 (LISTEN) node 9070 jornfreiheit 21u IPv6 0x5cee55fb5913843 0t0 TCP *:8080 (LISTEN) Python 9138 jornfreiheit 5u IPv4 0x5cee55fcfdf7753 0t0 TCP localhost:8000 (LISTEN) Wenn Sie nun z.B. einen bestimmten Prozess killen wollen, z.B. den Python-Prozess, der in localhost auf Port 8000 l\u00e4uft, dann geben Sie kill -9 9138 im Terminal ein. 9138 ist die PID des entsprechenden Prozesses.","title":"Werkzeuge"},{"location":"tools/#werkzeuge","text":"","title":"Werkzeuge"},{"location":"tools/#angular","text":"","title":"Angular"},{"location":"tools/#integrated-development-environment-ide","text":"F\u00fcr die Webentwicklung stehen Ihnen viele gute Entwicklungswerkzeuge zur Verf\u00fcgung. F\u00fcr welches Sie sich entscheiden, bleibt Ihnen \u00fcberlassen. Hier eine Auswahl der aus meiner Sicht besten Entwicklungswerkzeuge: IntelliJ IDEA PhpStorm WebStorm Sublime Text Atom Visual Studio Code F\u00fcr die Tools von Jetbrains ben\u00f6tigen Sie einen Account. Mit Ihrer HTW-E-Mail-Adresse bekommen Sie aber eine kostenlose Hochschullizenz und k\u00f6nnen so die Enterprise-Versionen kostenlos nutzen. Sublime Text ist Shareware und fragt regelm\u00e4\u00dfig, ob Sie spenden m\u00f6chten.","title":"Integrated Development Environment (IDE)"},{"location":"tools/#git","text":"Git ist ein Werkzeug zur Versionskontrolle und zum gemeinsamen Entwickeln in Teams. Nach jeder \u00dcbung committen Sie Ihre L\u00f6sung und pushen Sie auf einen zentralen, netzbasierten Dienst, wie z.B. GitHub GitLab Bibucket Gew\u00e4hren Sie mir Zugriff auf Ihr zentrales Repository. Auf GitHub finden Sie mich unter jfreiheit bzw. meiner E-Mail-Adresse joern.freiheit@htw-berlin.de .","title":"Git"},{"location":"tools/#developer-tools","text":"Alle Browser sind mit Werkzeugen ausgestattet, die es Web-Entwicklerinnen erm\u00f6glichen, im Browser Informationen \u00fcber die Webanwendung zu erhalten. F\u00fcr einige Browser ist hier angegeben, wie Sie diese Entwicklerwerkzeuge einschalten.","title":"Developer Tools"},{"location":"tools/#chrome","text":"In Chrome sind die Entwicklerwerkzeuge unter dem Men\u00fc neben der URL-Eingabezeile unter Weitere Tools --> Entwicklertools verf\u00fcgbar (siehe folgendes Bild). Die eingeschalteten Entwicklertools offenbaren Ihnen umfassende Informationen \u00fcber die angezeigte Webseite. Besonders interessant ist der Reiter Console : oder auch der Reiter Elements , der Ihnen sowohl den HTML- als auch den jeweiligen CSS-Code anzeigt: Weiterf\u00fchrende Informationen erhalten Sie unter https://developers.google.com/web/tools/chrome-devtools .","title":"Chrome"},{"location":"tools/#firefox","text":"Zu den Entwicklertools von Firefox finden Sie Informationen auf https://developer.mozilla.org/de/docs/Tools Firefox Browser Developer Die Entwicklertools lassen sich in Firefox \u00f6ffnen unter Web-Entwickler --> Inspektor : Sie haben die gleichen M\u00f6glichkeiten der Ananlyse wie bei Chrome, bei Safari und anderen Browsern:","title":"Firefox"},{"location":"tools/#safari","text":"In Safari m\u00fcssen Sie zun\u00e4chst den Men\u00fceintrag Entwickler aktivieren. Eine Anleitung dazu finden Sie z.B. hier auf heise . Weitere Informationen zu den Entwicklertools erhalten Sie z.B. auf Werkzeuge im Men\u00fc \u201eEntwickler\u201c Safari Developer Help Web Development Tools","title":"Safari"},{"location":"tools/#curl","text":"Curl ist ein Open-Source-Kommandozeilenprogramm, um Daten mittels URL zu transferieren. Curl kann auf der Kommandozeile genutzt werden, um SMTP, HTTP, FTP usw. zu verwenden. Wir werden Curl insbesondere f\u00fcr die HTTP-Anfragemethoden GET und POST verwenden. Eine ausf\u00fchrliche Beschreibung von Curl ist im Buch Everything curl - the book frei verf\u00fcgbar. Die Installation von Curl erfolgt \u00fcber die Curl Download Seite . Zum Testen, ob Curl korrekt funktioniert, k\u00f6nnen Sie im Terminal z.B. curl freiheit.f4.htw-berlin.de/curl.html eingeben. Es sollte folgende Ausgabe erscheinen: <!DOCTYPE html> <html> <head> <title>Curl-Test</title> </head> <body> <p>Hallo FIW!</p> </body> </html> Mit dem -o -Flag k\u00f6nnen Sie die Datei speichern (Sie k\u00f6nnen einen Dateinamen angeben - hier curl.html ): curl -o curl.html freiheit.f4.htw-berlin.de/curl.html Da oben die lokale Datei genau so hei\u00dft wie die remote-Datei, h\u00e4tte man auch curl -O freiheit.f4.htw-berlin.de/curl.html angeben k\u00f6nnen, also gro\u00dfes -O . Mit dem -d -Flag k\u00f6nnen Parameter \u00fcbergeben und die entsprechende Seite mit einer POST-Anfrage aufgerufen werden. Mit dem zus\u00e4tzlichen -G -Flag erfolgt die Anfrage nicht als POST sondern als GET. Mit dem -I -Flag fragen Sie den Header der Anfrage ab, z.B.: curl -I freiheit.f4.htw-berlin.de/curl.html gibt etwas aus in der Art: HTTP/1.1 200 OK Date: Thu, 04 Jun 2020 13 :59:43 GMT Server: Apache/2.4.38 ( Debian ) Last-Modified: Thu, 04 Jun 2020 13 :01:59 GMT ETag: \"78-5a741c004bdb9\" Accept-Ranges: bytes Content-Length: 120 Vary: Accept-Encoding Content-Type: text/html F\u00fcr eine vollst\u00e4ndige \u00dcbersicht aller Flags von Curl siehe Curl manpage .","title":"Curl"},{"location":"tools/#postman","text":"Postman ist eine Anwendung, um Schnittstellen ( Application Programming Interface - API ), die das Backend bereitstellt, zu entwickeln und zu testen. Sie finden Postman unter postman.com . Wir beschr\u00e4nken uns zun\u00e4chst auf den Postman API Client . Laden Sie das Tool herunter und installieren es. Rufen Sie Postman auf und geben in das Eingabefeld https://postman-echo.com/get ein. Lassen Sie die Auswahl links daneben auf GET und klicken auf den Send -Button. Es erscheint folgendes Bild: Neben der GET -Anfrage sind folgende weitere Anfragen (siehe auch HTML \u2192 HTTP ) m\u00f6glich: POST - sendet Daten zur Verarbeitung an den Webserver PUT - l\u00e4dt existierende Daten (eine Datei) auf den Server PATCH - \u00e4ndert Daten (eine Datei), ohne - wie bei PUT - diese vollst\u00e4ndig zu ersetzen DELETE - l\u00f6scht die angegebenen Daten auf dem Server","title":"Postman"},{"location":"tools/#nodejs","text":"Node.js ist eine JavaScript-Laufzeitumgebung. Node.js reagiert auf Ereignisse und antwortet asynchron. Das bedeutet, dass die Ausf\u00fchrung einer Ereignisbearbeitung nicht zum Blockieren der Laufzeitumgebung f\u00fchrt, sondern nebenl\u00e4ufig weitere Ereignisse eintreffen k\u00f6nnen, die ebenfalls asynchron behandelt werden. Dies geschieht mithilfe des Callback-Patterns . Callbacks sind Funktionen, die anderen Funktionen als Parameter \u00fcbergeben werden (siehe JavaScript \u2192 Callback-Funktionen ).","title":"Node.js"},{"location":"tools/#mysql","text":"MySQL ist eine relationale Datenbank und geh\u00f6rt zu den am meisten verwendeten relationalen Datenbanken bei Webanwendungen. Wir h\u00e4tten uns auch f\u00fcr PostgreSQL entscheiden k\u00f6nnen. F\u00fcr einen kurzen Vergleich von MySQL und PostgreSQL siehe hier . Informationen zur Installation von MySQL finden Sie hier . Nach der Installation finden Sie z.B. auf dem Mac unter Systemeinstellungen \u2192 MySQL :","title":"MySQL"},{"location":"tools/#phpmyadmin","text":"phpMyadmin ist eine graphische Oberfl\u00e4che zur Verwaltung Ihrer MySQL -Datenbanken. Nach erfolgreicher Installation rufen Sie im Browser localhost/phpmyadmin auf und haben Zugriff auf Ihre Datenbanken bzw. k\u00f6nnen diese erstellen, \u00e4ndern und bef\u00fcllen.","title":"phpMyadmin"},{"location":"tools/#weitere-hilfen","text":"","title":"Weitere Hilfen"},{"location":"tools/#prozesse-und-ports","text":"Wenn Sie herausbekommen wollen, welche Ports bereits belegt sind und durch welchen Prozess, dann geben Sie im Terminal ein: lsof -i -P | grep -i LISTEN Eventuell m\u00fcssen Sie ein sudo voranstellen. Sie erhalten eine Ausgabe in der Form (variiert nat\u00fcrlich stark): rapportd 372 jornfreiheit 4u IPv4 0x5cee55fd054bd73 0t0 TCP *:57124 (LISTEN) rapportd 372 jornfreiheit 5u IPv6 0x5cee55fab8990c3 0t0 TCP *:57124 (LISTEN) phpstorm 456 jornfreiheit 55u IPv4 0x5cee55faabf19b3 0t0 TCP localhost:6942 (LISTEN) phpstorm 456 jornfreiheit 355u IPv4 0x5cee55fb7f034f3 0t0 TCP localhost:63342 (LISTEN) Dropbox 2638 jornfreiheit 129u IPv6 0x5cee55fb262a223 0t0 TCP *:17500 (LISTEN) Dropbox 2638 jornfreiheit 130u IPv4 0x5cee55fb25ea393 0t0 TCP *:17500 (LISTEN) Dropbox 2638 jornfreiheit 185u IPv4 0x5cee55fb7f00393 0t0 TCP localhost:17600 (LISTEN) Dropbox 2638 jornfreiheit 194u IPv4 0x5cee55fb9e31753 0t0 TCP localhost:17603 (LISTEN) node 9070 jornfreiheit 21u IPv6 0x5cee55fb5913843 0t0 TCP *:8080 (LISTEN) Python 9138 jornfreiheit 5u IPv4 0x5cee55fcfdf7753 0t0 TCP localhost:8000 (LISTEN) Wenn Sie nun z.B. einen bestimmten Prozess killen wollen, z.B. den Python-Prozess, der in localhost auf Port 8000 l\u00e4uft, dann geben Sie kill -9 9138 im Terminal ein. 9138 ist die PID des entsprechenden Prozesses.","title":"Prozesse und Ports"}]}